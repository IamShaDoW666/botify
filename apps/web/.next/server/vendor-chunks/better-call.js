"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/better-call";
exports.ids = ["vendor-chunks/better-call"];
exports.modules = {

/***/ "(action-browser)/../../node_modules/better-call/dist/index.js":
/*!****************************************************!*\
  !*** ../../node_modules/better-call/dist/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   APIError: () => (/* binding */ APIError),\n/* harmony export */   _statusCode: () => (/* binding */ _statusCode),\n/* harmony export */   createEndpoint: () => (/* binding */ createEndpoint2),\n/* harmony export */   createInternalContext: () => (/* binding */ createInternalContext),\n/* harmony export */   createMiddleware: () => (/* binding */ createMiddleware),\n/* harmony export */   createRouter: () => (/* binding */ createRouter),\n/* harmony export */   generator: () => (/* binding */ generator),\n/* harmony export */   getCookieKey: () => (/* binding */ getCookieKey),\n/* harmony export */   getHTML: () => (/* binding */ getHTML),\n/* harmony export */   parseCookies: () => (/* binding */ parseCookies),\n/* harmony export */   serializeCookie: () => (/* binding */ serializeCookie),\n/* harmony export */   serializeSignedCookie: () => (/* binding */ serializeSignedCookie),\n/* harmony export */   toResponse: () => (/* binding */ toResponse)\n/* harmony export */ });\n/* harmony import */ var uncrypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uncrypto */ \"(action-browser)/../../node_modules/uncrypto/dist/crypto.node.mjs\");\n/* harmony import */ var rou3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rou3 */ \"(action-browser)/../../node_modules/rou3/dist/index.mjs\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/error.ts\nvar _statusCode = {\n  OK: 200,\n  CREATED: 201,\n  ACCEPTED: 202,\n  NO_CONTENT: 204,\n  MULTIPLE_CHOICES: 300,\n  MOVED_PERMANENTLY: 301,\n  FOUND: 302,\n  SEE_OTHER: 303,\n  NOT_MODIFIED: 304,\n  TEMPORARY_REDIRECT: 307,\n  BAD_REQUEST: 400,\n  UNAUTHORIZED: 401,\n  PAYMENT_REQUIRED: 402,\n  FORBIDDEN: 403,\n  NOT_FOUND: 404,\n  METHOD_NOT_ALLOWED: 405,\n  NOT_ACCEPTABLE: 406,\n  PROXY_AUTHENTICATION_REQUIRED: 407,\n  REQUEST_TIMEOUT: 408,\n  CONFLICT: 409,\n  GONE: 410,\n  LENGTH_REQUIRED: 411,\n  PRECONDITION_FAILED: 412,\n  PAYLOAD_TOO_LARGE: 413,\n  URI_TOO_LONG: 414,\n  UNSUPPORTED_MEDIA_TYPE: 415,\n  RANGE_NOT_SATISFIABLE: 416,\n  EXPECTATION_FAILED: 417,\n  \"I'M_A_TEAPOT\": 418,\n  MISDIRECTED_REQUEST: 421,\n  UNPROCESSABLE_ENTITY: 422,\n  LOCKED: 423,\n  FAILED_DEPENDENCY: 424,\n  TOO_EARLY: 425,\n  UPGRADE_REQUIRED: 426,\n  PRECONDITION_REQUIRED: 428,\n  TOO_MANY_REQUESTS: 429,\n  REQUEST_HEADER_FIELDS_TOO_LARGE: 431,\n  UNAVAILABLE_FOR_LEGAL_REASONS: 451,\n  INTERNAL_SERVER_ERROR: 500,\n  NOT_IMPLEMENTED: 501,\n  BAD_GATEWAY: 502,\n  SERVICE_UNAVAILABLE: 503,\n  GATEWAY_TIMEOUT: 504,\n  HTTP_VERSION_NOT_SUPPORTED: 505,\n  VARIANT_ALSO_NEGOTIATES: 506,\n  INSUFFICIENT_STORAGE: 507,\n  LOOP_DETECTED: 508,\n  NOT_EXTENDED: 510,\n  NETWORK_AUTHENTICATION_REQUIRED: 511\n};\nvar APIError = class extends Error {\n  constructor(status = \"INTERNAL_SERVER_ERROR\", body = void 0, headers = {}, statusCode = typeof status === \"number\" ? status : _statusCode[status]) {\n    super(body?.message);\n    this.status = status;\n    this.body = body;\n    this.headers = headers;\n    this.statusCode = statusCode;\n    this.name = \"APIError\";\n    this.status = status;\n    this.headers = headers;\n    this.statusCode = statusCode;\n    this.body = body ? {\n      code: body?.message?.toUpperCase().replace(/ /g, \"_\").replace(/[^A-Z0-9_]/g, \"\"),\n      ...body\n    } : void 0;\n    this.stack = \"\";\n  }\n};\n\n// src/utils.ts\nasync function getBody(request) {\n  const contentType = request.headers.get(\"content-type\") || \"\";\n  if (!request.body) {\n    return void 0;\n  }\n  if (contentType.includes(\"application/json\")) {\n    return await request.json();\n  }\n  if (contentType.includes(\"application/x-www-form-urlencoded\")) {\n    const formData = await request.formData();\n    const result = {};\n    formData.forEach((value, key) => {\n      result[key] = value.toString();\n    });\n    return result;\n  }\n  if (contentType.includes(\"multipart/form-data\")) {\n    const formData = await request.formData();\n    const result = {};\n    formData.forEach((value, key) => {\n      result[key] = value;\n    });\n    return result;\n  }\n  if (contentType.includes(\"text/plain\")) {\n    return await request.text();\n  }\n  if (contentType.includes(\"application/octet-stream\")) {\n    return await request.arrayBuffer();\n  }\n  if (contentType.includes(\"application/pdf\") || contentType.includes(\"image/\") || contentType.includes(\"video/\")) {\n    const blob = await request.blob();\n    return blob;\n  }\n  if (contentType.includes(\"application/stream\") || request.body instanceof ReadableStream) {\n    return request.body;\n  }\n  return await request.text();\n}\nfunction isAPIError(error) {\n  return error instanceof APIError || error?.name === \"APIError\";\n}\nfunction tryDecode(str) {\n  try {\n    return str.includes(\"%\") ? decodeURIComponent(str) : str;\n  } catch {\n    return str;\n  }\n}\n\n// src/to-response.ts\nfunction isJSONSerializable(value) {\n  if (value === void 0) {\n    return false;\n  }\n  const t = typeof value;\n  if (t === \"string\" || t === \"number\" || t === \"boolean\" || t === null) {\n    return true;\n  }\n  if (t !== \"object\") {\n    return false;\n  }\n  if (Array.isArray(value)) {\n    return true;\n  }\n  if (value.buffer) {\n    return false;\n  }\n  return value.constructor && value.constructor.name === \"Object\" || typeof value.toJSON === \"function\";\n}\nfunction safeStringify(obj, replacer, space) {\n  let id = 0;\n  const seen = /* @__PURE__ */ new WeakMap();\n  const safeReplacer = (key, value) => {\n    if (typeof value === \"bigint\") {\n      return value.toString();\n    }\n    if (typeof value === \"object\" && value !== null) {\n      if (seen.has(value)) {\n        return `[Circular ref-${seen.get(value)}]`;\n      }\n      seen.set(value, id++);\n    }\n    if (replacer) {\n      return replacer(key, value);\n    }\n    return value;\n  };\n  return JSON.stringify(obj, safeReplacer, space);\n}\nfunction isJSONResponse(value) {\n  if (!value || typeof value !== \"object\") {\n    return false;\n  }\n  return \"_flag\" in value && value._flag === \"json\";\n}\nfunction toResponse(data, init) {\n  if (data instanceof Response) {\n    if (init?.headers instanceof Headers) {\n      init.headers.forEach((value, key) => {\n        data.headers.set(key, value);\n      });\n    }\n    return data;\n  }\n  const isJSON = isJSONResponse(data);\n  if (isJSON) {\n    const body2 = data.body;\n    const routerResponse = data.routerResponse;\n    if (routerResponse instanceof Response) {\n      return routerResponse;\n    }\n    const headers2 = new Headers({\n      ...routerResponse?.headers,\n      ...data.headers,\n      ...init?.headers,\n      \"Content-Type\": \"application/json\"\n    });\n    return new Response(JSON.stringify(body2), {\n      ...routerResponse,\n      headers: headers2,\n      status: data.status ?? init?.status ?? routerResponse?.status,\n      statusText: init?.statusText ?? routerResponse?.statusText\n    });\n  }\n  if (isAPIError(data)) {\n    return toResponse(data.body, {\n      status: init?.status ?? data.statusCode,\n      statusText: data.status.toString(),\n      headers: init?.headers || data.headers\n    });\n  }\n  let body = data;\n  let headers = new Headers(init?.headers);\n  if (!data) {\n    if (data === null) {\n      body = JSON.stringify(null);\n    }\n    headers.set(\"content-type\", \"application/json\");\n  } else if (typeof data === \"string\") {\n    body = data;\n    headers.set(\"Content-Type\", \"text/plain\");\n  } else if (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) {\n    body = data;\n    headers.set(\"Content-Type\", \"application/octet-stream\");\n  } else if (data instanceof Blob) {\n    body = data;\n    headers.set(\"Content-Type\", data.type || \"application/octet-stream\");\n  } else if (data instanceof FormData) {\n    body = data;\n  } else if (data instanceof URLSearchParams) {\n    body = data;\n    headers.set(\"Content-Type\", \"application/x-www-form-urlencoded\");\n  } else if (data instanceof ReadableStream) {\n    body = data;\n    headers.set(\"Content-Type\", \"application/octet-stream\");\n  } else if (isJSONSerializable(data)) {\n    body = safeStringify(data);\n    headers.set(\"Content-Type\", \"application/json\");\n  }\n  return new Response(body, {\n    ...init,\n    headers\n  });\n}\n\n// src/validator.ts\nasync function runValidation(options, context = {}) {\n  let request = {\n    body: context.body,\n    query: context.query\n  };\n  if (options.body) {\n    const result = await options.body[\"~standard\"].validate(context.body);\n    if (result.issues) {\n      return {\n        data: null,\n        error: fromError(result.issues, \"body\")\n      };\n    }\n    request.body = result.value;\n  }\n  if (options.query) {\n    const result = await options.query[\"~standard\"].validate(context.query);\n    if (result.issues) {\n      return {\n        data: null,\n        error: fromError(result.issues, \"query\")\n      };\n    }\n    request.query = result.value;\n  }\n  if (options.requireHeaders && !context.headers) {\n    return {\n      data: null,\n      error: { message: \"Headers is required\" }\n    };\n  }\n  if (options.requireRequest && !context.request) {\n    return {\n      data: null,\n      error: { message: \"Request is required\" }\n    };\n  }\n  return {\n    data: request,\n    error: null\n  };\n}\nfunction fromError(error, validating) {\n  const errorMessages = [];\n  for (const issue2 of error) {\n    const message = issue2.message;\n    errorMessages.push(message);\n  }\n  return {\n    message: `Invalid ${validating} parameters`\n  };\n}\n\n// src/crypto.ts\n\nvar algorithm = { name: \"HMAC\", hash: \"SHA-256\" };\nvar getCryptoKey = async (secret) => {\n  const secretBuf = typeof secret === \"string\" ? new TextEncoder().encode(secret) : secret;\n  return await uncrypto__WEBPACK_IMPORTED_MODULE_0__.subtle.importKey(\"raw\", secretBuf, algorithm, false, [\"sign\", \"verify\"]);\n};\nvar verifySignature = async (base64Signature, value, secret) => {\n  try {\n    const signatureBinStr = atob(base64Signature);\n    const signature = new Uint8Array(signatureBinStr.length);\n    for (let i = 0, len = signatureBinStr.length; i < len; i++) {\n      signature[i] = signatureBinStr.charCodeAt(i);\n    }\n    return await uncrypto__WEBPACK_IMPORTED_MODULE_0__.subtle.verify(algorithm, secret, signature, new TextEncoder().encode(value));\n  } catch (e) {\n    return false;\n  }\n};\nvar makeSignature = async (value, secret) => {\n  const key = await getCryptoKey(secret);\n  const signature = await uncrypto__WEBPACK_IMPORTED_MODULE_0__.subtle.sign(algorithm.name, key, new TextEncoder().encode(value));\n  return btoa(String.fromCharCode(...new Uint8Array(signature)));\n};\nvar signCookieValue = async (value, secret) => {\n  const signature = await makeSignature(value, secret);\n  value = `${value}.${signature}`;\n  value = encodeURIComponent(value);\n  return value;\n};\n\n// src/cookies.ts\nvar getCookieKey = (key, prefix) => {\n  let finalKey = key;\n  if (prefix) {\n    if (prefix === \"secure\") {\n      finalKey = \"__Secure-\" + key;\n    } else if (prefix === \"host\") {\n      finalKey = \"__Host-\" + key;\n    } else {\n      return void 0;\n    }\n  }\n  return finalKey;\n};\nfunction parseCookies(str) {\n  if (typeof str !== \"string\") {\n    throw new TypeError(\"argument str must be a string\");\n  }\n  const cookies = /* @__PURE__ */ new Map();\n  let index = 0;\n  while (index < str.length) {\n    const eqIdx = str.indexOf(\"=\", index);\n    if (eqIdx === -1) {\n      break;\n    }\n    let endIdx = str.indexOf(\";\", index);\n    if (endIdx === -1) {\n      endIdx = str.length;\n    } else if (endIdx < eqIdx) {\n      index = str.lastIndexOf(\";\", eqIdx - 1) + 1;\n      continue;\n    }\n    const key = str.slice(index, eqIdx).trim();\n    if (!cookies.has(key)) {\n      let val = str.slice(eqIdx + 1, endIdx).trim();\n      if (val.codePointAt(0) === 34) {\n        val = val.slice(1, -1);\n      }\n      cookies.set(key, tryDecode(val));\n    }\n    index = endIdx + 1;\n  }\n  return cookies;\n}\nvar _serialize = (key, value, opt = {}) => {\n  let cookie;\n  if (opt?.prefix === \"secure\") {\n    cookie = `${`__Secure-${key}`}=${value}`;\n  } else if (opt?.prefix === \"host\") {\n    cookie = `${`__Host-${key}`}=${value}`;\n  } else {\n    cookie = `${key}=${value}`;\n  }\n  if (key.startsWith(\"__Secure-\") && !opt.secure) {\n    opt.secure = true;\n  }\n  if (key.startsWith(\"__Host-\")) {\n    if (!opt.secure) {\n      opt.secure = true;\n    }\n    if (opt.path !== \"/\") {\n      opt.path = \"/\";\n    }\n    if (opt.domain) {\n      opt.domain = void 0;\n    }\n  }\n  if (opt && typeof opt.maxAge === \"number\" && opt.maxAge >= 0) {\n    if (opt.maxAge > 3456e4) {\n      throw new Error(\n        \"Cookies Max-Age SHOULD NOT be greater than 400 days (34560000 seconds) in duration.\"\n      );\n    }\n    cookie += `; Max-Age=${Math.floor(opt.maxAge)}`;\n  }\n  if (opt.domain && opt.prefix !== \"host\") {\n    cookie += `; Domain=${opt.domain}`;\n  }\n  if (opt.path) {\n    cookie += `; Path=${opt.path}`;\n  }\n  if (opt.expires) {\n    if (opt.expires.getTime() - Date.now() > 3456e7) {\n      throw new Error(\n        \"Cookies Expires SHOULD NOT be greater than 400 days (34560000 seconds) in the future.\"\n      );\n    }\n    cookie += `; Expires=${opt.expires.toUTCString()}`;\n  }\n  if (opt.httpOnly) {\n    cookie += \"; HttpOnly\";\n  }\n  if (opt.secure) {\n    cookie += \"; Secure\";\n  }\n  if (opt.sameSite) {\n    cookie += `; SameSite=${opt.sameSite.charAt(0).toUpperCase() + opt.sameSite.slice(1)}`;\n  }\n  if (opt.partitioned) {\n    if (!opt.secure) {\n      opt.secure = true;\n    }\n    cookie += \"; Partitioned\";\n  }\n  return cookie;\n};\nvar serializeCookie = (key, value, opt) => {\n  value = encodeURIComponent(value);\n  return _serialize(key, value, opt);\n};\nvar serializeSignedCookie = async (key, value, secret, opt) => {\n  value = await signCookieValue(value, secret);\n  return _serialize(key, value, opt);\n};\n\n// src/context.ts\nvar createInternalContext = async (context, {\n  options,\n  path\n}) => {\n  const headers = new Headers();\n  const { data, error } = await runValidation(options, context);\n  if (error) {\n    throw new APIError(400, {\n      message: error.message,\n      code: \"VALIDATION_ERROR\"\n    });\n  }\n  const requestHeaders = \"headers\" in context ? context.headers instanceof Headers ? context.headers : new Headers(context.headers) : \"request\" in context && context.request instanceof Request ? context.request.headers : null;\n  const requestCookies = requestHeaders?.get(\"cookie\");\n  const parsedCookies = requestCookies ? parseCookies(requestCookies) : void 0;\n  const internalContext = {\n    ...context,\n    body: data.body,\n    query: data.query,\n    path: context.path || path,\n    context: \"context\" in context && context.context ? context.context : {},\n    returned: void 0,\n    headers: context?.headers,\n    request: context?.request,\n    params: \"params\" in context ? context.params : void 0,\n    method: context.method,\n    setHeader: (key, value) => {\n      headers.set(key, value);\n    },\n    getHeader: (key) => {\n      if (!requestHeaders) return null;\n      return requestHeaders.get(key);\n    },\n    getCookie: (key, prefix) => {\n      const finalKey = getCookieKey(key, prefix);\n      if (!finalKey) {\n        return null;\n      }\n      return parsedCookies?.get(finalKey) || null;\n    },\n    getSignedCookie: async (key, secret, prefix) => {\n      const finalKey = getCookieKey(key, prefix);\n      if (!finalKey) {\n        return null;\n      }\n      const value = parsedCookies?.get(finalKey);\n      if (!value) {\n        return null;\n      }\n      const signatureStartPos = value.lastIndexOf(\".\");\n      if (signatureStartPos < 1) {\n        return null;\n      }\n      const signedValue = value.substring(0, signatureStartPos);\n      const signature = value.substring(signatureStartPos + 1);\n      if (signature.length !== 44 || !signature.endsWith(\"=\")) {\n        return null;\n      }\n      const secretKey = await getCryptoKey(secret);\n      const isVerified = await verifySignature(signature, signedValue, secretKey);\n      return isVerified ? signedValue : false;\n    },\n    setCookie: (key, value, options2) => {\n      const cookie = serializeCookie(key, value, options2);\n      headers.append(\"set-cookie\", cookie);\n      return cookie;\n    },\n    setSignedCookie: async (key, value, secret, options2) => {\n      const cookie = await serializeSignedCookie(key, value, secret, options2);\n      headers.append(\"set-cookie\", cookie);\n      return cookie;\n    },\n    redirect: (url) => {\n      headers.set(\"location\", url);\n      return new APIError(\"FOUND\", void 0, headers);\n    },\n    error: (status, body, headers2) => {\n      return new APIError(status, body, headers2);\n    },\n    json: (json, routerResponse) => {\n      if (!context.asResponse) {\n        return json;\n      }\n      return {\n        body: routerResponse?.body || json,\n        routerResponse,\n        _flag: \"json\"\n      };\n    },\n    responseHeaders: headers\n  };\n  for (const middleware of options.use || []) {\n    const response = await middleware({\n      ...internalContext,\n      returnHeaders: true,\n      asResponse: false\n    });\n    if (response.response) {\n      Object.assign(internalContext.context, response.response);\n    }\n    if (response.headers) {\n      response.headers.forEach((value, key) => {\n        internalContext.responseHeaders.set(key, value);\n      });\n    }\n  }\n  return internalContext;\n};\n\n// src/middleware.ts\nfunction createMiddleware(optionsOrHandler, handler) {\n  const internalHandler = async (inputCtx) => {\n    const context = inputCtx;\n    const _handler = typeof optionsOrHandler === \"function\" ? optionsOrHandler : handler;\n    const options = typeof optionsOrHandler === \"function\" ? {} : optionsOrHandler;\n    const internalContext = await createInternalContext(context, {\n      options,\n      path: \"/\"\n    });\n    if (!_handler) {\n      throw new Error(\"handler must be defined\");\n    }\n    const response = await _handler(internalContext);\n    const headers = internalContext.responseHeaders;\n    return context.returnHeaders ? {\n      headers,\n      response\n    } : response;\n  };\n  internalHandler.options = typeof optionsOrHandler === \"function\" ? {} : optionsOrHandler;\n  return internalHandler;\n}\ncreateMiddleware.create = (opts) => {\n  function fn(optionsOrHandler, handler) {\n    if (typeof optionsOrHandler === \"function\") {\n      return createMiddleware(\n        {\n          use: opts?.use\n        },\n        optionsOrHandler\n      );\n    }\n    if (!handler) {\n      throw new Error(\"Middleware handler is required\");\n    }\n    const middleware = createMiddleware(\n      {\n        ...optionsOrHandler,\n        method: \"*\",\n        use: [...opts?.use || [], ...optionsOrHandler.use || []]\n      },\n      handler\n    );\n    return middleware;\n  }\n  return fn;\n};\n\n// src/endpoint.ts\nvar createEndpoint2 = (path, options, handler) => {\n  const internalHandler = async (...inputCtx) => {\n    const context = inputCtx[0] || {};\n    const internalContext = await createInternalContext(context, {\n      options,\n      path\n    });\n    const response = await handler(internalContext).catch(async (e) => {\n      if (isAPIError(e)) {\n        const onAPIError = options.onAPIError;\n        if (onAPIError) {\n          await onAPIError(e);\n        }\n        if (context.asResponse) {\n          return e;\n        }\n      }\n      throw e;\n    });\n    const headers = internalContext.responseHeaders;\n    return context.asResponse ? toResponse(response, {\n      headers\n    }) : context.returnHeaders ? {\n      headers,\n      response\n    } : response;\n  };\n  internalHandler.options = options;\n  internalHandler.path = path;\n  return internalHandler;\n};\ncreateEndpoint2.create = (opts) => {\n  return (path, options, handler) => {\n    return createEndpoint2(\n      path,\n      {\n        ...options,\n        use: [...options?.use || [], ...opts?.use || []]\n      },\n      handler\n    );\n  };\n};\n\n// src/router.ts\n\n\n// node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/core/core.js\nvar NEVER = Object.freeze({\n  status: \"aborted\"\n});\n// @__NO_SIDE_EFFECTS__\nfunction $constructor(name, initializer3, params) {\n  function init(inst, def) {\n    var _a;\n    Object.defineProperty(inst, \"_zod\", {\n      value: inst._zod ?? {},\n      enumerable: false\n    });\n    (_a = inst._zod).traits ?? (_a.traits = /* @__PURE__ */ new Set());\n    inst._zod.traits.add(name);\n    initializer3(inst, def);\n    for (const k in _.prototype) {\n      if (!(k in inst))\n        Object.defineProperty(inst, k, { value: _.prototype[k].bind(inst) });\n    }\n    inst._zod.constr = _;\n    inst._zod.def = def;\n  }\n  const Parent = params?.Parent ?? Object;\n  class Definition extends Parent {\n  }\n  Object.defineProperty(Definition, \"name\", { value: name });\n  function _(def) {\n    var _a;\n    const inst = params?.Parent ? new Definition() : this;\n    init(inst, def);\n    (_a = inst._zod).deferred ?? (_a.deferred = []);\n    for (const fn of inst._zod.deferred) {\n      fn();\n    }\n    return inst;\n  }\n  Object.defineProperty(_, \"init\", { value: init });\n  Object.defineProperty(_, Symbol.hasInstance, {\n    value: (inst) => {\n      if (params?.Parent && inst instanceof params.Parent)\n        return true;\n      return inst?._zod?.traits?.has(name);\n    }\n  });\n  Object.defineProperty(_, \"name\", { value: name });\n  return _;\n}\nvar $brand = Symbol(\"zod_brand\");\nvar $ZodAsyncError = class extends Error {\n  constructor() {\n    super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);\n  }\n};\nvar globalConfig = {};\nfunction config(newConfig) {\n  if (newConfig)\n    Object.assign(globalConfig, newConfig);\n  return globalConfig;\n}\n\n// node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/core/util.js\nvar util_exports = {};\n__export(util_exports, {\n  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES,\n  Class: () => Class,\n  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,\n  aborted: () => aborted,\n  allowsEval: () => allowsEval,\n  assert: () => assert,\n  assertEqual: () => assertEqual,\n  assertIs: () => assertIs,\n  assertNever: () => assertNever,\n  assertNotEqual: () => assertNotEqual,\n  assignProp: () => assignProp,\n  cached: () => cached,\n  captureStackTrace: () => captureStackTrace,\n  cleanEnum: () => cleanEnum,\n  cleanRegex: () => cleanRegex,\n  clone: () => clone,\n  createTransparentProxy: () => createTransparentProxy,\n  defineLazy: () => defineLazy,\n  esc: () => esc,\n  escapeRegex: () => escapeRegex,\n  extend: () => extend,\n  finalizeIssue: () => finalizeIssue,\n  floatSafeRemainder: () => floatSafeRemainder,\n  getElementAtPath: () => getElementAtPath,\n  getEnumValues: () => getEnumValues,\n  getLengthableOrigin: () => getLengthableOrigin,\n  getParsedType: () => getParsedType,\n  getSizableOrigin: () => getSizableOrigin,\n  isObject: () => isObject,\n  isPlainObject: () => isPlainObject,\n  issue: () => issue,\n  joinValues: () => joinValues,\n  jsonStringifyReplacer: () => jsonStringifyReplacer,\n  merge: () => merge,\n  normalizeParams: () => normalizeParams,\n  nullish: () => nullish,\n  numKeys: () => numKeys,\n  omit: () => omit,\n  optionalKeys: () => optionalKeys,\n  partial: () => partial,\n  pick: () => pick,\n  prefixIssues: () => prefixIssues,\n  primitiveTypes: () => primitiveTypes,\n  promiseAllObject: () => promiseAllObject,\n  propertyKeyTypes: () => propertyKeyTypes,\n  randomString: () => randomString,\n  required: () => required,\n  stringifyPrimitive: () => stringifyPrimitive,\n  unwrapMessage: () => unwrapMessage\n});\nfunction assertEqual(val) {\n  return val;\n}\nfunction assertNotEqual(val) {\n  return val;\n}\nfunction assertIs(_arg) {\n}\nfunction assertNever(_x) {\n  throw new Error();\n}\nfunction assert(_) {\n}\nfunction getEnumValues(entries) {\n  const numericValues = Object.values(entries).filter((v) => typeof v === \"number\");\n  const values = Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);\n  return values;\n}\nfunction joinValues(array2, separator = \"|\") {\n  return array2.map((val) => stringifyPrimitive(val)).join(separator);\n}\nfunction jsonStringifyReplacer(_, value) {\n  if (typeof value === \"bigint\")\n    return value.toString();\n  return value;\n}\nfunction cached(getter) {\n  const set = false;\n  return {\n    get value() {\n      if (!set) {\n        const value = getter();\n        Object.defineProperty(this, \"value\", { value });\n        return value;\n      }\n      throw new Error(\"cached value already set\");\n    }\n  };\n}\nfunction nullish(input) {\n  return input === null || input === void 0;\n}\nfunction cleanRegex(source) {\n  const start = source.startsWith(\"^\") ? 1 : 0;\n  const end = source.endsWith(\"$\") ? source.length - 1 : source.length;\n  return source.slice(start, end);\n}\nfunction floatSafeRemainder(val, step) {\n  const valDecCount = (val.toString().split(\".\")[1] || \"\").length;\n  const stepDecCount = (step.toString().split(\".\")[1] || \"\").length;\n  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\n  const valInt = Number.parseInt(val.toFixed(decCount).replace(\".\", \"\"));\n  const stepInt = Number.parseInt(step.toFixed(decCount).replace(\".\", \"\"));\n  return valInt % stepInt / 10 ** decCount;\n}\nfunction defineLazy(object, key, getter) {\n  const set = false;\n  Object.defineProperty(object, key, {\n    get() {\n      if (!set) {\n        const value = getter();\n        object[key] = value;\n        return value;\n      }\n      throw new Error(\"cached value already set\");\n    },\n    set(v) {\n      Object.defineProperty(object, key, {\n        value: v\n        // configurable: true,\n      });\n    },\n    configurable: true\n  });\n}\nfunction assignProp(target, prop, value) {\n  Object.defineProperty(target, prop, {\n    value,\n    writable: true,\n    enumerable: true,\n    configurable: true\n  });\n}\nfunction getElementAtPath(obj, path) {\n  if (!path)\n    return obj;\n  return path.reduce((acc, key) => acc?.[key], obj);\n}\nfunction promiseAllObject(promisesObj) {\n  const keys = Object.keys(promisesObj);\n  const promises = keys.map((key) => promisesObj[key]);\n  return Promise.all(promises).then((results) => {\n    const resolvedObj = {};\n    for (let i = 0; i < keys.length; i++) {\n      resolvedObj[keys[i]] = results[i];\n    }\n    return resolvedObj;\n  });\n}\nfunction randomString(length = 10) {\n  const chars = \"abcdefghijklmnopqrstuvwxyz\";\n  let str = \"\";\n  for (let i = 0; i < length; i++) {\n    str += chars[Math.floor(Math.random() * chars.length)];\n  }\n  return str;\n}\nfunction esc(str) {\n  return JSON.stringify(str);\n}\nvar captureStackTrace = Error.captureStackTrace ? Error.captureStackTrace : (..._args) => {\n};\nfunction isObject(data) {\n  return typeof data === \"object\" && data !== null && !Array.isArray(data);\n}\nvar allowsEval = cached(() => {\n  if (typeof navigator !== \"undefined\" && navigator?.userAgent?.includes(\"Cloudflare\")) {\n    return false;\n  }\n  try {\n    const F = Function;\n    new F(\"\");\n    return true;\n  } catch (_) {\n    return false;\n  }\n});\nfunction isPlainObject(o) {\n  if (isObject(o) === false)\n    return false;\n  const ctor = o.constructor;\n  if (ctor === void 0)\n    return true;\n  const prot = ctor.prototype;\n  if (isObject(prot) === false)\n    return false;\n  if (Object.prototype.hasOwnProperty.call(prot, \"isPrototypeOf\") === false) {\n    return false;\n  }\n  return true;\n}\nfunction numKeys(data) {\n  let keyCount = 0;\n  for (const key in data) {\n    if (Object.prototype.hasOwnProperty.call(data, key)) {\n      keyCount++;\n    }\n  }\n  return keyCount;\n}\nvar getParsedType = (data) => {\n  const t = typeof data;\n  switch (t) {\n    case \"undefined\":\n      return \"undefined\";\n    case \"string\":\n      return \"string\";\n    case \"number\":\n      return Number.isNaN(data) ? \"nan\" : \"number\";\n    case \"boolean\":\n      return \"boolean\";\n    case \"function\":\n      return \"function\";\n    case \"bigint\":\n      return \"bigint\";\n    case \"symbol\":\n      return \"symbol\";\n    case \"object\":\n      if (Array.isArray(data)) {\n        return \"array\";\n      }\n      if (data === null) {\n        return \"null\";\n      }\n      if (data.then && typeof data.then === \"function\" && data.catch && typeof data.catch === \"function\") {\n        return \"promise\";\n      }\n      if (typeof Map !== \"undefined\" && data instanceof Map) {\n        return \"map\";\n      }\n      if (typeof Set !== \"undefined\" && data instanceof Set) {\n        return \"set\";\n      }\n      if (typeof Date !== \"undefined\" && data instanceof Date) {\n        return \"date\";\n      }\n      if (typeof File !== \"undefined\" && data instanceof File) {\n        return \"file\";\n      }\n      return \"object\";\n    default:\n      throw new Error(`Unknown data type: ${t}`);\n  }\n};\nvar propertyKeyTypes = /* @__PURE__ */ new Set([\"string\", \"number\", \"symbol\"]);\nvar primitiveTypes = /* @__PURE__ */ new Set([\"string\", \"number\", \"bigint\", \"boolean\", \"symbol\", \"undefined\"]);\nfunction escapeRegex(str) {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\nfunction clone(inst, def, params) {\n  const cl = new inst._zod.constr(def ?? inst._zod.def);\n  if (!def || params?.parent)\n    cl._zod.parent = inst;\n  return cl;\n}\nfunction normalizeParams(_params) {\n  const params = _params;\n  if (!params)\n    return {};\n  if (typeof params === \"string\")\n    return { error: () => params };\n  if (params?.message !== void 0) {\n    if (params?.error !== void 0)\n      throw new Error(\"Cannot specify both `message` and `error` params\");\n    params.error = params.message;\n  }\n  delete params.message;\n  if (typeof params.error === \"string\")\n    return { ...params, error: () => params.error };\n  return params;\n}\nfunction createTransparentProxy(getter) {\n  let target;\n  return new Proxy({}, {\n    get(_, prop, receiver) {\n      target ?? (target = getter());\n      return Reflect.get(target, prop, receiver);\n    },\n    set(_, prop, value, receiver) {\n      target ?? (target = getter());\n      return Reflect.set(target, prop, value, receiver);\n    },\n    has(_, prop) {\n      target ?? (target = getter());\n      return Reflect.has(target, prop);\n    },\n    deleteProperty(_, prop) {\n      target ?? (target = getter());\n      return Reflect.deleteProperty(target, prop);\n    },\n    ownKeys(_) {\n      target ?? (target = getter());\n      return Reflect.ownKeys(target);\n    },\n    getOwnPropertyDescriptor(_, prop) {\n      target ?? (target = getter());\n      return Reflect.getOwnPropertyDescriptor(target, prop);\n    },\n    defineProperty(_, prop, descriptor) {\n      target ?? (target = getter());\n      return Reflect.defineProperty(target, prop, descriptor);\n    }\n  });\n}\nfunction stringifyPrimitive(value) {\n  if (typeof value === \"bigint\")\n    return value.toString() + \"n\";\n  if (typeof value === \"string\")\n    return `\"${value}\"`;\n  return `${value}`;\n}\nfunction optionalKeys(shape) {\n  return Object.keys(shape).filter((k) => {\n    return shape[k]._zod.optin === \"optional\" && shape[k]._zod.optout === \"optional\";\n  });\n}\nvar NUMBER_FORMAT_RANGES = {\n  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],\n  int32: [-2147483648, 2147483647],\n  uint32: [0, 4294967295],\n  float32: [-34028234663852886e22, 34028234663852886e22],\n  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]\n};\nvar BIGINT_FORMAT_RANGES = {\n  int64: [/* @__PURE__ */ BigInt(\"-9223372036854775808\"), /* @__PURE__ */ BigInt(\"9223372036854775807\")],\n  uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt(\"18446744073709551615\")]\n};\nfunction pick(schema, mask) {\n  const newShape = {};\n  const currDef = schema._zod.def;\n  for (const key in mask) {\n    if (!(key in currDef.shape)) {\n      throw new Error(`Unrecognized key: \"${key}\"`);\n    }\n    if (!mask[key])\n      continue;\n    newShape[key] = currDef.shape[key];\n  }\n  return clone(schema, {\n    ...schema._zod.def,\n    shape: newShape,\n    checks: []\n  });\n}\nfunction omit(schema, mask) {\n  const newShape = { ...schema._zod.def.shape };\n  const currDef = schema._zod.def;\n  for (const key in mask) {\n    if (!(key in currDef.shape)) {\n      throw new Error(`Unrecognized key: \"${key}\"`);\n    }\n    if (!mask[key])\n      continue;\n    delete newShape[key];\n  }\n  return clone(schema, {\n    ...schema._zod.def,\n    shape: newShape,\n    checks: []\n  });\n}\nfunction extend(schema, shape) {\n  if (!isPlainObject(shape)) {\n    throw new Error(\"Invalid input to extend: expected a plain object\");\n  }\n  const def = {\n    ...schema._zod.def,\n    get shape() {\n      const _shape = { ...schema._zod.def.shape, ...shape };\n      assignProp(this, \"shape\", _shape);\n      return _shape;\n    },\n    checks: []\n    // delete existing checks\n  };\n  return clone(schema, def);\n}\nfunction merge(a, b) {\n  return clone(a, {\n    ...a._zod.def,\n    get shape() {\n      const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };\n      assignProp(this, \"shape\", _shape);\n      return _shape;\n    },\n    catchall: b._zod.def.catchall,\n    checks: []\n    // delete existing checks\n  });\n}\nfunction partial(Class2, schema, mask) {\n  const oldShape = schema._zod.def.shape;\n  const shape = { ...oldShape };\n  if (mask) {\n    for (const key in mask) {\n      if (!(key in oldShape)) {\n        throw new Error(`Unrecognized key: \"${key}\"`);\n      }\n      if (!mask[key])\n        continue;\n      shape[key] = Class2 ? new Class2({\n        type: \"optional\",\n        innerType: oldShape[key]\n      }) : oldShape[key];\n    }\n  } else {\n    for (const key in oldShape) {\n      shape[key] = Class2 ? new Class2({\n        type: \"optional\",\n        innerType: oldShape[key]\n      }) : oldShape[key];\n    }\n  }\n  return clone(schema, {\n    ...schema._zod.def,\n    shape,\n    checks: []\n  });\n}\nfunction required(Class2, schema, mask) {\n  const oldShape = schema._zod.def.shape;\n  const shape = { ...oldShape };\n  if (mask) {\n    for (const key in mask) {\n      if (!(key in shape)) {\n        throw new Error(`Unrecognized key: \"${key}\"`);\n      }\n      if (!mask[key])\n        continue;\n      shape[key] = new Class2({\n        type: \"nonoptional\",\n        innerType: oldShape[key]\n      });\n    }\n  } else {\n    for (const key in oldShape) {\n      shape[key] = new Class2({\n        type: \"nonoptional\",\n        innerType: oldShape[key]\n      });\n    }\n  }\n  return clone(schema, {\n    ...schema._zod.def,\n    shape,\n    // optional: [],\n    checks: []\n  });\n}\nfunction aborted(x, startIndex = 0) {\n  for (let i = startIndex; i < x.issues.length; i++) {\n    if (x.issues[i]?.continue !== true)\n      return true;\n  }\n  return false;\n}\nfunction prefixIssues(path, issues) {\n  return issues.map((iss) => {\n    var _a;\n    (_a = iss).path ?? (_a.path = []);\n    iss.path.unshift(path);\n    return iss;\n  });\n}\nfunction unwrapMessage(message) {\n  return typeof message === \"string\" ? message : message?.message;\n}\nfunction finalizeIssue(iss, ctx, config2) {\n  const full = { ...iss, path: iss.path ?? [] };\n  if (!iss.message) {\n    const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config2.customError?.(iss)) ?? unwrapMessage(config2.localeError?.(iss)) ?? \"Invalid input\";\n    full.message = message;\n  }\n  delete full.inst;\n  delete full.continue;\n  if (!ctx?.reportInput) {\n    delete full.input;\n  }\n  return full;\n}\nfunction getSizableOrigin(input) {\n  if (input instanceof Set)\n    return \"set\";\n  if (input instanceof Map)\n    return \"map\";\n  if (input instanceof File)\n    return \"file\";\n  return \"unknown\";\n}\nfunction getLengthableOrigin(input) {\n  if (Array.isArray(input))\n    return \"array\";\n  if (typeof input === \"string\")\n    return \"string\";\n  return \"unknown\";\n}\nfunction issue(...args) {\n  const [iss, input, inst] = args;\n  if (typeof iss === \"string\") {\n    return {\n      message: iss,\n      code: \"custom\",\n      input,\n      inst\n    };\n  }\n  return { ...iss };\n}\nfunction cleanEnum(obj) {\n  return Object.entries(obj).filter(([k, _]) => {\n    return Number.isNaN(Number.parseInt(k, 10));\n  }).map((el) => el[1]);\n}\nvar Class = class {\n  constructor(..._args) {\n  }\n};\n\n// node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/core/errors.js\nvar initializer = (inst, def) => {\n  inst.name = \"$ZodError\";\n  Object.defineProperty(inst, \"_zod\", {\n    value: inst._zod,\n    enumerable: false\n  });\n  Object.defineProperty(inst, \"issues\", {\n    value: def,\n    enumerable: false\n  });\n  Object.defineProperty(inst, \"message\", {\n    get() {\n      return JSON.stringify(def, jsonStringifyReplacer, 2);\n    },\n    enumerable: true\n    // configurable: false,\n  });\n  Object.defineProperty(inst, \"toString\", {\n    value: () => inst.message,\n    enumerable: false\n  });\n};\nvar $ZodError = $constructor(\"$ZodError\", initializer);\nvar $ZodRealError = $constructor(\"$ZodError\", initializer, { Parent: Error });\nfunction flattenError(error, mapper = (issue2) => issue2.message) {\n  const fieldErrors = {};\n  const formErrors = [];\n  for (const sub of error.issues) {\n    if (sub.path.length > 0) {\n      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];\n      fieldErrors[sub.path[0]].push(mapper(sub));\n    } else {\n      formErrors.push(mapper(sub));\n    }\n  }\n  return { formErrors, fieldErrors };\n}\nfunction formatError(error, _mapper) {\n  const mapper = _mapper || function(issue2) {\n    return issue2.message;\n  };\n  const fieldErrors = { _errors: [] };\n  const processError = (error2) => {\n    for (const issue2 of error2.issues) {\n      if (issue2.code === \"invalid_union\" && issue2.errors.length) {\n        issue2.errors.map((issues) => processError({ issues }));\n      } else if (issue2.code === \"invalid_key\") {\n        processError({ issues: issue2.issues });\n      } else if (issue2.code === \"invalid_element\") {\n        processError({ issues: issue2.issues });\n      } else if (issue2.path.length === 0) {\n        fieldErrors._errors.push(mapper(issue2));\n      } else {\n        let curr = fieldErrors;\n        let i = 0;\n        while (i < issue2.path.length) {\n          const el = issue2.path[i];\n          const terminal = i === issue2.path.length - 1;\n          if (!terminal) {\n            curr[el] = curr[el] || { _errors: [] };\n          } else {\n            curr[el] = curr[el] || { _errors: [] };\n            curr[el]._errors.push(mapper(issue2));\n          }\n          curr = curr[el];\n          i++;\n        }\n      }\n    }\n  };\n  processError(error);\n  return fieldErrors;\n}\n\n// node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/core/parse.js\nvar _parse = (_Err) => (schema, value, _ctx, _params) => {\n  const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };\n  const result = schema._zod.run({ value, issues: [] }, ctx);\n  if (result instanceof Promise) {\n    throw new $ZodAsyncError();\n  }\n  if (result.issues.length) {\n    const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));\n    captureStackTrace(e, _params?.callee);\n    throw e;\n  }\n  return result.value;\n};\nvar _parseAsync = (_Err) => async (schema, value, _ctx, params) => {\n  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };\n  let result = schema._zod.run({ value, issues: [] }, ctx);\n  if (result instanceof Promise)\n    result = await result;\n  if (result.issues.length) {\n    const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));\n    captureStackTrace(e, params?.callee);\n    throw e;\n  }\n  return result.value;\n};\nvar _safeParse = (_Err) => (schema, value, _ctx) => {\n  const ctx = _ctx ? { ..._ctx, async: false } : { async: false };\n  const result = schema._zod.run({ value, issues: [] }, ctx);\n  if (result instanceof Promise) {\n    throw new $ZodAsyncError();\n  }\n  return result.issues.length ? {\n    success: false,\n    error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))\n  } : { success: true, data: result.value };\n};\nvar safeParse = /* @__PURE__ */ _safeParse($ZodRealError);\nvar _safeParseAsync = (_Err) => async (schema, value, _ctx) => {\n  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };\n  let result = schema._zod.run({ value, issues: [] }, ctx);\n  if (result instanceof Promise)\n    result = await result;\n  return result.issues.length ? {\n    success: false,\n    error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))\n  } : { success: true, data: result.value };\n};\nvar safeParseAsync = /* @__PURE__ */ _safeParseAsync($ZodRealError);\n\n// node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/core/checks.js\nvar $ZodCheck = /* @__PURE__ */ $constructor(\"$ZodCheck\", (inst, def) => {\n  var _a;\n  inst._zod ?? (inst._zod = {});\n  inst._zod.def = def;\n  (_a = inst._zod).onattach ?? (_a.onattach = []);\n});\nvar $ZodCheckMaxLength = /* @__PURE__ */ $constructor(\"$ZodCheckMaxLength\", (inst, def) => {\n  var _a;\n  $ZodCheck.init(inst, def);\n  (_a = inst._zod.def).when ?? (_a.when = (payload) => {\n    const val = payload.value;\n    return !nullish(val) && val.length !== void 0;\n  });\n  inst._zod.onattach.push((inst2) => {\n    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;\n    if (def.maximum < curr)\n      inst2._zod.bag.maximum = def.maximum;\n  });\n  inst._zod.check = (payload) => {\n    const input = payload.value;\n    const length = input.length;\n    if (length <= def.maximum)\n      return;\n    const origin = getLengthableOrigin(input);\n    payload.issues.push({\n      origin,\n      code: \"too_big\",\n      maximum: def.maximum,\n      inclusive: true,\n      input,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCheckMinLength = /* @__PURE__ */ $constructor(\"$ZodCheckMinLength\", (inst, def) => {\n  var _a;\n  $ZodCheck.init(inst, def);\n  (_a = inst._zod.def).when ?? (_a.when = (payload) => {\n    const val = payload.value;\n    return !nullish(val) && val.length !== void 0;\n  });\n  inst._zod.onattach.push((inst2) => {\n    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;\n    if (def.minimum > curr)\n      inst2._zod.bag.minimum = def.minimum;\n  });\n  inst._zod.check = (payload) => {\n    const input = payload.value;\n    const length = input.length;\n    if (length >= def.minimum)\n      return;\n    const origin = getLengthableOrigin(input);\n    payload.issues.push({\n      origin,\n      code: \"too_small\",\n      minimum: def.minimum,\n      inclusive: true,\n      input,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCheckLengthEquals = /* @__PURE__ */ $constructor(\"$ZodCheckLengthEquals\", (inst, def) => {\n  var _a;\n  $ZodCheck.init(inst, def);\n  (_a = inst._zod.def).when ?? (_a.when = (payload) => {\n    const val = payload.value;\n    return !nullish(val) && val.length !== void 0;\n  });\n  inst._zod.onattach.push((inst2) => {\n    const bag = inst2._zod.bag;\n    bag.minimum = def.length;\n    bag.maximum = def.length;\n    bag.length = def.length;\n  });\n  inst._zod.check = (payload) => {\n    const input = payload.value;\n    const length = input.length;\n    if (length === def.length)\n      return;\n    const origin = getLengthableOrigin(input);\n    const tooBig = length > def.length;\n    payload.issues.push({\n      origin,\n      ...tooBig ? { code: \"too_big\", maximum: def.length } : { code: \"too_small\", minimum: def.length },\n      inclusive: true,\n      exact: true,\n      input: payload.value,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCheckOverwrite = /* @__PURE__ */ $constructor(\"$ZodCheckOverwrite\", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  inst._zod.check = (payload) => {\n    payload.value = def.tx(payload.value);\n  };\n});\n\n// node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/core/doc.js\nvar Doc = class {\n  constructor(args = []) {\n    this.content = [];\n    this.indent = 0;\n    if (this)\n      this.args = args;\n  }\n  indented(fn) {\n    this.indent += 1;\n    fn(this);\n    this.indent -= 1;\n  }\n  write(arg) {\n    if (typeof arg === \"function\") {\n      arg(this, { execution: \"sync\" });\n      arg(this, { execution: \"async\" });\n      return;\n    }\n    const content = arg;\n    const lines = content.split(\"\\n\").filter((x) => x);\n    const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));\n    const dedented = lines.map((x) => x.slice(minIndent)).map((x) => \" \".repeat(this.indent * 2) + x);\n    for (const line of dedented) {\n      this.content.push(line);\n    }\n  }\n  compile() {\n    const F = Function;\n    const args = this?.args;\n    const content = this?.content ?? [``];\n    const lines = [...content.map((x) => `  ${x}`)];\n    return new F(...args, lines.join(\"\\n\"));\n  }\n};\n\n// node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/core/versions.js\nvar version = {\n  major: 4,\n  minor: 0,\n  patch: 0\n};\n\n// node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/core/schemas.js\nvar $ZodType = /* @__PURE__ */ $constructor(\"$ZodType\", (inst, def) => {\n  var _a;\n  inst ?? (inst = {});\n  inst._zod.def = def;\n  inst._zod.bag = inst._zod.bag || {};\n  inst._zod.version = version;\n  const checks = [...inst._zod.def.checks ?? []];\n  if (inst._zod.traits.has(\"$ZodCheck\")) {\n    checks.unshift(inst);\n  }\n  for (const ch of checks) {\n    for (const fn of ch._zod.onattach) {\n      fn(inst);\n    }\n  }\n  if (checks.length === 0) {\n    (_a = inst._zod).deferred ?? (_a.deferred = []);\n    inst._zod.deferred?.push(() => {\n      inst._zod.run = inst._zod.parse;\n    });\n  } else {\n    const runChecks = (payload, checks2, ctx) => {\n      let isAborted = aborted(payload);\n      let asyncResult;\n      for (const ch of checks2) {\n        if (ch._zod.def.when) {\n          const shouldRun = ch._zod.def.when(payload);\n          if (!shouldRun)\n            continue;\n        } else if (isAborted) {\n          continue;\n        }\n        const currLen = payload.issues.length;\n        const _ = ch._zod.check(payload);\n        if (_ instanceof Promise && ctx?.async === false) {\n          throw new $ZodAsyncError();\n        }\n        if (asyncResult || _ instanceof Promise) {\n          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {\n            await _;\n            const nextLen = payload.issues.length;\n            if (nextLen === currLen)\n              return;\n            if (!isAborted)\n              isAborted = aborted(payload, currLen);\n          });\n        } else {\n          const nextLen = payload.issues.length;\n          if (nextLen === currLen)\n            continue;\n          if (!isAborted)\n            isAborted = aborted(payload, currLen);\n        }\n      }\n      if (asyncResult) {\n        return asyncResult.then(() => {\n          return payload;\n        });\n      }\n      return payload;\n    };\n    inst._zod.run = (payload, ctx) => {\n      const result = inst._zod.parse(payload, ctx);\n      if (result instanceof Promise) {\n        if (ctx.async === false)\n          throw new $ZodAsyncError();\n        return result.then((result2) => runChecks(result2, checks, ctx));\n      }\n      return runChecks(result, checks, ctx);\n    };\n  }\n  inst[\"~standard\"] = {\n    validate: (value) => {\n      try {\n        const r = safeParse(inst, value);\n        return r.success ? { value: r.data } : { issues: r.error?.issues };\n      } catch (_) {\n        return safeParseAsync(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });\n      }\n    },\n    vendor: \"zod\",\n    version: 1\n  };\n});\nvar $ZodUnknown = /* @__PURE__ */ $constructor(\"$ZodUnknown\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload) => payload;\n});\nvar $ZodNever = /* @__PURE__ */ $constructor(\"$ZodNever\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, _ctx) => {\n    payload.issues.push({\n      expected: \"never\",\n      code: \"invalid_type\",\n      input: payload.value,\n      inst\n    });\n    return payload;\n  };\n});\nfunction handleArrayResult(result, final, index) {\n  if (result.issues.length) {\n    final.issues.push(...prefixIssues(index, result.issues));\n  }\n  final.value[index] = result.value;\n}\nvar $ZodArray = /* @__PURE__ */ $constructor(\"$ZodArray\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, ctx) => {\n    const input = payload.value;\n    if (!Array.isArray(input)) {\n      payload.issues.push({\n        expected: \"array\",\n        code: \"invalid_type\",\n        input,\n        inst\n      });\n      return payload;\n    }\n    payload.value = Array(input.length);\n    const proms = [];\n    for (let i = 0; i < input.length; i++) {\n      const item = input[i];\n      const result = def.element._zod.run({\n        value: item,\n        issues: []\n      }, ctx);\n      if (result instanceof Promise) {\n        proms.push(result.then((result2) => handleArrayResult(result2, payload, i)));\n      } else {\n        handleArrayResult(result, payload, i);\n      }\n    }\n    if (proms.length) {\n      return Promise.all(proms).then(() => payload);\n    }\n    return payload;\n  };\n});\nfunction handleObjectResult(result, final, key) {\n  if (result.issues.length) {\n    final.issues.push(...prefixIssues(key, result.issues));\n  }\n  final.value[key] = result.value;\n}\nfunction handleOptionalObjectResult(result, final, key, input) {\n  if (result.issues.length) {\n    if (input[key] === void 0) {\n      if (key in input) {\n        final.value[key] = void 0;\n      } else {\n        final.value[key] = result.value;\n      }\n    } else {\n      final.issues.push(...prefixIssues(key, result.issues));\n    }\n  } else if (result.value === void 0) {\n    if (key in input)\n      final.value[key] = void 0;\n  } else {\n    final.value[key] = result.value;\n  }\n}\nvar $ZodObject = /* @__PURE__ */ $constructor(\"$ZodObject\", (inst, def) => {\n  $ZodType.init(inst, def);\n  const _normalized = cached(() => {\n    const keys = Object.keys(def.shape);\n    for (const k of keys) {\n      if (!(def.shape[k] instanceof $ZodType)) {\n        throw new Error(`Invalid element at key \"${k}\": expected a Zod schema`);\n      }\n    }\n    const okeys = optionalKeys(def.shape);\n    return {\n      shape: def.shape,\n      keys,\n      keySet: new Set(keys),\n      numKeys: keys.length,\n      optionalKeys: new Set(okeys)\n    };\n  });\n  defineLazy(inst._zod, \"propValues\", () => {\n    const shape = def.shape;\n    const propValues = {};\n    for (const key in shape) {\n      const field = shape[key]._zod;\n      if (field.values) {\n        propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());\n        for (const v of field.values)\n          propValues[key].add(v);\n      }\n    }\n    return propValues;\n  });\n  const generateFastpass = (shape) => {\n    const doc = new Doc([\"shape\", \"payload\", \"ctx\"]);\n    const normalized = _normalized.value;\n    const parseStr = (key) => {\n      const k = esc(key);\n      return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;\n    };\n    doc.write(`const input = payload.value;`);\n    const ids = /* @__PURE__ */ Object.create(null);\n    let counter = 0;\n    for (const key of normalized.keys) {\n      ids[key] = `key_${counter++}`;\n    }\n    doc.write(`const newResult = {}`);\n    for (const key of normalized.keys) {\n      if (normalized.optionalKeys.has(key)) {\n        const id = ids[key];\n        doc.write(`const ${id} = ${parseStr(key)};`);\n        const k = esc(key);\n        doc.write(`\n        if (${id}.issues.length) {\n          if (input[${k}] === undefined) {\n            if (${k} in input) {\n              newResult[${k}] = undefined;\n            }\n          } else {\n            payload.issues = payload.issues.concat(\n              ${id}.issues.map((iss) => ({\n                ...iss,\n                path: iss.path ? [${k}, ...iss.path] : [${k}],\n              }))\n            );\n          }\n        } else if (${id}.value === undefined) {\n          if (${k} in input) newResult[${k}] = undefined;\n        } else {\n          newResult[${k}] = ${id}.value;\n        }\n        `);\n      } else {\n        const id = ids[key];\n        doc.write(`const ${id} = ${parseStr(key)};`);\n        doc.write(`\n          if (${id}.issues.length) payload.issues = payload.issues.concat(${id}.issues.map(iss => ({\n            ...iss,\n            path: iss.path ? [${esc(key)}, ...iss.path] : [${esc(key)}]\n          })));`);\n        doc.write(`newResult[${esc(key)}] = ${id}.value`);\n      }\n    }\n    doc.write(`payload.value = newResult;`);\n    doc.write(`return payload;`);\n    const fn = doc.compile();\n    return (payload, ctx) => fn(shape, payload, ctx);\n  };\n  let fastpass;\n  const isObject2 = isObject;\n  const jit = !globalConfig.jitless;\n  const allowsEval2 = allowsEval;\n  const fastEnabled = jit && allowsEval2.value;\n  const catchall = def.catchall;\n  let value;\n  inst._zod.parse = (payload, ctx) => {\n    value ?? (value = _normalized.value);\n    const input = payload.value;\n    if (!isObject2(input)) {\n      payload.issues.push({\n        expected: \"object\",\n        code: \"invalid_type\",\n        input,\n        inst\n      });\n      return payload;\n    }\n    const proms = [];\n    if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {\n      if (!fastpass)\n        fastpass = generateFastpass(def.shape);\n      payload = fastpass(payload, ctx);\n    } else {\n      payload.value = {};\n      const shape = value.shape;\n      for (const key of value.keys) {\n        const el = shape[key];\n        const r = el._zod.run({ value: input[key], issues: [] }, ctx);\n        const isOptional = el._zod.optin === \"optional\" && el._zod.optout === \"optional\";\n        if (r instanceof Promise) {\n          proms.push(r.then((r2) => isOptional ? handleOptionalObjectResult(r2, payload, key, input) : handleObjectResult(r2, payload, key)));\n        } else if (isOptional) {\n          handleOptionalObjectResult(r, payload, key, input);\n        } else {\n          handleObjectResult(r, payload, key);\n        }\n      }\n    }\n    if (!catchall) {\n      return proms.length ? Promise.all(proms).then(() => payload) : payload;\n    }\n    const unrecognized = [];\n    const keySet = value.keySet;\n    const _catchall = catchall._zod;\n    const t = _catchall.def.type;\n    for (const key of Object.keys(input)) {\n      if (keySet.has(key))\n        continue;\n      if (t === \"never\") {\n        unrecognized.push(key);\n        continue;\n      }\n      const r = _catchall.run({ value: input[key], issues: [] }, ctx);\n      if (r instanceof Promise) {\n        proms.push(r.then((r2) => handleObjectResult(r2, payload, key)));\n      } else {\n        handleObjectResult(r, payload, key);\n      }\n    }\n    if (unrecognized.length) {\n      payload.issues.push({\n        code: \"unrecognized_keys\",\n        keys: unrecognized,\n        input,\n        inst\n      });\n    }\n    if (!proms.length)\n      return payload;\n    return Promise.all(proms).then(() => {\n      return payload;\n    });\n  };\n});\nfunction handleUnionResults(results, final, inst, ctx) {\n  for (const result of results) {\n    if (result.issues.length === 0) {\n      final.value = result.value;\n      return final;\n    }\n  }\n  final.issues.push({\n    code: \"invalid_union\",\n    input: final.value,\n    inst,\n    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))\n  });\n  return final;\n}\nvar $ZodUnion = /* @__PURE__ */ $constructor(\"$ZodUnion\", (inst, def) => {\n  $ZodType.init(inst, def);\n  defineLazy(inst._zod, \"optin\", () => def.options.some((o) => o._zod.optin === \"optional\") ? \"optional\" : void 0);\n  defineLazy(inst._zod, \"optout\", () => def.options.some((o) => o._zod.optout === \"optional\") ? \"optional\" : void 0);\n  defineLazy(inst._zod, \"values\", () => {\n    if (def.options.every((o) => o._zod.values)) {\n      return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));\n    }\n    return void 0;\n  });\n  defineLazy(inst._zod, \"pattern\", () => {\n    if (def.options.every((o) => o._zod.pattern)) {\n      const patterns = def.options.map((o) => o._zod.pattern);\n      return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join(\"|\")})$`);\n    }\n    return void 0;\n  });\n  inst._zod.parse = (payload, ctx) => {\n    let async = false;\n    const results = [];\n    for (const option of def.options) {\n      const result = option._zod.run({\n        value: payload.value,\n        issues: []\n      }, ctx);\n      if (result instanceof Promise) {\n        results.push(result);\n        async = true;\n      } else {\n        if (result.issues.length === 0)\n          return result;\n        results.push(result);\n      }\n    }\n    if (!async)\n      return handleUnionResults(results, payload, inst, ctx);\n    return Promise.all(results).then((results2) => {\n      return handleUnionResults(results2, payload, inst, ctx);\n    });\n  };\n});\nvar $ZodIntersection = /* @__PURE__ */ $constructor(\"$ZodIntersection\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, ctx) => {\n    const input = payload.value;\n    const left = def.left._zod.run({ value: input, issues: [] }, ctx);\n    const right = def.right._zod.run({ value: input, issues: [] }, ctx);\n    const async = left instanceof Promise || right instanceof Promise;\n    if (async) {\n      return Promise.all([left, right]).then(([left2, right2]) => {\n        return handleIntersectionResults(payload, left2, right2);\n      });\n    }\n    return handleIntersectionResults(payload, left, right);\n  };\n});\nfunction mergeValues(a, b) {\n  if (a === b) {\n    return { valid: true, data: a };\n  }\n  if (a instanceof Date && b instanceof Date && +a === +b) {\n    return { valid: true, data: a };\n  }\n  if (isPlainObject(a) && isPlainObject(b)) {\n    const bKeys = Object.keys(b);\n    const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);\n    const newObj = { ...a, ...b };\n    for (const key of sharedKeys) {\n      const sharedValue = mergeValues(a[key], b[key]);\n      if (!sharedValue.valid) {\n        return {\n          valid: false,\n          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]\n        };\n      }\n      newObj[key] = sharedValue.data;\n    }\n    return { valid: true, data: newObj };\n  }\n  if (Array.isArray(a) && Array.isArray(b)) {\n    if (a.length !== b.length) {\n      return { valid: false, mergeErrorPath: [] };\n    }\n    const newArray = [];\n    for (let index = 0; index < a.length; index++) {\n      const itemA = a[index];\n      const itemB = b[index];\n      const sharedValue = mergeValues(itemA, itemB);\n      if (!sharedValue.valid) {\n        return {\n          valid: false,\n          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]\n        };\n      }\n      newArray.push(sharedValue.data);\n    }\n    return { valid: true, data: newArray };\n  }\n  return { valid: false, mergeErrorPath: [] };\n}\nfunction handleIntersectionResults(result, left, right) {\n  if (left.issues.length) {\n    result.issues.push(...left.issues);\n  }\n  if (right.issues.length) {\n    result.issues.push(...right.issues);\n  }\n  if (aborted(result))\n    return result;\n  const merged = mergeValues(left.value, right.value);\n  if (!merged.valid) {\n    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);\n  }\n  result.value = merged.data;\n  return result;\n}\nvar $ZodEnum = /* @__PURE__ */ $constructor(\"$ZodEnum\", (inst, def) => {\n  $ZodType.init(inst, def);\n  const values = getEnumValues(def.entries);\n  inst._zod.values = new Set(values);\n  inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o === \"string\" ? escapeRegex(o) : o.toString()).join(\"|\")})$`);\n  inst._zod.parse = (payload, _ctx) => {\n    const input = payload.value;\n    if (inst._zod.values.has(input)) {\n      return payload;\n    }\n    payload.issues.push({\n      code: \"invalid_value\",\n      values,\n      input,\n      inst\n    });\n    return payload;\n  };\n});\nvar $ZodTransform = /* @__PURE__ */ $constructor(\"$ZodTransform\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, _ctx) => {\n    const _out = def.transform(payload.value, payload);\n    if (_ctx.async) {\n      const output = _out instanceof Promise ? _out : Promise.resolve(_out);\n      return output.then((output2) => {\n        payload.value = output2;\n        return payload;\n      });\n    }\n    if (_out instanceof Promise) {\n      throw new $ZodAsyncError();\n    }\n    payload.value = _out;\n    return payload;\n  };\n});\nvar $ZodOptional = /* @__PURE__ */ $constructor(\"$ZodOptional\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.optin = \"optional\";\n  inst._zod.optout = \"optional\";\n  defineLazy(inst._zod, \"values\", () => {\n    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, void 0]) : void 0;\n  });\n  defineLazy(inst._zod, \"pattern\", () => {\n    const pattern = def.innerType._zod.pattern;\n    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : void 0;\n  });\n  inst._zod.parse = (payload, ctx) => {\n    if (def.innerType._zod.optin === \"optional\") {\n      return def.innerType._zod.run(payload, ctx);\n    }\n    if (payload.value === void 0) {\n      return payload;\n    }\n    return def.innerType._zod.run(payload, ctx);\n  };\n});\nvar $ZodNullable = /* @__PURE__ */ $constructor(\"$ZodNullable\", (inst, def) => {\n  $ZodType.init(inst, def);\n  defineLazy(inst._zod, \"optin\", () => def.innerType._zod.optin);\n  defineLazy(inst._zod, \"optout\", () => def.innerType._zod.optout);\n  defineLazy(inst._zod, \"pattern\", () => {\n    const pattern = def.innerType._zod.pattern;\n    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : void 0;\n  });\n  defineLazy(inst._zod, \"values\", () => {\n    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, null]) : void 0;\n  });\n  inst._zod.parse = (payload, ctx) => {\n    if (payload.value === null)\n      return payload;\n    return def.innerType._zod.run(payload, ctx);\n  };\n});\nvar $ZodDefault = /* @__PURE__ */ $constructor(\"$ZodDefault\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.optin = \"optional\";\n  defineLazy(inst._zod, \"values\", () => def.innerType._zod.values);\n  inst._zod.parse = (payload, ctx) => {\n    if (payload.value === void 0) {\n      payload.value = def.defaultValue;\n      return payload;\n    }\n    const result = def.innerType._zod.run(payload, ctx);\n    if (result instanceof Promise) {\n      return result.then((result2) => handleDefaultResult(result2, def));\n    }\n    return handleDefaultResult(result, def);\n  };\n});\nfunction handleDefaultResult(payload, def) {\n  if (payload.value === void 0) {\n    payload.value = def.defaultValue;\n  }\n  return payload;\n}\nvar $ZodPrefault = /* @__PURE__ */ $constructor(\"$ZodPrefault\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.optin = \"optional\";\n  defineLazy(inst._zod, \"values\", () => def.innerType._zod.values);\n  inst._zod.parse = (payload, ctx) => {\n    if (payload.value === void 0) {\n      payload.value = def.defaultValue;\n    }\n    return def.innerType._zod.run(payload, ctx);\n  };\n});\nvar $ZodNonOptional = /* @__PURE__ */ $constructor(\"$ZodNonOptional\", (inst, def) => {\n  $ZodType.init(inst, def);\n  defineLazy(inst._zod, \"values\", () => {\n    const v = def.innerType._zod.values;\n    return v ? new Set([...v].filter((x) => x !== void 0)) : void 0;\n  });\n  inst._zod.parse = (payload, ctx) => {\n    const result = def.innerType._zod.run(payload, ctx);\n    if (result instanceof Promise) {\n      return result.then((result2) => handleNonOptionalResult(result2, inst));\n    }\n    return handleNonOptionalResult(result, inst);\n  };\n});\nfunction handleNonOptionalResult(payload, inst) {\n  if (!payload.issues.length && payload.value === void 0) {\n    payload.issues.push({\n      code: \"invalid_type\",\n      expected: \"nonoptional\",\n      input: payload.value,\n      inst\n    });\n  }\n  return payload;\n}\nvar $ZodCatch = /* @__PURE__ */ $constructor(\"$ZodCatch\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.optin = \"optional\";\n  defineLazy(inst._zod, \"optout\", () => def.innerType._zod.optout);\n  defineLazy(inst._zod, \"values\", () => def.innerType._zod.values);\n  inst._zod.parse = (payload, ctx) => {\n    const result = def.innerType._zod.run(payload, ctx);\n    if (result instanceof Promise) {\n      return result.then((result2) => {\n        payload.value = result2.value;\n        if (result2.issues.length) {\n          payload.value = def.catchValue({\n            ...payload,\n            error: {\n              issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))\n            },\n            input: payload.value\n          });\n          payload.issues = [];\n        }\n        return payload;\n      });\n    }\n    payload.value = result.value;\n    if (result.issues.length) {\n      payload.value = def.catchValue({\n        ...payload,\n        error: {\n          issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))\n        },\n        input: payload.value\n      });\n      payload.issues = [];\n    }\n    return payload;\n  };\n});\nvar $ZodPipe = /* @__PURE__ */ $constructor(\"$ZodPipe\", (inst, def) => {\n  $ZodType.init(inst, def);\n  defineLazy(inst._zod, \"values\", () => def.in._zod.values);\n  defineLazy(inst._zod, \"optin\", () => def.in._zod.optin);\n  defineLazy(inst._zod, \"optout\", () => def.out._zod.optout);\n  inst._zod.parse = (payload, ctx) => {\n    const left = def.in._zod.run(payload, ctx);\n    if (left instanceof Promise) {\n      return left.then((left2) => handlePipeResult(left2, def, ctx));\n    }\n    return handlePipeResult(left, def, ctx);\n  };\n});\nfunction handlePipeResult(left, def, ctx) {\n  if (aborted(left)) {\n    return left;\n  }\n  return def.out._zod.run({ value: left.value, issues: left.issues }, ctx);\n}\nvar $ZodReadonly = /* @__PURE__ */ $constructor(\"$ZodReadonly\", (inst, def) => {\n  $ZodType.init(inst, def);\n  defineLazy(inst._zod, \"propValues\", () => def.innerType._zod.propValues);\n  defineLazy(inst._zod, \"values\", () => def.innerType._zod.values);\n  defineLazy(inst._zod, \"optin\", () => def.innerType._zod.optin);\n  defineLazy(inst._zod, \"optout\", () => def.innerType._zod.optout);\n  inst._zod.parse = (payload, ctx) => {\n    const result = def.innerType._zod.run(payload, ctx);\n    if (result instanceof Promise) {\n      return result.then(handleReadonlyResult);\n    }\n    return handleReadonlyResult(result);\n  };\n});\nfunction handleReadonlyResult(payload) {\n  payload.value = Object.freeze(payload.value);\n  return payload;\n}\nvar $ZodCustom = /* @__PURE__ */ $constructor(\"$ZodCustom\", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, _) => {\n    return payload;\n  };\n  inst._zod.check = (payload) => {\n    const input = payload.value;\n    const r = def.fn(input);\n    if (r instanceof Promise) {\n      return r.then((r2) => handleRefineResult(r2, payload, input, inst));\n    }\n    handleRefineResult(r, payload, input, inst);\n    return;\n  };\n});\nfunction handleRefineResult(result, payload, input, inst) {\n  if (!result) {\n    const _iss = {\n      code: \"custom\",\n      input,\n      inst,\n      // incorporates params.error into issue reporting\n      path: [...inst._zod.def.path ?? []],\n      // incorporates params.error into issue reporting\n      continue: !inst._zod.def.abort\n      // params: inst._zod.def.params,\n    };\n    if (inst._zod.def.params)\n      _iss.params = inst._zod.def.params;\n    payload.issues.push(issue(_iss));\n  }\n}\n\n// node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/core/registries.js\nvar $output = Symbol(\"ZodOutput\");\nvar $input = Symbol(\"ZodInput\");\nvar $ZodRegistry = class {\n  constructor() {\n    this._map = /* @__PURE__ */ new Map();\n    this._idmap = /* @__PURE__ */ new Map();\n  }\n  add(schema, ..._meta) {\n    const meta = _meta[0];\n    this._map.set(schema, meta);\n    if (meta && typeof meta === \"object\" && \"id\" in meta) {\n      if (this._idmap.has(meta.id)) {\n        throw new Error(`ID ${meta.id} already exists in the registry`);\n      }\n      this._idmap.set(meta.id, schema);\n    }\n    return this;\n  }\n  clear() {\n    this._map = /* @__PURE__ */ new Map();\n    this._idmap = /* @__PURE__ */ new Map();\n    return this;\n  }\n  remove(schema) {\n    const meta = this._map.get(schema);\n    if (meta && typeof meta === \"object\" && \"id\" in meta) {\n      this._idmap.delete(meta.id);\n    }\n    this._map.delete(schema);\n    return this;\n  }\n  get(schema) {\n    const p = schema._zod.parent;\n    if (p) {\n      const pm = { ...this.get(p) ?? {} };\n      delete pm.id;\n      return { ...pm, ...this._map.get(schema) };\n    }\n    return this._map.get(schema);\n  }\n  has(schema) {\n    return this._map.has(schema);\n  }\n};\nfunction registry() {\n  return new $ZodRegistry();\n}\nvar globalRegistry = /* @__PURE__ */ registry();\n\n// node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/core/api.js\nfunction _unknown(Class2) {\n  return new Class2({\n    type: \"unknown\"\n  });\n}\nfunction _never(Class2, params) {\n  return new Class2({\n    type: \"never\",\n    ...normalizeParams(params)\n  });\n}\nfunction _maxLength(maximum, params) {\n  const ch = new $ZodCheckMaxLength({\n    check: \"max_length\",\n    ...normalizeParams(params),\n    maximum\n  });\n  return ch;\n}\nfunction _minLength(minimum, params) {\n  return new $ZodCheckMinLength({\n    check: \"min_length\",\n    ...normalizeParams(params),\n    minimum\n  });\n}\nfunction _length(length, params) {\n  return new $ZodCheckLengthEquals({\n    check: \"length_equals\",\n    ...normalizeParams(params),\n    length\n  });\n}\nfunction _overwrite(tx) {\n  return new $ZodCheckOverwrite({\n    check: \"overwrite\",\n    tx\n  });\n}\nfunction _array(Class2, element, params) {\n  return new Class2({\n    type: \"array\",\n    element,\n    // get element() {\n    //   return element;\n    // },\n    ...normalizeParams(params)\n  });\n}\nfunction _refine(Class2, fn, _params) {\n  const schema = new Class2({\n    type: \"custom\",\n    check: \"custom\",\n    fn,\n    ...normalizeParams(_params)\n  });\n  return schema;\n}\n\n// node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/classic/errors.js\nvar initializer2 = (inst, issues) => {\n  $ZodError.init(inst, issues);\n  inst.name = \"ZodError\";\n  Object.defineProperties(inst, {\n    format: {\n      value: (mapper) => formatError(inst, mapper)\n      // enumerable: false,\n    },\n    flatten: {\n      value: (mapper) => flattenError(inst, mapper)\n      // enumerable: false,\n    },\n    addIssue: {\n      value: (issue2) => inst.issues.push(issue2)\n      // enumerable: false,\n    },\n    addIssues: {\n      value: (issues2) => inst.issues.push(...issues2)\n      // enumerable: false,\n    },\n    isEmpty: {\n      get() {\n        return inst.issues.length === 0;\n      }\n      // enumerable: false,\n    }\n  });\n};\nvar ZodError = $constructor(\"ZodError\", initializer2);\nvar ZodRealError = $constructor(\"ZodError\", initializer2, {\n  Parent: Error\n});\n\n// node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/classic/parse.js\nvar parse = /* @__PURE__ */ _parse(ZodRealError);\nvar parseAsync = /* @__PURE__ */ _parseAsync(ZodRealError);\nvar safeParse2 = /* @__PURE__ */ _safeParse(ZodRealError);\nvar safeParseAsync2 = /* @__PURE__ */ _safeParseAsync(ZodRealError);\n\n// node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/classic/schemas.js\nvar ZodType = /* @__PURE__ */ $constructor(\"ZodType\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst.def = def;\n  Object.defineProperty(inst, \"_def\", { value: def });\n  inst.check = (...checks) => {\n    return inst.clone(\n      {\n        ...def,\n        checks: [\n          ...def.checks ?? [],\n          ...checks.map((ch) => typeof ch === \"function\" ? { _zod: { check: ch, def: { check: \"custom\" }, onattach: [] } } : ch)\n        ]\n      }\n      // { parent: true }\n    );\n  };\n  inst.clone = (def2, params) => clone(inst, def2, params);\n  inst.brand = () => inst;\n  inst.register = (reg, meta) => {\n    reg.add(inst, meta);\n    return inst;\n  };\n  inst.parse = (data, params) => parse(inst, data, params, { callee: inst.parse });\n  inst.safeParse = (data, params) => safeParse2(inst, data, params);\n  inst.parseAsync = async (data, params) => parseAsync(inst, data, params, { callee: inst.parseAsync });\n  inst.safeParseAsync = async (data, params) => safeParseAsync2(inst, data, params);\n  inst.spa = inst.safeParseAsync;\n  inst.refine = (check2, params) => inst.check(refine(check2, params));\n  inst.superRefine = (refinement) => inst.check(superRefine(refinement));\n  inst.overwrite = (fn) => inst.check(_overwrite(fn));\n  inst.optional = () => optional(inst);\n  inst.nullable = () => nullable(inst);\n  inst.nullish = () => optional(nullable(inst));\n  inst.nonoptional = (params) => nonoptional(inst, params);\n  inst.array = () => array(inst);\n  inst.or = (arg) => union([inst, arg]);\n  inst.and = (arg) => intersection(inst, arg);\n  inst.transform = (tx) => pipe(inst, transform(tx));\n  inst.default = (def2) => _default(inst, def2);\n  inst.prefault = (def2) => prefault(inst, def2);\n  inst.catch = (params) => _catch(inst, params);\n  inst.pipe = (target) => pipe(inst, target);\n  inst.readonly = () => readonly(inst);\n  inst.describe = (description) => {\n    const cl = inst.clone();\n    globalRegistry.add(cl, { description });\n    return cl;\n  };\n  Object.defineProperty(inst, \"description\", {\n    get() {\n      return globalRegistry.get(inst)?.description;\n    },\n    configurable: true\n  });\n  inst.meta = (...args) => {\n    if (args.length === 0) {\n      return globalRegistry.get(inst);\n    }\n    const cl = inst.clone();\n    globalRegistry.add(cl, args[0]);\n    return cl;\n  };\n  inst.isOptional = () => inst.safeParse(void 0).success;\n  inst.isNullable = () => inst.safeParse(null).success;\n  return inst;\n});\nvar ZodUnknown = /* @__PURE__ */ $constructor(\"ZodUnknown\", (inst, def) => {\n  $ZodUnknown.init(inst, def);\n  ZodType.init(inst, def);\n});\nfunction unknown() {\n  return _unknown(ZodUnknown);\n}\nvar ZodNever = /* @__PURE__ */ $constructor(\"ZodNever\", (inst, def) => {\n  $ZodNever.init(inst, def);\n  ZodType.init(inst, def);\n});\nfunction never(params) {\n  return _never(ZodNever, params);\n}\nvar ZodArray = /* @__PURE__ */ $constructor(\"ZodArray\", (inst, def) => {\n  $ZodArray.init(inst, def);\n  ZodType.init(inst, def);\n  inst.element = def.element;\n  inst.min = (minLength, params) => inst.check(_minLength(minLength, params));\n  inst.nonempty = (params) => inst.check(_minLength(1, params));\n  inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));\n  inst.length = (len, params) => inst.check(_length(len, params));\n  inst.unwrap = () => inst.element;\n});\nfunction array(element, params) {\n  return _array(ZodArray, element, params);\n}\nvar ZodObject = /* @__PURE__ */ $constructor(\"ZodObject\", (inst, def) => {\n  $ZodObject.init(inst, def);\n  ZodType.init(inst, def);\n  util_exports.defineLazy(inst, \"shape\", () => def.shape);\n  inst.keyof = () => _enum(Object.keys(inst._zod.def.shape));\n  inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });\n  inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });\n  inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });\n  inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });\n  inst.strip = () => inst.clone({ ...inst._zod.def, catchall: void 0 });\n  inst.extend = (incoming) => {\n    return util_exports.extend(inst, incoming);\n  };\n  inst.merge = (other) => util_exports.merge(inst, other);\n  inst.pick = (mask) => util_exports.pick(inst, mask);\n  inst.omit = (mask) => util_exports.omit(inst, mask);\n  inst.partial = (...args) => util_exports.partial(ZodOptional, inst, args[0]);\n  inst.required = (...args) => util_exports.required(ZodNonOptional, inst, args[0]);\n});\nvar ZodUnion = /* @__PURE__ */ $constructor(\"ZodUnion\", (inst, def) => {\n  $ZodUnion.init(inst, def);\n  ZodType.init(inst, def);\n  inst.options = def.options;\n});\nfunction union(options, params) {\n  return new ZodUnion({\n    type: \"union\",\n    options,\n    ...util_exports.normalizeParams(params)\n  });\n}\nvar ZodIntersection = /* @__PURE__ */ $constructor(\"ZodIntersection\", (inst, def) => {\n  $ZodIntersection.init(inst, def);\n  ZodType.init(inst, def);\n});\nfunction intersection(left, right) {\n  return new ZodIntersection({\n    type: \"intersection\",\n    left,\n    right\n  });\n}\nvar ZodEnum = /* @__PURE__ */ $constructor(\"ZodEnum\", (inst, def) => {\n  $ZodEnum.init(inst, def);\n  ZodType.init(inst, def);\n  inst.enum = def.entries;\n  inst.options = Object.values(def.entries);\n  const keys = new Set(Object.keys(def.entries));\n  inst.extract = (values, params) => {\n    const newEntries = {};\n    for (const value of values) {\n      if (keys.has(value)) {\n        newEntries[value] = def.entries[value];\n      } else\n        throw new Error(`Key ${value} not found in enum`);\n    }\n    return new ZodEnum({\n      ...def,\n      checks: [],\n      ...util_exports.normalizeParams(params),\n      entries: newEntries\n    });\n  };\n  inst.exclude = (values, params) => {\n    const newEntries = { ...def.entries };\n    for (const value of values) {\n      if (keys.has(value)) {\n        delete newEntries[value];\n      } else\n        throw new Error(`Key ${value} not found in enum`);\n    }\n    return new ZodEnum({\n      ...def,\n      checks: [],\n      ...util_exports.normalizeParams(params),\n      entries: newEntries\n    });\n  };\n});\nfunction _enum(values, params) {\n  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;\n  return new ZodEnum({\n    type: \"enum\",\n    entries,\n    ...util_exports.normalizeParams(params)\n  });\n}\nvar ZodTransform = /* @__PURE__ */ $constructor(\"ZodTransform\", (inst, def) => {\n  $ZodTransform.init(inst, def);\n  ZodType.init(inst, def);\n  inst._zod.parse = (payload, _ctx) => {\n    payload.addIssue = (issue2) => {\n      if (typeof issue2 === \"string\") {\n        payload.issues.push(util_exports.issue(issue2, payload.value, def));\n      } else {\n        const _issue = issue2;\n        if (_issue.fatal)\n          _issue.continue = false;\n        _issue.code ?? (_issue.code = \"custom\");\n        _issue.input ?? (_issue.input = payload.value);\n        _issue.inst ?? (_issue.inst = inst);\n        _issue.continue ?? (_issue.continue = true);\n        payload.issues.push(util_exports.issue(_issue));\n      }\n    };\n    const output = def.transform(payload.value, payload);\n    if (output instanceof Promise) {\n      return output.then((output2) => {\n        payload.value = output2;\n        return payload;\n      });\n    }\n    payload.value = output;\n    return payload;\n  };\n});\nfunction transform(fn) {\n  return new ZodTransform({\n    type: \"transform\",\n    transform: fn\n  });\n}\nvar ZodOptional = /* @__PURE__ */ $constructor(\"ZodOptional\", (inst, def) => {\n  $ZodOptional.init(inst, def);\n  ZodType.init(inst, def);\n  inst.unwrap = () => inst._zod.def.innerType;\n});\nfunction optional(innerType) {\n  return new ZodOptional({\n    type: \"optional\",\n    innerType\n  });\n}\nvar ZodNullable = /* @__PURE__ */ $constructor(\"ZodNullable\", (inst, def) => {\n  $ZodNullable.init(inst, def);\n  ZodType.init(inst, def);\n  inst.unwrap = () => inst._zod.def.innerType;\n});\nfunction nullable(innerType) {\n  return new ZodNullable({\n    type: \"nullable\",\n    innerType\n  });\n}\nvar ZodDefault = /* @__PURE__ */ $constructor(\"ZodDefault\", (inst, def) => {\n  $ZodDefault.init(inst, def);\n  ZodType.init(inst, def);\n  inst.unwrap = () => inst._zod.def.innerType;\n  inst.removeDefault = inst.unwrap;\n});\nfunction _default(innerType, defaultValue) {\n  return new ZodDefault({\n    type: \"default\",\n    innerType,\n    get defaultValue() {\n      return typeof defaultValue === \"function\" ? defaultValue() : defaultValue;\n    }\n  });\n}\nvar ZodPrefault = /* @__PURE__ */ $constructor(\"ZodPrefault\", (inst, def) => {\n  $ZodPrefault.init(inst, def);\n  ZodType.init(inst, def);\n  inst.unwrap = () => inst._zod.def.innerType;\n});\nfunction prefault(innerType, defaultValue) {\n  return new ZodPrefault({\n    type: \"prefault\",\n    innerType,\n    get defaultValue() {\n      return typeof defaultValue === \"function\" ? defaultValue() : defaultValue;\n    }\n  });\n}\nvar ZodNonOptional = /* @__PURE__ */ $constructor(\"ZodNonOptional\", (inst, def) => {\n  $ZodNonOptional.init(inst, def);\n  ZodType.init(inst, def);\n  inst.unwrap = () => inst._zod.def.innerType;\n});\nfunction nonoptional(innerType, params) {\n  return new ZodNonOptional({\n    type: \"nonoptional\",\n    innerType,\n    ...util_exports.normalizeParams(params)\n  });\n}\nvar ZodCatch = /* @__PURE__ */ $constructor(\"ZodCatch\", (inst, def) => {\n  $ZodCatch.init(inst, def);\n  ZodType.init(inst, def);\n  inst.unwrap = () => inst._zod.def.innerType;\n  inst.removeCatch = inst.unwrap;\n});\nfunction _catch(innerType, catchValue) {\n  return new ZodCatch({\n    type: \"catch\",\n    innerType,\n    catchValue: typeof catchValue === \"function\" ? catchValue : () => catchValue\n  });\n}\nvar ZodPipe = /* @__PURE__ */ $constructor(\"ZodPipe\", (inst, def) => {\n  $ZodPipe.init(inst, def);\n  ZodType.init(inst, def);\n  inst.in = def.in;\n  inst.out = def.out;\n});\nfunction pipe(in_, out) {\n  return new ZodPipe({\n    type: \"pipe\",\n    in: in_,\n    out\n    // ...util.normalizeParams(params),\n  });\n}\nvar ZodReadonly = /* @__PURE__ */ $constructor(\"ZodReadonly\", (inst, def) => {\n  $ZodReadonly.init(inst, def);\n  ZodType.init(inst, def);\n});\nfunction readonly(innerType) {\n  return new ZodReadonly({\n    type: \"readonly\",\n    innerType\n  });\n}\nvar ZodCustom = /* @__PURE__ */ $constructor(\"ZodCustom\", (inst, def) => {\n  $ZodCustom.init(inst, def);\n  ZodType.init(inst, def);\n});\nfunction check(fn) {\n  const ch = new $ZodCheck({\n    check: \"custom\"\n    // ...util.normalizeParams(params),\n  });\n  ch._zod.check = fn;\n  return ch;\n}\nfunction refine(fn, _params = {}) {\n  return _refine(ZodCustom, fn, _params);\n}\nfunction superRefine(fn) {\n  const ch = check((payload) => {\n    payload.addIssue = (issue2) => {\n      if (typeof issue2 === \"string\") {\n        payload.issues.push(util_exports.issue(issue2, payload.value, ch._zod.def));\n      } else {\n        const _issue = issue2;\n        if (_issue.fatal)\n          _issue.continue = false;\n        _issue.code ?? (_issue.code = \"custom\");\n        _issue.input ?? (_issue.input = payload.value);\n        _issue.inst ?? (_issue.inst = ch);\n        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);\n        payload.issues.push(util_exports.issue(_issue));\n      }\n    };\n    return fn(payload.value, payload);\n  });\n  return ch;\n}\n\n// src/openapi.ts\nvar paths = {};\nfunction getTypeFromZodType(zodType) {\n  switch (zodType.constructor.name) {\n    case \"ZodString\":\n      return \"string\";\n    case \"ZodNumber\":\n      return \"number\";\n    case \"ZodBoolean\":\n      return \"boolean\";\n    case \"ZodObject\":\n      return \"object\";\n    case \"ZodArray\":\n      return \"array\";\n    default:\n      return \"string\";\n  }\n}\nfunction getParameters(options) {\n  const parameters = [];\n  if (options.metadata?.openapi?.parameters) {\n    parameters.push(...options.metadata.openapi.parameters);\n    return parameters;\n  }\n  if (options.query instanceof ZodObject) {\n    Object.entries(options.query.shape).forEach(([key, value]) => {\n      if (value instanceof ZodObject) {\n        parameters.push({\n          name: key,\n          in: \"query\",\n          schema: {\n            type: getTypeFromZodType(value),\n            ...\"minLength\" in value && value.minLength ? {\n              minLength: value.minLength\n            } : {},\n            description: value.description\n          }\n        });\n      }\n    });\n  }\n  return parameters;\n}\nfunction getRequestBody(options) {\n  if (options.metadata?.openapi?.requestBody) {\n    return options.metadata.openapi.requestBody;\n  }\n  if (!options.body) return void 0;\n  if (options.body instanceof ZodObject || options.body instanceof ZodOptional) {\n    const shape = options.body.shape;\n    if (!shape) return void 0;\n    const properties = {};\n    const required2 = [];\n    Object.entries(shape).forEach(([key, value]) => {\n      if (value instanceof ZodObject) {\n        properties[key] = {\n          type: getTypeFromZodType(value),\n          description: value.description\n        };\n        if (!(value instanceof ZodOptional)) {\n          required2.push(key);\n        }\n      }\n    });\n    return {\n      required: options.body instanceof ZodOptional ? false : options.body ? true : false,\n      content: {\n        \"application/json\": {\n          schema: {\n            type: \"object\",\n            properties,\n            required: required2\n          }\n        }\n      }\n    };\n  }\n  return void 0;\n}\nfunction getResponse(responses) {\n  return {\n    \"400\": {\n      content: {\n        \"application/json\": {\n          schema: {\n            type: \"object\",\n            properties: {\n              message: {\n                type: \"string\"\n              }\n            },\n            required: [\"message\"]\n          }\n        }\n      },\n      description: \"Bad Request. Usually due to missing parameters, or invalid parameters.\"\n    },\n    \"401\": {\n      content: {\n        \"application/json\": {\n          schema: {\n            type: \"object\",\n            properties: {\n              message: {\n                type: \"string\"\n              }\n            },\n            required: [\"message\"]\n          }\n        }\n      },\n      description: \"Unauthorized. Due to missing or invalid authentication.\"\n    },\n    \"403\": {\n      content: {\n        \"application/json\": {\n          schema: {\n            type: \"object\",\n            properties: {\n              message: {\n                type: \"string\"\n              }\n            }\n          }\n        }\n      },\n      description: \"Forbidden. You do not have permission to access this resource or to perform this action.\"\n    },\n    \"404\": {\n      content: {\n        \"application/json\": {\n          schema: {\n            type: \"object\",\n            properties: {\n              message: {\n                type: \"string\"\n              }\n            }\n          }\n        }\n      },\n      description: \"Not Found. The requested resource was not found.\"\n    },\n    \"429\": {\n      content: {\n        \"application/json\": {\n          schema: {\n            type: \"object\",\n            properties: {\n              message: {\n                type: \"string\"\n              }\n            }\n          }\n        }\n      },\n      description: \"Too Many Requests. You have exceeded the rate limit. Try again later.\"\n    },\n    \"500\": {\n      content: {\n        \"application/json\": {\n          schema: {\n            type: \"object\",\n            properties: {\n              message: {\n                type: \"string\"\n              }\n            }\n          }\n        }\n      },\n      description: \"Internal Server Error. This is a problem with the server that you cannot fix.\"\n    },\n    ...responses\n  };\n}\nasync function generator(endpoints, config2) {\n  const components = {\n    schemas: {}\n  };\n  Object.entries(endpoints).forEach(([_, value]) => {\n    const options = value.options;\n    if (options.metadata?.SERVER_ONLY) return;\n    if (options.method === \"GET\") {\n      paths[value.path] = {\n        get: {\n          tags: [\"Default\", ...options.metadata?.openapi?.tags || []],\n          description: options.metadata?.openapi?.description,\n          operationId: options.metadata?.openapi?.operationId,\n          security: [\n            {\n              bearerAuth: []\n            }\n          ],\n          parameters: getParameters(options),\n          responses: getResponse(options.metadata?.openapi?.responses)\n        }\n      };\n    }\n    if (options.method === \"POST\") {\n      const body = getRequestBody(options);\n      paths[value.path] = {\n        post: {\n          tags: [\"Default\", ...options.metadata?.openapi?.tags || []],\n          description: options.metadata?.openapi?.description,\n          operationId: options.metadata?.openapi?.operationId,\n          security: [\n            {\n              bearerAuth: []\n            }\n          ],\n          parameters: getParameters(options),\n          ...body ? { requestBody: body } : {\n            requestBody: {\n              //set body none\n              content: {\n                \"application/json\": {\n                  schema: {\n                    type: \"object\",\n                    properties: {}\n                  }\n                }\n              }\n            }\n          },\n          responses: getResponse(options.metadata?.openapi?.responses)\n        }\n      };\n    }\n  });\n  const res = {\n    openapi: \"3.1.1\",\n    info: {\n      title: \"Better Auth\",\n      description: \"API Reference for your Better Auth Instance\",\n      version: \"1.1.0\"\n    },\n    components,\n    security: [\n      {\n        apiKeyCookie: []\n      }\n    ],\n    servers: [\n      {\n        url: config2?.url\n      }\n    ],\n    tags: [\n      {\n        name: \"Default\",\n        description: \"Default endpoints that are included with Better Auth by default. These endpoints are not part of any plugin.\"\n      }\n    ],\n    paths\n  };\n  return res;\n}\nvar getHTML = (apiReference, config2) => `<!doctype html>\n<html>\n  <head>\n    <title>Scalar API Reference</title>\n    <meta charset=\"utf-8\" />\n    <meta\n      name=\"viewport\"\n      content=\"width=device-width, initial-scale=1\" />\n  </head>\n  <body>\n    <script\n      id=\"api-reference\"\n      type=\"application/json\">\n    ${JSON.stringify(apiReference)}\n    </script>\n\t <script>\n      var configuration = {\n\t  \tfavicon: ${config2?.logo ? `data:image/svg+xml;utf8,${encodeURIComponent(config2.logo)}` : void 0} ,\n\t   \ttheme: ${config2?.theme || \"saturn\"},\n        metaData: {\n\t\t\ttitle: ${config2?.title || \"Open API Reference\"},\n\t\t\tdescription: ${config2?.description || \"Better Call Open API\"},\n\t\t}\n      }\n      document.getElementById('api-reference').dataset.configuration =\n        JSON.stringify(configuration)\n    </script>\n\t  <script src=\"https://cdn.jsdelivr.net/npm/@scalar/api-reference\"></script>\n  </body>\n</html>`;\n\n// src/router.ts\nvar createRouter = (endpoints, config2) => {\n  if (!config2?.openapi?.disabled) {\n    const openapi = {\n      path: \"/api/reference\",\n      ...config2?.openapi\n    };\n    endpoints[\"openapi\"] = createEndpoint2(\n      openapi.path,\n      {\n        method: \"GET\"\n      },\n      async (c) => {\n        const schema = await generator(endpoints);\n        return new Response(getHTML(schema, openapi.scalar), {\n          headers: {\n            \"Content-Type\": \"text/html\"\n          }\n        });\n      }\n    );\n  }\n  const router = (0,rou3__WEBPACK_IMPORTED_MODULE_1__.createRouter)();\n  const middlewareRouter = (0,rou3__WEBPACK_IMPORTED_MODULE_1__.createRouter)();\n  for (const endpoint of Object.values(endpoints)) {\n    if (!endpoint.options) {\n      continue;\n    }\n    if (endpoint.options?.metadata?.SERVER_ONLY) continue;\n    const methods = Array.isArray(endpoint.options?.method) ? endpoint.options.method : [endpoint.options?.method];\n    for (const method of methods) {\n      (0,rou3__WEBPACK_IMPORTED_MODULE_1__.addRoute)(router, method, endpoint.path, endpoint);\n    }\n  }\n  if (config2?.routerMiddleware?.length) {\n    for (const { path, middleware } of config2.routerMiddleware) {\n      (0,rou3__WEBPACK_IMPORTED_MODULE_1__.addRoute)(middlewareRouter, \"*\", path, middleware);\n    }\n  }\n  const processRequest = async (request) => {\n    const url = new URL(request.url);\n    const path = config2?.basePath ? url.pathname.split(config2.basePath).reduce((acc, curr, index) => {\n      if (index !== 0) {\n        if (index > 1) {\n          acc.push(`${config2.basePath}${curr}`);\n        } else {\n          acc.push(curr);\n        }\n      }\n      return acc;\n    }, []).join(\"\") : url.pathname;\n    if (!path?.length) {\n      return new Response(null, { status: 404, statusText: \"Not Found\" });\n    }\n    const route = (0,rou3__WEBPACK_IMPORTED_MODULE_1__.findRoute)(router, request.method, path);\n    if (!route?.data) {\n      return new Response(null, { status: 404, statusText: \"Not Found\" });\n    }\n    const query = {};\n    url.searchParams.forEach((value, key) => {\n      if (key in query) {\n        if (Array.isArray(query[key])) {\n          query[key].push(value);\n        } else {\n          query[key] = [query[key], value];\n        }\n      } else {\n        query[key] = value;\n      }\n    });\n    const handler = route.data;\n    const context = {\n      path,\n      method: request.method,\n      headers: request.headers,\n      params: route.params ? JSON.parse(JSON.stringify(route.params)) : {},\n      request,\n      body: handler.options.disableBody ? void 0 : await getBody(handler.options.cloneRequest ? request.clone() : request),\n      query,\n      _flag: \"router\",\n      asResponse: true,\n      context: config2?.routerContext\n    };\n    try {\n      const middlewareRoutes = (0,rou3__WEBPACK_IMPORTED_MODULE_1__.findAllRoutes)(middlewareRouter, \"*\", path);\n      if (middlewareRoutes?.length) {\n        for (const { data: middleware, params } of middlewareRoutes) {\n          const res = await middleware({\n            ...context,\n            params,\n            asResponse: false\n          });\n          if (res instanceof Response) return res;\n        }\n      }\n      const response = await handler(context);\n      return response;\n    } catch (error) {\n      if (isAPIError(error)) {\n        return toResponse(error);\n      }\n      console.error(`# SERVER_ERROR: `, error);\n      return new Response(null, {\n        status: 500,\n        statusText: \"Internal Server Error\"\n      });\n    }\n  };\n  return {\n    handler: async (request) => {\n      const onReq = await config2?.onRequest?.(request);\n      if (onReq instanceof Response) {\n        return onReq;\n      }\n      const req = onReq instanceof Request ? onReq : request;\n      const res = await processRequest(req);\n      const onRes = await config2?.onResponse?.(res);\n      if (onRes instanceof Response) {\n        return onRes;\n      }\n      return res;\n    },\n    endpoints\n  };\n};\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvYmV0dGVyLWNhbGwvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUM0Rjs7QUFFNUY7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxrQ0FBa0M7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsYUFBYTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxhQUFhO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxxQ0FBcUMsYUFBYTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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LEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsd0NBQXdDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixTQUFTO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsWUFBWTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsUUFBUSxrQkFBa0IsaUJBQWlCLG1CQUFtQjtBQUMzSDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsb0JBQW9CO0FBQ2pGO0FBQ0EsNkVBQTZFLHlCQUF5QjtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGFBQWE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsNEJBQTRCO0FBQ3pFLHdDQUF3Qyx1Q0FBdUM7QUFDL0Usa0NBQWtDLHVDQUF1QztBQUN6RSxtQ0FBbUMscUNBQXFDO0FBQ3hFLGtDQUFrQyxvQ0FBb0M7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLCtCQUErQixPQUFPO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUiwrQkFBK0IsT0FBTztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxJQUFJO0FBQ2xCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DLE9BQU8saUNBQWlDLFlBQVk7QUFDdkcsY0FBYywyQkFBMkI7QUFDekM7QUFDQSxZQUFZLHVDQUF1QztBQUNuRCxrQkFBa0IsK0NBQStDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtEQUFnQjtBQUNqQywyQkFBMkIsa0RBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSw4Q0FBUTtBQUNkO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBbUI7QUFDcEMsTUFBTSw4Q0FBUTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQixFQUFFLEtBQUs7QUFDOUMsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esa0NBQWtDLHNDQUFzQztBQUN4RTtBQUNBLGtCQUFrQiwrQ0FBUztBQUMzQjtBQUNBLGtDQUFrQyxzQ0FBc0M7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsbURBQWE7QUFDNUM7QUFDQSxxQkFBcUIsMkJBQTJCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQWVFO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWxhbi9EZXNrdG9wL0FwcHMvYmV0dGVyLWF1dGgvbm9kZV9tb2R1bGVzL2JldHRlci1jYWxsL2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcblxuLy8gc3JjL2Vycm9yLnRzXG52YXIgX3N0YXR1c0NvZGUgPSB7XG4gIE9LOiAyMDAsXG4gIENSRUFURUQ6IDIwMSxcbiAgQUNDRVBURUQ6IDIwMixcbiAgTk9fQ09OVEVOVDogMjA0LFxuICBNVUxUSVBMRV9DSE9JQ0VTOiAzMDAsXG4gIE1PVkVEX1BFUk1BTkVOVExZOiAzMDEsXG4gIEZPVU5EOiAzMDIsXG4gIFNFRV9PVEhFUjogMzAzLFxuICBOT1RfTU9ESUZJRUQ6IDMwNCxcbiAgVEVNUE9SQVJZX1JFRElSRUNUOiAzMDcsXG4gIEJBRF9SRVFVRVNUOiA0MDAsXG4gIFVOQVVUSE9SSVpFRDogNDAxLFxuICBQQVlNRU5UX1JFUVVJUkVEOiA0MDIsXG4gIEZPUkJJRERFTjogNDAzLFxuICBOT1RfRk9VTkQ6IDQwNCxcbiAgTUVUSE9EX05PVF9BTExPV0VEOiA0MDUsXG4gIE5PVF9BQ0NFUFRBQkxFOiA0MDYsXG4gIFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEOiA0MDcsXG4gIFJFUVVFU1RfVElNRU9VVDogNDA4LFxuICBDT05GTElDVDogNDA5LFxuICBHT05FOiA0MTAsXG4gIExFTkdUSF9SRVFVSVJFRDogNDExLFxuICBQUkVDT05ESVRJT05fRkFJTEVEOiA0MTIsXG4gIFBBWUxPQURfVE9PX0xBUkdFOiA0MTMsXG4gIFVSSV9UT09fTE9ORzogNDE0LFxuICBVTlNVUFBPUlRFRF9NRURJQV9UWVBFOiA0MTUsXG4gIFJBTkdFX05PVF9TQVRJU0ZJQUJMRTogNDE2LFxuICBFWFBFQ1RBVElPTl9GQUlMRUQ6IDQxNyxcbiAgXCJJJ01fQV9URUFQT1RcIjogNDE4LFxuICBNSVNESVJFQ1RFRF9SRVFVRVNUOiA0MjEsXG4gIFVOUFJPQ0VTU0FCTEVfRU5USVRZOiA0MjIsXG4gIExPQ0tFRDogNDIzLFxuICBGQUlMRURfREVQRU5ERU5DWTogNDI0LFxuICBUT09fRUFSTFk6IDQyNSxcbiAgVVBHUkFERV9SRVFVSVJFRDogNDI2LFxuICBQUkVDT05ESVRJT05fUkVRVUlSRUQ6IDQyOCxcbiAgVE9PX01BTllfUkVRVUVTVFM6IDQyOSxcbiAgUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRTogNDMxLFxuICBVTkFWQUlMQUJMRV9GT1JfTEVHQUxfUkVBU09OUzogNDUxLFxuICBJTlRFUk5BTF9TRVJWRVJfRVJST1I6IDUwMCxcbiAgTk9UX0lNUExFTUVOVEVEOiA1MDEsXG4gIEJBRF9HQVRFV0FZOiA1MDIsXG4gIFNFUlZJQ0VfVU5BVkFJTEFCTEU6IDUwMyxcbiAgR0FURVdBWV9USU1FT1VUOiA1MDQsXG4gIEhUVFBfVkVSU0lPTl9OT1RfU1VQUE9SVEVEOiA1MDUsXG4gIFZBUklBTlRfQUxTT19ORUdPVElBVEVTOiA1MDYsXG4gIElOU1VGRklDSUVOVF9TVE9SQUdFOiA1MDcsXG4gIExPT1BfREVURUNURUQ6IDUwOCxcbiAgTk9UX0VYVEVOREVEOiA1MTAsXG4gIE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQ6IDUxMVxufTtcbnZhciBBUElFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihzdGF0dXMgPSBcIklOVEVSTkFMX1NFUlZFUl9FUlJPUlwiLCBib2R5ID0gdm9pZCAwLCBoZWFkZXJzID0ge30sIHN0YXR1c0NvZGUgPSB0eXBlb2Ygc3RhdHVzID09PSBcIm51bWJlclwiID8gc3RhdHVzIDogX3N0YXR1c0NvZGVbc3RhdHVzXSkge1xuICAgIHN1cGVyKGJvZHk/Lm1lc3NhZ2UpO1xuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5oZWFkZXJzID0gaGVhZGVycztcbiAgICB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuICAgIHRoaXMubmFtZSA9IFwiQVBJRXJyb3JcIjtcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgIHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG4gICAgdGhpcy5ib2R5ID0gYm9keSA/IHtcbiAgICAgIGNvZGU6IGJvZHk/Lm1lc3NhZ2U/LnRvVXBwZXJDYXNlKCkucmVwbGFjZSgvIC9nLCBcIl9cIikucmVwbGFjZSgvW15BLVowLTlfXS9nLCBcIlwiKSxcbiAgICAgIC4uLmJvZHlcbiAgICB9IDogdm9pZCAwO1xuICAgIHRoaXMuc3RhY2sgPSBcIlwiO1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMudHNcbmFzeW5jIGZ1bmN0aW9uIGdldEJvZHkocmVxdWVzdCkge1xuICBjb25zdCBjb250ZW50VHlwZSA9IHJlcXVlc3QuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIikgfHwgXCJcIjtcbiAgaWYgKCFyZXF1ZXN0LmJvZHkpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGlmIChjb250ZW50VHlwZS5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL2pzb25cIikpIHtcbiAgICByZXR1cm4gYXdhaXQgcmVxdWVzdC5qc29uKCk7XG4gIH1cbiAgaWYgKGNvbnRlbnRUeXBlLmluY2x1ZGVzKFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIpKSB7XG4gICAgY29uc3QgZm9ybURhdGEgPSBhd2FpdCByZXF1ZXN0LmZvcm1EYXRhKCk7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9ybURhdGEuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZS50b1N0cmluZygpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKGNvbnRlbnRUeXBlLmluY2x1ZGVzKFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiKSkge1xuICAgIGNvbnN0IGZvcm1EYXRhID0gYXdhaXQgcmVxdWVzdC5mb3JtRGF0YSgpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvcm1EYXRhLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoY29udGVudFR5cGUuaW5jbHVkZXMoXCJ0ZXh0L3BsYWluXCIpKSB7XG4gICAgcmV0dXJuIGF3YWl0IHJlcXVlc3QudGV4dCgpO1xuICB9XG4gIGlmIChjb250ZW50VHlwZS5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiKSkge1xuICAgIHJldHVybiBhd2FpdCByZXF1ZXN0LmFycmF5QnVmZmVyKCk7XG4gIH1cbiAgaWYgKGNvbnRlbnRUeXBlLmluY2x1ZGVzKFwiYXBwbGljYXRpb24vcGRmXCIpIHx8IGNvbnRlbnRUeXBlLmluY2x1ZGVzKFwiaW1hZ2UvXCIpIHx8IGNvbnRlbnRUeXBlLmluY2x1ZGVzKFwidmlkZW8vXCIpKSB7XG4gICAgY29uc3QgYmxvYiA9IGF3YWl0IHJlcXVlc3QuYmxvYigpO1xuICAgIHJldHVybiBibG9iO1xuICB9XG4gIGlmIChjb250ZW50VHlwZS5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL3N0cmVhbVwiKSB8fCByZXF1ZXN0LmJvZHkgaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbSkge1xuICAgIHJldHVybiByZXF1ZXN0LmJvZHk7XG4gIH1cbiAgcmV0dXJuIGF3YWl0IHJlcXVlc3QudGV4dCgpO1xufVxuZnVuY3Rpb24gaXNBUElFcnJvcihlcnJvcikge1xuICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBBUElFcnJvciB8fCBlcnJvcj8ubmFtZSA9PT0gXCJBUElFcnJvclwiO1xufVxuZnVuY3Rpb24gdHJ5RGVjb2RlKHN0cikge1xuICB0cnkge1xuICAgIHJldHVybiBzdHIuaW5jbHVkZXMoXCIlXCIpID8gZGVjb2RlVVJJQ29tcG9uZW50KHN0cikgOiBzdHI7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cblxuLy8gc3JjL3RvLXJlc3BvbnNlLnRzXG5mdW5jdGlvbiBpc0pTT05TZXJpYWxpemFibGUodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgdCA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKHQgPT09IFwic3RyaW5nXCIgfHwgdCA9PT0gXCJudW1iZXJcIiB8fCB0ID09PSBcImJvb2xlYW5cIiB8fCB0ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHQgIT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHZhbHVlLmJ1ZmZlcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IubmFtZSA9PT0gXCJPYmplY3RcIiB8fCB0eXBlb2YgdmFsdWUudG9KU09OID09PSBcImZ1bmN0aW9uXCI7XG59XG5mdW5jdGlvbiBzYWZlU3RyaW5naWZ5KG9iaiwgcmVwbGFjZXIsIHNwYWNlKSB7XG4gIGxldCBpZCA9IDA7XG4gIGNvbnN0IHNlZW4gPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgY29uc3Qgc2FmZVJlcGxhY2VyID0gKGtleSwgdmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiKSB7XG4gICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKHNlZW4uaGFzKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gYFtDaXJjdWxhciByZWYtJHtzZWVuLmdldCh2YWx1ZSl9XWA7XG4gICAgICB9XG4gICAgICBzZWVuLnNldCh2YWx1ZSwgaWQrKyk7XG4gICAgfVxuICAgIGlmIChyZXBsYWNlcikge1xuICAgICAgcmV0dXJuIHJlcGxhY2VyKGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmosIHNhZmVSZXBsYWNlciwgc3BhY2UpO1xufVxuZnVuY3Rpb24gaXNKU09OUmVzcG9uc2UodmFsdWUpIHtcbiAgaWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIFwiX2ZsYWdcIiBpbiB2YWx1ZSAmJiB2YWx1ZS5fZmxhZyA9PT0gXCJqc29uXCI7XG59XG5mdW5jdGlvbiB0b1Jlc3BvbnNlKGRhdGEsIGluaXQpIHtcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBSZXNwb25zZSkge1xuICAgIGlmIChpbml0Py5oZWFkZXJzIGluc3RhbmNlb2YgSGVhZGVycykge1xuICAgICAgaW5pdC5oZWFkZXJzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgZGF0YS5oZWFkZXJzLnNldChrZXksIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICBjb25zdCBpc0pTT04gPSBpc0pTT05SZXNwb25zZShkYXRhKTtcbiAgaWYgKGlzSlNPTikge1xuICAgIGNvbnN0IGJvZHkyID0gZGF0YS5ib2R5O1xuICAgIGNvbnN0IHJvdXRlclJlc3BvbnNlID0gZGF0YS5yb3V0ZXJSZXNwb25zZTtcbiAgICBpZiAocm91dGVyUmVzcG9uc2UgaW5zdGFuY2VvZiBSZXNwb25zZSkge1xuICAgICAgcmV0dXJuIHJvdXRlclJlc3BvbnNlO1xuICAgIH1cbiAgICBjb25zdCBoZWFkZXJzMiA9IG5ldyBIZWFkZXJzKHtcbiAgICAgIC4uLnJvdXRlclJlc3BvbnNlPy5oZWFkZXJzLFxuICAgICAgLi4uZGF0YS5oZWFkZXJzLFxuICAgICAgLi4uaW5pdD8uaGVhZGVycyxcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZShKU09OLnN0cmluZ2lmeShib2R5MiksIHtcbiAgICAgIC4uLnJvdXRlclJlc3BvbnNlLFxuICAgICAgaGVhZGVyczogaGVhZGVyczIsXG4gICAgICBzdGF0dXM6IGRhdGEuc3RhdHVzID8/IGluaXQ/LnN0YXR1cyA/PyByb3V0ZXJSZXNwb25zZT8uc3RhdHVzLFxuICAgICAgc3RhdHVzVGV4dDogaW5pdD8uc3RhdHVzVGV4dCA/PyByb3V0ZXJSZXNwb25zZT8uc3RhdHVzVGV4dFxuICAgIH0pO1xuICB9XG4gIGlmIChpc0FQSUVycm9yKGRhdGEpKSB7XG4gICAgcmV0dXJuIHRvUmVzcG9uc2UoZGF0YS5ib2R5LCB7XG4gICAgICBzdGF0dXM6IGluaXQ/LnN0YXR1cyA/PyBkYXRhLnN0YXR1c0NvZGUsXG4gICAgICBzdGF0dXNUZXh0OiBkYXRhLnN0YXR1cy50b1N0cmluZygpLFxuICAgICAgaGVhZGVyczogaW5pdD8uaGVhZGVycyB8fCBkYXRhLmhlYWRlcnNcbiAgICB9KTtcbiAgfVxuICBsZXQgYm9keSA9IGRhdGE7XG4gIGxldCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoaW5pdD8uaGVhZGVycyk7XG4gIGlmICghZGF0YSkge1xuICAgIGlmIChkYXRhID09PSBudWxsKSB7XG4gICAgICBib2R5ID0gSlNPTi5zdHJpbmdpZnkobnVsbCk7XG4gICAgfVxuICAgIGhlYWRlcnMuc2V0KFwiY29udGVudC10eXBlXCIsIFwiYXBwbGljYXRpb24vanNvblwiKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGJvZHkgPSBkYXRhO1xuICAgIGhlYWRlcnMuc2V0KFwiQ29udGVudC1UeXBlXCIsIFwidGV4dC9wbGFpblwiKTtcbiAgfSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KGRhdGEpKSB7XG4gICAgYm9keSA9IGRhdGE7XG4gICAgaGVhZGVycy5zZXQoXCJDb250ZW50LVR5cGVcIiwgXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIik7XG4gIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICBib2R5ID0gZGF0YTtcbiAgICBoZWFkZXJzLnNldChcIkNvbnRlbnQtVHlwZVwiLCBkYXRhLnR5cGUgfHwgXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIik7XG4gIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEZvcm1EYXRhKSB7XG4gICAgYm9keSA9IGRhdGE7XG4gIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcykge1xuICAgIGJvZHkgPSBkYXRhO1xuICAgIGhlYWRlcnMuc2V0KFwiQ29udGVudC1UeXBlXCIsIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIpO1xuICB9IGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbSkge1xuICAgIGJvZHkgPSBkYXRhO1xuICAgIGhlYWRlcnMuc2V0KFwiQ29udGVudC1UeXBlXCIsIFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCIpO1xuICB9IGVsc2UgaWYgKGlzSlNPTlNlcmlhbGl6YWJsZShkYXRhKSkge1xuICAgIGJvZHkgPSBzYWZlU3RyaW5naWZ5KGRhdGEpO1xuICAgIGhlYWRlcnMuc2V0KFwiQ29udGVudC1UeXBlXCIsIFwiYXBwbGljYXRpb24vanNvblwiKTtcbiAgfVxuICByZXR1cm4gbmV3IFJlc3BvbnNlKGJvZHksIHtcbiAgICAuLi5pbml0LFxuICAgIGhlYWRlcnNcbiAgfSk7XG59XG5cbi8vIHNyYy92YWxpZGF0b3IudHNcbmFzeW5jIGZ1bmN0aW9uIHJ1blZhbGlkYXRpb24ob3B0aW9ucywgY29udGV4dCA9IHt9KSB7XG4gIGxldCByZXF1ZXN0ID0ge1xuICAgIGJvZHk6IGNvbnRleHQuYm9keSxcbiAgICBxdWVyeTogY29udGV4dC5xdWVyeVxuICB9O1xuICBpZiAob3B0aW9ucy5ib2R5KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgb3B0aW9ucy5ib2R5W1wifnN0YW5kYXJkXCJdLnZhbGlkYXRlKGNvbnRleHQuYm9keSk7XG4gICAgaWYgKHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgIGVycm9yOiBmcm9tRXJyb3IocmVzdWx0Lmlzc3VlcywgXCJib2R5XCIpXG4gICAgICB9O1xuICAgIH1cbiAgICByZXF1ZXN0LmJvZHkgPSByZXN1bHQudmFsdWU7XG4gIH1cbiAgaWYgKG9wdGlvbnMucXVlcnkpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBvcHRpb25zLnF1ZXJ5W1wifnN0YW5kYXJkXCJdLnZhbGlkYXRlKGNvbnRleHQucXVlcnkpO1xuICAgIGlmIChyZXN1bHQuaXNzdWVzKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICBlcnJvcjogZnJvbUVycm9yKHJlc3VsdC5pc3N1ZXMsIFwicXVlcnlcIilcbiAgICAgIH07XG4gICAgfVxuICAgIHJlcXVlc3QucXVlcnkgPSByZXN1bHQudmFsdWU7XG4gIH1cbiAgaWYgKG9wdGlvbnMucmVxdWlyZUhlYWRlcnMgJiYgIWNvbnRleHQuaGVhZGVycykge1xuICAgIHJldHVybiB7XG4gICAgICBkYXRhOiBudWxsLFxuICAgICAgZXJyb3I6IHsgbWVzc2FnZTogXCJIZWFkZXJzIGlzIHJlcXVpcmVkXCIgfVxuICAgIH07XG4gIH1cbiAgaWYgKG9wdGlvbnMucmVxdWlyZVJlcXVlc3QgJiYgIWNvbnRleHQucmVxdWVzdCkge1xuICAgIHJldHVybiB7XG4gICAgICBkYXRhOiBudWxsLFxuICAgICAgZXJyb3I6IHsgbWVzc2FnZTogXCJSZXF1ZXN0IGlzIHJlcXVpcmVkXCIgfVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBkYXRhOiByZXF1ZXN0LFxuICAgIGVycm9yOiBudWxsXG4gIH07XG59XG5mdW5jdGlvbiBmcm9tRXJyb3IoZXJyb3IsIHZhbGlkYXRpbmcpIHtcbiAgY29uc3QgZXJyb3JNZXNzYWdlcyA9IFtdO1xuICBmb3IgKGNvbnN0IGlzc3VlMiBvZiBlcnJvcikge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBpc3N1ZTIubWVzc2FnZTtcbiAgICBlcnJvck1lc3NhZ2VzLnB1c2gobWVzc2FnZSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBtZXNzYWdlOiBgSW52YWxpZCAke3ZhbGlkYXRpbmd9IHBhcmFtZXRlcnNgXG4gIH07XG59XG5cbi8vIHNyYy9jcnlwdG8udHNcbmltcG9ydCB7IHN1YnRsZSB9IGZyb20gXCJ1bmNyeXB0b1wiO1xudmFyIGFsZ29yaXRobSA9IHsgbmFtZTogXCJITUFDXCIsIGhhc2g6IFwiU0hBLTI1NlwiIH07XG52YXIgZ2V0Q3J5cHRvS2V5ID0gYXN5bmMgKHNlY3JldCkgPT4ge1xuICBjb25zdCBzZWNyZXRCdWYgPSB0eXBlb2Ygc2VjcmV0ID09PSBcInN0cmluZ1wiID8gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHNlY3JldCkgOiBzZWNyZXQ7XG4gIHJldHVybiBhd2FpdCBzdWJ0bGUuaW1wb3J0S2V5KFwicmF3XCIsIHNlY3JldEJ1ZiwgYWxnb3JpdGhtLCBmYWxzZSwgW1wic2lnblwiLCBcInZlcmlmeVwiXSk7XG59O1xudmFyIHZlcmlmeVNpZ25hdHVyZSA9IGFzeW5jIChiYXNlNjRTaWduYXR1cmUsIHZhbHVlLCBzZWNyZXQpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBzaWduYXR1cmVCaW5TdHIgPSBhdG9iKGJhc2U2NFNpZ25hdHVyZSk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gbmV3IFVpbnQ4QXJyYXkoc2lnbmF0dXJlQmluU3RyLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHNpZ25hdHVyZUJpblN0ci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgc2lnbmF0dXJlW2ldID0gc2lnbmF0dXJlQmluU3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBzdWJ0bGUudmVyaWZ5KGFsZ29yaXRobSwgc2VjcmV0LCBzaWduYXR1cmUsIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh2YWx1ZSkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xudmFyIG1ha2VTaWduYXR1cmUgPSBhc3luYyAodmFsdWUsIHNlY3JldCkgPT4ge1xuICBjb25zdCBrZXkgPSBhd2FpdCBnZXRDcnlwdG9LZXkoc2VjcmV0KTtcbiAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgc3VidGxlLnNpZ24oYWxnb3JpdGhtLm5hbWUsIGtleSwgbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHZhbHVlKSk7XG4gIHJldHVybiBidG9hKFN0cmluZy5mcm9tQ2hhckNvZGUoLi4ubmV3IFVpbnQ4QXJyYXkoc2lnbmF0dXJlKSkpO1xufTtcbnZhciBzaWduQ29va2llVmFsdWUgPSBhc3luYyAodmFsdWUsIHNlY3JldCkgPT4ge1xuICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBtYWtlU2lnbmF0dXJlKHZhbHVlLCBzZWNyZXQpO1xuICB2YWx1ZSA9IGAke3ZhbHVlfS4ke3NpZ25hdHVyZX1gO1xuICB2YWx1ZSA9IGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbi8vIHNyYy9jb29raWVzLnRzXG52YXIgZ2V0Q29va2llS2V5ID0gKGtleSwgcHJlZml4KSA9PiB7XG4gIGxldCBmaW5hbEtleSA9IGtleTtcbiAgaWYgKHByZWZpeCkge1xuICAgIGlmIChwcmVmaXggPT09IFwic2VjdXJlXCIpIHtcbiAgICAgIGZpbmFsS2V5ID0gXCJfX1NlY3VyZS1cIiArIGtleTtcbiAgICB9IGVsc2UgaWYgKHByZWZpeCA9PT0gXCJob3N0XCIpIHtcbiAgICAgIGZpbmFsS2V5ID0gXCJfX0hvc3QtXCIgKyBrZXk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICB9XG4gIHJldHVybiBmaW5hbEtleTtcbn07XG5mdW5jdGlvbiBwYXJzZUNvb2tpZXMoc3RyKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImFyZ3VtZW50IHN0ciBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuICB9XG4gIGNvbnN0IGNvb2tpZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBsZXQgaW5kZXggPSAwO1xuICB3aGlsZSAoaW5kZXggPCBzdHIubGVuZ3RoKSB7XG4gICAgY29uc3QgZXFJZHggPSBzdHIuaW5kZXhPZihcIj1cIiwgaW5kZXgpO1xuICAgIGlmIChlcUlkeCA9PT0gLTEpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBsZXQgZW5kSWR4ID0gc3RyLmluZGV4T2YoXCI7XCIsIGluZGV4KTtcbiAgICBpZiAoZW5kSWR4ID09PSAtMSkge1xuICAgICAgZW5kSWR4ID0gc3RyLmxlbmd0aDtcbiAgICB9IGVsc2UgaWYgKGVuZElkeCA8IGVxSWR4KSB7XG4gICAgICBpbmRleCA9IHN0ci5sYXN0SW5kZXhPZihcIjtcIiwgZXFJZHggLSAxKSArIDE7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3Qga2V5ID0gc3RyLnNsaWNlKGluZGV4LCBlcUlkeCkudHJpbSgpO1xuICAgIGlmICghY29va2llcy5oYXMoa2V5KSkge1xuICAgICAgbGV0IHZhbCA9IHN0ci5zbGljZShlcUlkeCArIDEsIGVuZElkeCkudHJpbSgpO1xuICAgICAgaWYgKHZhbC5jb2RlUG9pbnRBdCgwKSA9PT0gMzQpIHtcbiAgICAgICAgdmFsID0gdmFsLnNsaWNlKDEsIC0xKTtcbiAgICAgIH1cbiAgICAgIGNvb2tpZXMuc2V0KGtleSwgdHJ5RGVjb2RlKHZhbCkpO1xuICAgIH1cbiAgICBpbmRleCA9IGVuZElkeCArIDE7XG4gIH1cbiAgcmV0dXJuIGNvb2tpZXM7XG59XG52YXIgX3NlcmlhbGl6ZSA9IChrZXksIHZhbHVlLCBvcHQgPSB7fSkgPT4ge1xuICBsZXQgY29va2llO1xuICBpZiAob3B0Py5wcmVmaXggPT09IFwic2VjdXJlXCIpIHtcbiAgICBjb29raWUgPSBgJHtgX19TZWN1cmUtJHtrZXl9YH09JHt2YWx1ZX1gO1xuICB9IGVsc2UgaWYgKG9wdD8ucHJlZml4ID09PSBcImhvc3RcIikge1xuICAgIGNvb2tpZSA9IGAke2BfX0hvc3QtJHtrZXl9YH09JHt2YWx1ZX1gO1xuICB9IGVsc2Uge1xuICAgIGNvb2tpZSA9IGAke2tleX09JHt2YWx1ZX1gO1xuICB9XG4gIGlmIChrZXkuc3RhcnRzV2l0aChcIl9fU2VjdXJlLVwiKSAmJiAhb3B0LnNlY3VyZSkge1xuICAgIG9wdC5zZWN1cmUgPSB0cnVlO1xuICB9XG4gIGlmIChrZXkuc3RhcnRzV2l0aChcIl9fSG9zdC1cIikpIHtcbiAgICBpZiAoIW9wdC5zZWN1cmUpIHtcbiAgICAgIG9wdC5zZWN1cmUgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAob3B0LnBhdGggIT09IFwiL1wiKSB7XG4gICAgICBvcHQucGF0aCA9IFwiL1wiO1xuICAgIH1cbiAgICBpZiAob3B0LmRvbWFpbikge1xuICAgICAgb3B0LmRvbWFpbiA9IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgaWYgKG9wdCAmJiB0eXBlb2Ygb3B0Lm1heEFnZSA9PT0gXCJudW1iZXJcIiAmJiBvcHQubWF4QWdlID49IDApIHtcbiAgICBpZiAob3B0Lm1heEFnZSA+IDM0NTZlNCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkNvb2tpZXMgTWF4LUFnZSBTSE9VTEQgTk9UIGJlIGdyZWF0ZXIgdGhhbiA0MDAgZGF5cyAoMzQ1NjAwMDAgc2Vjb25kcykgaW4gZHVyYXRpb24uXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGNvb2tpZSArPSBgOyBNYXgtQWdlPSR7TWF0aC5mbG9vcihvcHQubWF4QWdlKX1gO1xuICB9XG4gIGlmIChvcHQuZG9tYWluICYmIG9wdC5wcmVmaXggIT09IFwiaG9zdFwiKSB7XG4gICAgY29va2llICs9IGA7IERvbWFpbj0ke29wdC5kb21haW59YDtcbiAgfVxuICBpZiAob3B0LnBhdGgpIHtcbiAgICBjb29raWUgKz0gYDsgUGF0aD0ke29wdC5wYXRofWA7XG4gIH1cbiAgaWYgKG9wdC5leHBpcmVzKSB7XG4gICAgaWYgKG9wdC5leHBpcmVzLmdldFRpbWUoKSAtIERhdGUubm93KCkgPiAzNDU2ZTcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJDb29raWVzIEV4cGlyZXMgU0hPVUxEIE5PVCBiZSBncmVhdGVyIHRoYW4gNDAwIGRheXMgKDM0NTYwMDAwIHNlY29uZHMpIGluIHRoZSBmdXR1cmUuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGNvb2tpZSArPSBgOyBFeHBpcmVzPSR7b3B0LmV4cGlyZXMudG9VVENTdHJpbmcoKX1gO1xuICB9XG4gIGlmIChvcHQuaHR0cE9ubHkpIHtcbiAgICBjb29raWUgKz0gXCI7IEh0dHBPbmx5XCI7XG4gIH1cbiAgaWYgKG9wdC5zZWN1cmUpIHtcbiAgICBjb29raWUgKz0gXCI7IFNlY3VyZVwiO1xuICB9XG4gIGlmIChvcHQuc2FtZVNpdGUpIHtcbiAgICBjb29raWUgKz0gYDsgU2FtZVNpdGU9JHtvcHQuc2FtZVNpdGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBvcHQuc2FtZVNpdGUuc2xpY2UoMSl9YDtcbiAgfVxuICBpZiAob3B0LnBhcnRpdGlvbmVkKSB7XG4gICAgaWYgKCFvcHQuc2VjdXJlKSB7XG4gICAgICBvcHQuc2VjdXJlID0gdHJ1ZTtcbiAgICB9XG4gICAgY29va2llICs9IFwiOyBQYXJ0aXRpb25lZFwiO1xuICB9XG4gIHJldHVybiBjb29raWU7XG59O1xudmFyIHNlcmlhbGl6ZUNvb2tpZSA9IChrZXksIHZhbHVlLCBvcHQpID0+IHtcbiAgdmFsdWUgPSBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuICByZXR1cm4gX3NlcmlhbGl6ZShrZXksIHZhbHVlLCBvcHQpO1xufTtcbnZhciBzZXJpYWxpemVTaWduZWRDb29raWUgPSBhc3luYyAoa2V5LCB2YWx1ZSwgc2VjcmV0LCBvcHQpID0+IHtcbiAgdmFsdWUgPSBhd2FpdCBzaWduQ29va2llVmFsdWUodmFsdWUsIHNlY3JldCk7XG4gIHJldHVybiBfc2VyaWFsaXplKGtleSwgdmFsdWUsIG9wdCk7XG59O1xuXG4vLyBzcmMvY29udGV4dC50c1xudmFyIGNyZWF0ZUludGVybmFsQ29udGV4dCA9IGFzeW5jIChjb250ZXh0LCB7XG4gIG9wdGlvbnMsXG4gIHBhdGhcbn0pID0+IHtcbiAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHJ1blZhbGlkYXRpb24ob3B0aW9ucywgY29udGV4dCk7XG4gIGlmIChlcnJvcikge1xuICAgIHRocm93IG5ldyBBUElFcnJvcig0MDAsIHtcbiAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICBjb2RlOiBcIlZBTElEQVRJT05fRVJST1JcIlxuICAgIH0pO1xuICB9XG4gIGNvbnN0IHJlcXVlc3RIZWFkZXJzID0gXCJoZWFkZXJzXCIgaW4gY29udGV4dCA/IGNvbnRleHQuaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMgPyBjb250ZXh0LmhlYWRlcnMgOiBuZXcgSGVhZGVycyhjb250ZXh0LmhlYWRlcnMpIDogXCJyZXF1ZXN0XCIgaW4gY29udGV4dCAmJiBjb250ZXh0LnJlcXVlc3QgaW5zdGFuY2VvZiBSZXF1ZXN0ID8gY29udGV4dC5yZXF1ZXN0LmhlYWRlcnMgOiBudWxsO1xuICBjb25zdCByZXF1ZXN0Q29va2llcyA9IHJlcXVlc3RIZWFkZXJzPy5nZXQoXCJjb29raWVcIik7XG4gIGNvbnN0IHBhcnNlZENvb2tpZXMgPSByZXF1ZXN0Q29va2llcyA/IHBhcnNlQ29va2llcyhyZXF1ZXN0Q29va2llcykgOiB2b2lkIDA7XG4gIGNvbnN0IGludGVybmFsQ29udGV4dCA9IHtcbiAgICAuLi5jb250ZXh0LFxuICAgIGJvZHk6IGRhdGEuYm9keSxcbiAgICBxdWVyeTogZGF0YS5xdWVyeSxcbiAgICBwYXRoOiBjb250ZXh0LnBhdGggfHwgcGF0aCxcbiAgICBjb250ZXh0OiBcImNvbnRleHRcIiBpbiBjb250ZXh0ICYmIGNvbnRleHQuY29udGV4dCA/IGNvbnRleHQuY29udGV4dCA6IHt9LFxuICAgIHJldHVybmVkOiB2b2lkIDAsXG4gICAgaGVhZGVyczogY29udGV4dD8uaGVhZGVycyxcbiAgICByZXF1ZXN0OiBjb250ZXh0Py5yZXF1ZXN0LFxuICAgIHBhcmFtczogXCJwYXJhbXNcIiBpbiBjb250ZXh0ID8gY29udGV4dC5wYXJhbXMgOiB2b2lkIDAsXG4gICAgbWV0aG9kOiBjb250ZXh0Lm1ldGhvZCxcbiAgICBzZXRIZWFkZXI6IChrZXksIHZhbHVlKSA9PiB7XG4gICAgICBoZWFkZXJzLnNldChrZXksIHZhbHVlKTtcbiAgICB9LFxuICAgIGdldEhlYWRlcjogKGtleSkgPT4ge1xuICAgICAgaWYgKCFyZXF1ZXN0SGVhZGVycykgcmV0dXJuIG51bGw7XG4gICAgICByZXR1cm4gcmVxdWVzdEhlYWRlcnMuZ2V0KGtleSk7XG4gICAgfSxcbiAgICBnZXRDb29raWU6IChrZXksIHByZWZpeCkgPT4ge1xuICAgICAgY29uc3QgZmluYWxLZXkgPSBnZXRDb29raWVLZXkoa2V5LCBwcmVmaXgpO1xuICAgICAgaWYgKCFmaW5hbEtleSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZWRDb29raWVzPy5nZXQoZmluYWxLZXkpIHx8IG51bGw7XG4gICAgfSxcbiAgICBnZXRTaWduZWRDb29raWU6IGFzeW5jIChrZXksIHNlY3JldCwgcHJlZml4KSA9PiB7XG4gICAgICBjb25zdCBmaW5hbEtleSA9IGdldENvb2tpZUtleShrZXksIHByZWZpeCk7XG4gICAgICBpZiAoIWZpbmFsS2V5KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsdWUgPSBwYXJzZWRDb29raWVzPy5nZXQoZmluYWxLZXkpO1xuICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNpZ25hdHVyZVN0YXJ0UG9zID0gdmFsdWUubGFzdEluZGV4T2YoXCIuXCIpO1xuICAgICAgaWYgKHNpZ25hdHVyZVN0YXJ0UG9zIDwgMSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNpZ25lZFZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDAsIHNpZ25hdHVyZVN0YXJ0UG9zKTtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHZhbHVlLnN1YnN0cmluZyhzaWduYXR1cmVTdGFydFBvcyArIDEpO1xuICAgICAgaWYgKHNpZ25hdHVyZS5sZW5ndGggIT09IDQ0IHx8ICFzaWduYXR1cmUuZW5kc1dpdGgoXCI9XCIpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2VjcmV0S2V5ID0gYXdhaXQgZ2V0Q3J5cHRvS2V5KHNlY3JldCk7XG4gICAgICBjb25zdCBpc1ZlcmlmaWVkID0gYXdhaXQgdmVyaWZ5U2lnbmF0dXJlKHNpZ25hdHVyZSwgc2lnbmVkVmFsdWUsIHNlY3JldEtleSk7XG4gICAgICByZXR1cm4gaXNWZXJpZmllZCA/IHNpZ25lZFZhbHVlIDogZmFsc2U7XG4gICAgfSxcbiAgICBzZXRDb29raWU6IChrZXksIHZhbHVlLCBvcHRpb25zMikgPT4ge1xuICAgICAgY29uc3QgY29va2llID0gc2VyaWFsaXplQ29va2llKGtleSwgdmFsdWUsIG9wdGlvbnMyKTtcbiAgICAgIGhlYWRlcnMuYXBwZW5kKFwic2V0LWNvb2tpZVwiLCBjb29raWUpO1xuICAgICAgcmV0dXJuIGNvb2tpZTtcbiAgICB9LFxuICAgIHNldFNpZ25lZENvb2tpZTogYXN5bmMgKGtleSwgdmFsdWUsIHNlY3JldCwgb3B0aW9uczIpID0+IHtcbiAgICAgIGNvbnN0IGNvb2tpZSA9IGF3YWl0IHNlcmlhbGl6ZVNpZ25lZENvb2tpZShrZXksIHZhbHVlLCBzZWNyZXQsIG9wdGlvbnMyKTtcbiAgICAgIGhlYWRlcnMuYXBwZW5kKFwic2V0LWNvb2tpZVwiLCBjb29raWUpO1xuICAgICAgcmV0dXJuIGNvb2tpZTtcbiAgICB9LFxuICAgIHJlZGlyZWN0OiAodXJsKSA9PiB7XG4gICAgICBoZWFkZXJzLnNldChcImxvY2F0aW9uXCIsIHVybCk7XG4gICAgICByZXR1cm4gbmV3IEFQSUVycm9yKFwiRk9VTkRcIiwgdm9pZCAwLCBoZWFkZXJzKTtcbiAgICB9LFxuICAgIGVycm9yOiAoc3RhdHVzLCBib2R5LCBoZWFkZXJzMikgPT4ge1xuICAgICAgcmV0dXJuIG5ldyBBUElFcnJvcihzdGF0dXMsIGJvZHksIGhlYWRlcnMyKTtcbiAgICB9LFxuICAgIGpzb246IChqc29uLCByb3V0ZXJSZXNwb25zZSkgPT4ge1xuICAgICAgaWYgKCFjb250ZXh0LmFzUmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBib2R5OiByb3V0ZXJSZXNwb25zZT8uYm9keSB8fCBqc29uLFxuICAgICAgICByb3V0ZXJSZXNwb25zZSxcbiAgICAgICAgX2ZsYWc6IFwianNvblwiXG4gICAgICB9O1xuICAgIH0sXG4gICAgcmVzcG9uc2VIZWFkZXJzOiBoZWFkZXJzXG4gIH07XG4gIGZvciAoY29uc3QgbWlkZGxld2FyZSBvZiBvcHRpb25zLnVzZSB8fCBbXSkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgbWlkZGxld2FyZSh7XG4gICAgICAuLi5pbnRlcm5hbENvbnRleHQsXG4gICAgICByZXR1cm5IZWFkZXJzOiB0cnVlLFxuICAgICAgYXNSZXNwb25zZTogZmFsc2VcbiAgICB9KTtcbiAgICBpZiAocmVzcG9uc2UucmVzcG9uc2UpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24oaW50ZXJuYWxDb250ZXh0LmNvbnRleHQsIHJlc3BvbnNlLnJlc3BvbnNlKTtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlLmhlYWRlcnMpIHtcbiAgICAgIHJlc3BvbnNlLmhlYWRlcnMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICBpbnRlcm5hbENvbnRleHQucmVzcG9uc2VIZWFkZXJzLnNldChrZXksIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaW50ZXJuYWxDb250ZXh0O1xufTtcblxuLy8gc3JjL21pZGRsZXdhcmUudHNcbmZ1bmN0aW9uIGNyZWF0ZU1pZGRsZXdhcmUob3B0aW9uc09ySGFuZGxlciwgaGFuZGxlcikge1xuICBjb25zdCBpbnRlcm5hbEhhbmRsZXIgPSBhc3luYyAoaW5wdXRDdHgpID0+IHtcbiAgICBjb25zdCBjb250ZXh0ID0gaW5wdXRDdHg7XG4gICAgY29uc3QgX2hhbmRsZXIgPSB0eXBlb2Ygb3B0aW9uc09ySGFuZGxlciA9PT0gXCJmdW5jdGlvblwiID8gb3B0aW9uc09ySGFuZGxlciA6IGhhbmRsZXI7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zT3JIYW5kbGVyID09PSBcImZ1bmN0aW9uXCIgPyB7fSA6IG9wdGlvbnNPckhhbmRsZXI7XG4gICAgY29uc3QgaW50ZXJuYWxDb250ZXh0ID0gYXdhaXQgY3JlYXRlSW50ZXJuYWxDb250ZXh0KGNvbnRleHQsIHtcbiAgICAgIG9wdGlvbnMsXG4gICAgICBwYXRoOiBcIi9cIlxuICAgIH0pO1xuICAgIGlmICghX2hhbmRsZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImhhbmRsZXIgbXVzdCBiZSBkZWZpbmVkXCIpO1xuICAgIH1cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IF9oYW5kbGVyKGludGVybmFsQ29udGV4dCk7XG4gICAgY29uc3QgaGVhZGVycyA9IGludGVybmFsQ29udGV4dC5yZXNwb25zZUhlYWRlcnM7XG4gICAgcmV0dXJuIGNvbnRleHQucmV0dXJuSGVhZGVycyA/IHtcbiAgICAgIGhlYWRlcnMsXG4gICAgICByZXNwb25zZVxuICAgIH0gOiByZXNwb25zZTtcbiAgfTtcbiAgaW50ZXJuYWxIYW5kbGVyLm9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9uc09ySGFuZGxlciA9PT0gXCJmdW5jdGlvblwiID8ge30gOiBvcHRpb25zT3JIYW5kbGVyO1xuICByZXR1cm4gaW50ZXJuYWxIYW5kbGVyO1xufVxuY3JlYXRlTWlkZGxld2FyZS5jcmVhdGUgPSAob3B0cykgPT4ge1xuICBmdW5jdGlvbiBmbihvcHRpb25zT3JIYW5kbGVyLCBoYW5kbGVyKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zT3JIYW5kbGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiBjcmVhdGVNaWRkbGV3YXJlKFxuICAgICAgICB7XG4gICAgICAgICAgdXNlOiBvcHRzPy51c2VcbiAgICAgICAgfSxcbiAgICAgICAgb3B0aW9uc09ySGFuZGxlclxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaWRkbGV3YXJlIGhhbmRsZXIgaXMgcmVxdWlyZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IG1pZGRsZXdhcmUgPSBjcmVhdGVNaWRkbGV3YXJlKFxuICAgICAge1xuICAgICAgICAuLi5vcHRpb25zT3JIYW5kbGVyLFxuICAgICAgICBtZXRob2Q6IFwiKlwiLFxuICAgICAgICB1c2U6IFsuLi5vcHRzPy51c2UgfHwgW10sIC4uLm9wdGlvbnNPckhhbmRsZXIudXNlIHx8IFtdXVxuICAgICAgfSxcbiAgICAgIGhhbmRsZXJcbiAgICApO1xuICAgIHJldHVybiBtaWRkbGV3YXJlO1xuICB9XG4gIHJldHVybiBmbjtcbn07XG5cbi8vIHNyYy9lbmRwb2ludC50c1xudmFyIGNyZWF0ZUVuZHBvaW50MiA9IChwYXRoLCBvcHRpb25zLCBoYW5kbGVyKSA9PiB7XG4gIGNvbnN0IGludGVybmFsSGFuZGxlciA9IGFzeW5jICguLi5pbnB1dEN0eCkgPT4ge1xuICAgIGNvbnN0IGNvbnRleHQgPSBpbnB1dEN0eFswXSB8fCB7fTtcbiAgICBjb25zdCBpbnRlcm5hbENvbnRleHQgPSBhd2FpdCBjcmVhdGVJbnRlcm5hbENvbnRleHQoY29udGV4dCwge1xuICAgICAgb3B0aW9ucyxcbiAgICAgIHBhdGhcbiAgICB9KTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGhhbmRsZXIoaW50ZXJuYWxDb250ZXh0KS5jYXRjaChhc3luYyAoZSkgPT4ge1xuICAgICAgaWYgKGlzQVBJRXJyb3IoZSkpIHtcbiAgICAgICAgY29uc3Qgb25BUElFcnJvciA9IG9wdGlvbnMub25BUElFcnJvcjtcbiAgICAgICAgaWYgKG9uQVBJRXJyb3IpIHtcbiAgICAgICAgICBhd2FpdCBvbkFQSUVycm9yKGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZXh0LmFzUmVzcG9uc2UpIHtcbiAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhyb3cgZTtcbiAgICB9KTtcbiAgICBjb25zdCBoZWFkZXJzID0gaW50ZXJuYWxDb250ZXh0LnJlc3BvbnNlSGVhZGVycztcbiAgICByZXR1cm4gY29udGV4dC5hc1Jlc3BvbnNlID8gdG9SZXNwb25zZShyZXNwb25zZSwge1xuICAgICAgaGVhZGVyc1xuICAgIH0pIDogY29udGV4dC5yZXR1cm5IZWFkZXJzID8ge1xuICAgICAgaGVhZGVycyxcbiAgICAgIHJlc3BvbnNlXG4gICAgfSA6IHJlc3BvbnNlO1xuICB9O1xuICBpbnRlcm5hbEhhbmRsZXIub3B0aW9ucyA9IG9wdGlvbnM7XG4gIGludGVybmFsSGFuZGxlci5wYXRoID0gcGF0aDtcbiAgcmV0dXJuIGludGVybmFsSGFuZGxlcjtcbn07XG5jcmVhdGVFbmRwb2ludDIuY3JlYXRlID0gKG9wdHMpID0+IHtcbiAgcmV0dXJuIChwYXRoLCBvcHRpb25zLCBoYW5kbGVyKSA9PiB7XG4gICAgcmV0dXJuIGNyZWF0ZUVuZHBvaW50MihcbiAgICAgIHBhdGgsXG4gICAgICB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIHVzZTogWy4uLm9wdGlvbnM/LnVzZSB8fCBbXSwgLi4ub3B0cz8udXNlIHx8IFtdXVxuICAgICAgfSxcbiAgICAgIGhhbmRsZXJcbiAgICApO1xuICB9O1xufTtcblxuLy8gc3JjL3JvdXRlci50c1xuaW1wb3J0IHsgY3JlYXRlUm91dGVyIGFzIGNyZWF0ZVJvdTNSb3V0ZXIsIGFkZFJvdXRlLCBmaW5kUm91dGUsIGZpbmRBbGxSb3V0ZXMgfSBmcm9tIFwicm91M1wiO1xuXG4vLyBub2RlX21vZHVsZXMvLnBucG0vem9kQDQuMC4xL25vZGVfbW9kdWxlcy96b2QvdjQvY29yZS9jb3JlLmpzXG52YXIgTkVWRVIgPSBPYmplY3QuZnJlZXplKHtcbiAgc3RhdHVzOiBcImFib3J0ZWRcIlxufSk7XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gJGNvbnN0cnVjdG9yKG5hbWUsIGluaXRpYWxpemVyMywgcGFyYW1zKSB7XG4gIGZ1bmN0aW9uIGluaXQoaW5zdCwgZGVmKSB7XG4gICAgdmFyIF9hO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbnN0LCBcIl96b2RcIiwge1xuICAgICAgdmFsdWU6IGluc3QuX3pvZCA/PyB7fSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgfSk7XG4gICAgKF9hID0gaW5zdC5fem9kKS50cmFpdHMgPz8gKF9hLnRyYWl0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpO1xuICAgIGluc3QuX3pvZC50cmFpdHMuYWRkKG5hbWUpO1xuICAgIGluaXRpYWxpemVyMyhpbnN0LCBkZWYpO1xuICAgIGZvciAoY29uc3QgayBpbiBfLnByb3RvdHlwZSkge1xuICAgICAgaWYgKCEoayBpbiBpbnN0KSlcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGluc3QsIGssIHsgdmFsdWU6IF8ucHJvdG90eXBlW2tdLmJpbmQoaW5zdCkgfSk7XG4gICAgfVxuICAgIGluc3QuX3pvZC5jb25zdHIgPSBfO1xuICAgIGluc3QuX3pvZC5kZWYgPSBkZWY7XG4gIH1cbiAgY29uc3QgUGFyZW50ID0gcGFyYW1zPy5QYXJlbnQgPz8gT2JqZWN0O1xuICBjbGFzcyBEZWZpbml0aW9uIGV4dGVuZHMgUGFyZW50IHtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVmaW5pdGlvbiwgXCJuYW1lXCIsIHsgdmFsdWU6IG5hbWUgfSk7XG4gIGZ1bmN0aW9uIF8oZGVmKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGluc3QgPSBwYXJhbXM/LlBhcmVudCA/IG5ldyBEZWZpbml0aW9uKCkgOiB0aGlzO1xuICAgIGluaXQoaW5zdCwgZGVmKTtcbiAgICAoX2EgPSBpbnN0Ll96b2QpLmRlZmVycmVkID8/IChfYS5kZWZlcnJlZCA9IFtdKTtcbiAgICBmb3IgKGNvbnN0IGZuIG9mIGluc3QuX3pvZC5kZWZlcnJlZCkge1xuICAgICAgZm4oKTtcbiAgICB9XG4gICAgcmV0dXJuIGluc3Q7XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF8sIFwiaW5pdFwiLCB7IHZhbHVlOiBpbml0IH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXywgU3ltYm9sLmhhc0luc3RhbmNlLCB7XG4gICAgdmFsdWU6IChpbnN0KSA9PiB7XG4gICAgICBpZiAocGFyYW1zPy5QYXJlbnQgJiYgaW5zdCBpbnN0YW5jZW9mIHBhcmFtcy5QYXJlbnQpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgcmV0dXJuIGluc3Q/Ll96b2Q/LnRyYWl0cz8uaGFzKG5hbWUpO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfLCBcIm5hbWVcIiwgeyB2YWx1ZTogbmFtZSB9KTtcbiAgcmV0dXJuIF87XG59XG52YXIgJGJyYW5kID0gU3ltYm9sKFwiem9kX2JyYW5kXCIpO1xudmFyICRab2RBc3luY0Vycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKGBFbmNvdW50ZXJlZCBQcm9taXNlIGR1cmluZyBzeW5jaHJvbm91cyBwYXJzZS4gVXNlIC5wYXJzZUFzeW5jKCkgaW5zdGVhZC5gKTtcbiAgfVxufTtcbnZhciBnbG9iYWxDb25maWcgPSB7fTtcbmZ1bmN0aW9uIGNvbmZpZyhuZXdDb25maWcpIHtcbiAgaWYgKG5ld0NvbmZpZylcbiAgICBPYmplY3QuYXNzaWduKGdsb2JhbENvbmZpZywgbmV3Q29uZmlnKTtcbiAgcmV0dXJuIGdsb2JhbENvbmZpZztcbn1cblxuLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3pvZEA0LjAuMS9ub2RlX21vZHVsZXMvem9kL3Y0L2NvcmUvdXRpbC5qc1xudmFyIHV0aWxfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQodXRpbF9leHBvcnRzLCB7XG4gIEJJR0lOVF9GT1JNQVRfUkFOR0VTOiAoKSA9PiBCSUdJTlRfRk9STUFUX1JBTkdFUyxcbiAgQ2xhc3M6ICgpID0+IENsYXNzLFxuICBOVU1CRVJfRk9STUFUX1JBTkdFUzogKCkgPT4gTlVNQkVSX0ZPUk1BVF9SQU5HRVMsXG4gIGFib3J0ZWQ6ICgpID0+IGFib3J0ZWQsXG4gIGFsbG93c0V2YWw6ICgpID0+IGFsbG93c0V2YWwsXG4gIGFzc2VydDogKCkgPT4gYXNzZXJ0LFxuICBhc3NlcnRFcXVhbDogKCkgPT4gYXNzZXJ0RXF1YWwsXG4gIGFzc2VydElzOiAoKSA9PiBhc3NlcnRJcyxcbiAgYXNzZXJ0TmV2ZXI6ICgpID0+IGFzc2VydE5ldmVyLFxuICBhc3NlcnROb3RFcXVhbDogKCkgPT4gYXNzZXJ0Tm90RXF1YWwsXG4gIGFzc2lnblByb3A6ICgpID0+IGFzc2lnblByb3AsXG4gIGNhY2hlZDogKCkgPT4gY2FjaGVkLFxuICBjYXB0dXJlU3RhY2tUcmFjZTogKCkgPT4gY2FwdHVyZVN0YWNrVHJhY2UsXG4gIGNsZWFuRW51bTogKCkgPT4gY2xlYW5FbnVtLFxuICBjbGVhblJlZ2V4OiAoKSA9PiBjbGVhblJlZ2V4LFxuICBjbG9uZTogKCkgPT4gY2xvbmUsXG4gIGNyZWF0ZVRyYW5zcGFyZW50UHJveHk6ICgpID0+IGNyZWF0ZVRyYW5zcGFyZW50UHJveHksXG4gIGRlZmluZUxhenk6ICgpID0+IGRlZmluZUxhenksXG4gIGVzYzogKCkgPT4gZXNjLFxuICBlc2NhcGVSZWdleDogKCkgPT4gZXNjYXBlUmVnZXgsXG4gIGV4dGVuZDogKCkgPT4gZXh0ZW5kLFxuICBmaW5hbGl6ZUlzc3VlOiAoKSA9PiBmaW5hbGl6ZUlzc3VlLFxuICBmbG9hdFNhZmVSZW1haW5kZXI6ICgpID0+IGZsb2F0U2FmZVJlbWFpbmRlcixcbiAgZ2V0RWxlbWVudEF0UGF0aDogKCkgPT4gZ2V0RWxlbWVudEF0UGF0aCxcbiAgZ2V0RW51bVZhbHVlczogKCkgPT4gZ2V0RW51bVZhbHVlcyxcbiAgZ2V0TGVuZ3RoYWJsZU9yaWdpbjogKCkgPT4gZ2V0TGVuZ3RoYWJsZU9yaWdpbixcbiAgZ2V0UGFyc2VkVHlwZTogKCkgPT4gZ2V0UGFyc2VkVHlwZSxcbiAgZ2V0U2l6YWJsZU9yaWdpbjogKCkgPT4gZ2V0U2l6YWJsZU9yaWdpbixcbiAgaXNPYmplY3Q6ICgpID0+IGlzT2JqZWN0LFxuICBpc1BsYWluT2JqZWN0OiAoKSA9PiBpc1BsYWluT2JqZWN0LFxuICBpc3N1ZTogKCkgPT4gaXNzdWUsXG4gIGpvaW5WYWx1ZXM6ICgpID0+IGpvaW5WYWx1ZXMsXG4gIGpzb25TdHJpbmdpZnlSZXBsYWNlcjogKCkgPT4ganNvblN0cmluZ2lmeVJlcGxhY2VyLFxuICBtZXJnZTogKCkgPT4gbWVyZ2UsXG4gIG5vcm1hbGl6ZVBhcmFtczogKCkgPT4gbm9ybWFsaXplUGFyYW1zLFxuICBudWxsaXNoOiAoKSA9PiBudWxsaXNoLFxuICBudW1LZXlzOiAoKSA9PiBudW1LZXlzLFxuICBvbWl0OiAoKSA9PiBvbWl0LFxuICBvcHRpb25hbEtleXM6ICgpID0+IG9wdGlvbmFsS2V5cyxcbiAgcGFydGlhbDogKCkgPT4gcGFydGlhbCxcbiAgcGljazogKCkgPT4gcGljayxcbiAgcHJlZml4SXNzdWVzOiAoKSA9PiBwcmVmaXhJc3N1ZXMsXG4gIHByaW1pdGl2ZVR5cGVzOiAoKSA9PiBwcmltaXRpdmVUeXBlcyxcbiAgcHJvbWlzZUFsbE9iamVjdDogKCkgPT4gcHJvbWlzZUFsbE9iamVjdCxcbiAgcHJvcGVydHlLZXlUeXBlczogKCkgPT4gcHJvcGVydHlLZXlUeXBlcyxcbiAgcmFuZG9tU3RyaW5nOiAoKSA9PiByYW5kb21TdHJpbmcsXG4gIHJlcXVpcmVkOiAoKSA9PiByZXF1aXJlZCxcbiAgc3RyaW5naWZ5UHJpbWl0aXZlOiAoKSA9PiBzdHJpbmdpZnlQcmltaXRpdmUsXG4gIHVud3JhcE1lc3NhZ2U6ICgpID0+IHVud3JhcE1lc3NhZ2Vcbn0pO1xuZnVuY3Rpb24gYXNzZXJ0RXF1YWwodmFsKSB7XG4gIHJldHVybiB2YWw7XG59XG5mdW5jdGlvbiBhc3NlcnROb3RFcXVhbCh2YWwpIHtcbiAgcmV0dXJuIHZhbDtcbn1cbmZ1bmN0aW9uIGFzc2VydElzKF9hcmcpIHtcbn1cbmZ1bmN0aW9uIGFzc2VydE5ldmVyKF94KSB7XG4gIHRocm93IG5ldyBFcnJvcigpO1xufVxuZnVuY3Rpb24gYXNzZXJ0KF8pIHtcbn1cbmZ1bmN0aW9uIGdldEVudW1WYWx1ZXMoZW50cmllcykge1xuICBjb25zdCBudW1lcmljVmFsdWVzID0gT2JqZWN0LnZhbHVlcyhlbnRyaWVzKS5maWx0ZXIoKHYpID0+IHR5cGVvZiB2ID09PSBcIm51bWJlclwiKTtcbiAgY29uc3QgdmFsdWVzID0gT2JqZWN0LmVudHJpZXMoZW50cmllcykuZmlsdGVyKChbaywgX10pID0+IG51bWVyaWNWYWx1ZXMuaW5kZXhPZigraykgPT09IC0xKS5tYXAoKFtfLCB2XSkgPT4gdik7XG4gIHJldHVybiB2YWx1ZXM7XG59XG5mdW5jdGlvbiBqb2luVmFsdWVzKGFycmF5Miwgc2VwYXJhdG9yID0gXCJ8XCIpIHtcbiAgcmV0dXJuIGFycmF5Mi5tYXAoKHZhbCkgPT4gc3RyaW5naWZ5UHJpbWl0aXZlKHZhbCkpLmpvaW4oc2VwYXJhdG9yKTtcbn1cbmZ1bmN0aW9uIGpzb25TdHJpbmdpZnlSZXBsYWNlcihfLCB2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiKVxuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBjYWNoZWQoZ2V0dGVyKSB7XG4gIGNvbnN0IHNldCA9IGZhbHNlO1xuICByZXR1cm4ge1xuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgIGlmICghc2V0KSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZ2V0dGVyKCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZhbHVlXCIsIHsgdmFsdWUgfSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNhY2hlZCB2YWx1ZSBhbHJlYWR5IHNldFwiKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBudWxsaXNoKGlucHV0KSB7XG4gIHJldHVybiBpbnB1dCA9PT0gbnVsbCB8fCBpbnB1dCA9PT0gdm9pZCAwO1xufVxuZnVuY3Rpb24gY2xlYW5SZWdleChzb3VyY2UpIHtcbiAgY29uc3Qgc3RhcnQgPSBzb3VyY2Uuc3RhcnRzV2l0aChcIl5cIikgPyAxIDogMDtcbiAgY29uc3QgZW5kID0gc291cmNlLmVuZHNXaXRoKFwiJFwiKSA/IHNvdXJjZS5sZW5ndGggLSAxIDogc291cmNlLmxlbmd0aDtcbiAgcmV0dXJuIHNvdXJjZS5zbGljZShzdGFydCwgZW5kKTtcbn1cbmZ1bmN0aW9uIGZsb2F0U2FmZVJlbWFpbmRlcih2YWwsIHN0ZXApIHtcbiAgY29uc3QgdmFsRGVjQ291bnQgPSAodmFsLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpWzFdIHx8IFwiXCIpLmxlbmd0aDtcbiAgY29uc3Qgc3RlcERlY0NvdW50ID0gKHN0ZXAudG9TdHJpbmcoKS5zcGxpdChcIi5cIilbMV0gfHwgXCJcIikubGVuZ3RoO1xuICBjb25zdCBkZWNDb3VudCA9IHZhbERlY0NvdW50ID4gc3RlcERlY0NvdW50ID8gdmFsRGVjQ291bnQgOiBzdGVwRGVjQ291bnQ7XG4gIGNvbnN0IHZhbEludCA9IE51bWJlci5wYXJzZUludCh2YWwudG9GaXhlZChkZWNDb3VudCkucmVwbGFjZShcIi5cIiwgXCJcIikpO1xuICBjb25zdCBzdGVwSW50ID0gTnVtYmVyLnBhcnNlSW50KHN0ZXAudG9GaXhlZChkZWNDb3VudCkucmVwbGFjZShcIi5cIiwgXCJcIikpO1xuICByZXR1cm4gdmFsSW50ICUgc3RlcEludCAvIDEwICoqIGRlY0NvdW50O1xufVxuZnVuY3Rpb24gZGVmaW5lTGF6eShvYmplY3QsIGtleSwgZ2V0dGVyKSB7XG4gIGNvbnN0IHNldCA9IGZhbHNlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcbiAgICBnZXQoKSB7XG4gICAgICBpZiAoIXNldCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGdldHRlcigpO1xuICAgICAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYWNoZWQgdmFsdWUgYWxyZWFkeSBzZXRcIik7XG4gICAgfSxcbiAgICBzZXQodikge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwga2V5LCB7XG4gICAgICAgIHZhbHVlOiB2XG4gICAgICAgIC8vIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuZnVuY3Rpb24gYXNzaWduUHJvcCh0YXJnZXQsIHByb3AsIHZhbHVlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3AsIHtcbiAgICB2YWx1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cbmZ1bmN0aW9uIGdldEVsZW1lbnRBdFBhdGgob2JqLCBwYXRoKSB7XG4gIGlmICghcGF0aClcbiAgICByZXR1cm4gb2JqO1xuICByZXR1cm4gcGF0aC5yZWR1Y2UoKGFjYywga2V5KSA9PiBhY2M/LltrZXldLCBvYmopO1xufVxuZnVuY3Rpb24gcHJvbWlzZUFsbE9iamVjdChwcm9taXNlc09iaikge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocHJvbWlzZXNPYmopO1xuICBjb25zdCBwcm9taXNlcyA9IGtleXMubWFwKChrZXkpID0+IHByb21pc2VzT2JqW2tleV0pO1xuICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oKHJlc3VsdHMpID0+IHtcbiAgICBjb25zdCByZXNvbHZlZE9iaiA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzb2x2ZWRPYmpba2V5c1tpXV0gPSByZXN1bHRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzb2x2ZWRPYmo7XG4gIH0pO1xufVxuZnVuY3Rpb24gcmFuZG9tU3RyaW5nKGxlbmd0aCA9IDEwKSB7XG4gIGNvbnN0IGNoYXJzID0gXCJhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiO1xuICBsZXQgc3RyID0gXCJcIjtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHN0ciArPSBjaGFyc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGFycy5sZW5ndGgpXTtcbiAgfVxuICByZXR1cm4gc3RyO1xufVxuZnVuY3Rpb24gZXNjKHN0cikge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoc3RyKTtcbn1cbnZhciBjYXB0dXJlU3RhY2tUcmFjZSA9IEVycm9yLmNhcHR1cmVTdGFja1RyYWNlID8gRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgOiAoLi4uX2FyZ3MpID0+IHtcbn07XG5mdW5jdGlvbiBpc09iamVjdChkYXRhKSB7XG4gIHJldHVybiB0eXBlb2YgZGF0YSA9PT0gXCJvYmplY3RcIiAmJiBkYXRhICE9PSBudWxsICYmICFBcnJheS5pc0FycmF5KGRhdGEpO1xufVxudmFyIGFsbG93c0V2YWwgPSBjYWNoZWQoKCkgPT4ge1xuICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBuYXZpZ2F0b3I/LnVzZXJBZ2VudD8uaW5jbHVkZXMoXCJDbG91ZGZsYXJlXCIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgRiA9IEZ1bmN0aW9uO1xuICAgIG5ldyBGKFwiXCIpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59KTtcbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qobykge1xuICBpZiAoaXNPYmplY3QobykgPT09IGZhbHNlKVxuICAgIHJldHVybiBmYWxzZTtcbiAgY29uc3QgY3RvciA9IG8uY29uc3RydWN0b3I7XG4gIGlmIChjdG9yID09PSB2b2lkIDApXG4gICAgcmV0dXJuIHRydWU7XG4gIGNvbnN0IHByb3QgPSBjdG9yLnByb3RvdHlwZTtcbiAgaWYgKGlzT2JqZWN0KHByb3QpID09PSBmYWxzZSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocHJvdCwgXCJpc1Byb3RvdHlwZU9mXCIpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIG51bUtleXMoZGF0YSkge1xuICBsZXQga2V5Q291bnQgPSAwO1xuICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpKSB7XG4gICAgICBrZXlDb3VudCsrO1xuICAgIH1cbiAgfVxuICByZXR1cm4ga2V5Q291bnQ7XG59XG52YXIgZ2V0UGFyc2VkVHlwZSA9IChkYXRhKSA9PiB7XG4gIGNvbnN0IHQgPSB0eXBlb2YgZGF0YTtcbiAgc3dpdGNoICh0KSB7XG4gICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgcmV0dXJuIFwidW5kZWZpbmVkXCI7XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgcmV0dXJuIE51bWJlci5pc05hTihkYXRhKSA/IFwibmFuXCIgOiBcIm51bWJlclwiO1xuICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICByZXR1cm4gXCJib29sZWFuXCI7XG4gICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICByZXR1cm4gXCJmdW5jdGlvblwiO1xuICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgIHJldHVybiBcImJpZ2ludFwiO1xuICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgIHJldHVybiBcInN5bWJvbFwiO1xuICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgIHJldHVybiBcImFycmF5XCI7XG4gICAgICB9XG4gICAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgICB9XG4gICAgICBpZiAoZGF0YS50aGVuICYmIHR5cGVvZiBkYXRhLnRoZW4gPT09IFwiZnVuY3Rpb25cIiAmJiBkYXRhLmNhdGNoICYmIHR5cGVvZiBkYXRhLmNhdGNoID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIFwicHJvbWlzZVwiO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBNYXAgIT09IFwidW5kZWZpbmVkXCIgJiYgZGF0YSBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICByZXR1cm4gXCJtYXBcIjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgU2V0ICE9PSBcInVuZGVmaW5lZFwiICYmIGRhdGEgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgcmV0dXJuIFwic2V0XCI7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIERhdGUgIT09IFwidW5kZWZpbmVkXCIgJiYgZGF0YSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIFwiZGF0ZVwiO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBGaWxlICE9PSBcInVuZGVmaW5lZFwiICYmIGRhdGEgaW5zdGFuY2VvZiBGaWxlKSB7XG4gICAgICAgIHJldHVybiBcImZpbGVcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBcIm9iamVjdFwiO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZGF0YSB0eXBlOiAke3R9YCk7XG4gIH1cbn07XG52YXIgcHJvcGVydHlLZXlUeXBlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcInN0cmluZ1wiLCBcIm51bWJlclwiLCBcInN5bWJvbFwiXSk7XG52YXIgcHJpbWl0aXZlVHlwZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJzdHJpbmdcIiwgXCJudW1iZXJcIiwgXCJiaWdpbnRcIiwgXCJib29sZWFuXCIsIFwic3ltYm9sXCIsIFwidW5kZWZpbmVkXCJdKTtcbmZ1bmN0aW9uIGVzY2FwZVJlZ2V4KHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCBcIlxcXFwkJlwiKTtcbn1cbmZ1bmN0aW9uIGNsb25lKGluc3QsIGRlZiwgcGFyYW1zKSB7XG4gIGNvbnN0IGNsID0gbmV3IGluc3QuX3pvZC5jb25zdHIoZGVmID8/IGluc3QuX3pvZC5kZWYpO1xuICBpZiAoIWRlZiB8fCBwYXJhbXM/LnBhcmVudClcbiAgICBjbC5fem9kLnBhcmVudCA9IGluc3Q7XG4gIHJldHVybiBjbDtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVBhcmFtcyhfcGFyYW1zKSB7XG4gIGNvbnN0IHBhcmFtcyA9IF9wYXJhbXM7XG4gIGlmICghcGFyYW1zKVxuICAgIHJldHVybiB7fTtcbiAgaWYgKHR5cGVvZiBwYXJhbXMgPT09IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIHsgZXJyb3I6ICgpID0+IHBhcmFtcyB9O1xuICBpZiAocGFyYW1zPy5tZXNzYWdlICE9PSB2b2lkIDApIHtcbiAgICBpZiAocGFyYW1zPy5lcnJvciAhPT0gdm9pZCAwKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNwZWNpZnkgYm90aCBgbWVzc2FnZWAgYW5kIGBlcnJvcmAgcGFyYW1zXCIpO1xuICAgIHBhcmFtcy5lcnJvciA9IHBhcmFtcy5tZXNzYWdlO1xuICB9XG4gIGRlbGV0ZSBwYXJhbXMubWVzc2FnZTtcbiAgaWYgKHR5cGVvZiBwYXJhbXMuZXJyb3IgPT09IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIHsgLi4ucGFyYW1zLCBlcnJvcjogKCkgPT4gcGFyYW1zLmVycm9yIH07XG4gIHJldHVybiBwYXJhbXM7XG59XG5mdW5jdGlvbiBjcmVhdGVUcmFuc3BhcmVudFByb3h5KGdldHRlcikge1xuICBsZXQgdGFyZ2V0O1xuICByZXR1cm4gbmV3IFByb3h5KHt9LCB7XG4gICAgZ2V0KF8sIHByb3AsIHJlY2VpdmVyKSB7XG4gICAgICB0YXJnZXQgPz8gKHRhcmdldCA9IGdldHRlcigpKTtcbiAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICB9LFxuICAgIHNldChfLCBwcm9wLCB2YWx1ZSwgcmVjZWl2ZXIpIHtcbiAgICAgIHRhcmdldCA/PyAodGFyZ2V0ID0gZ2V0dGVyKCkpO1xuICAgICAgcmV0dXJuIFJlZmxlY3Quc2V0KHRhcmdldCwgcHJvcCwgdmFsdWUsIHJlY2VpdmVyKTtcbiAgICB9LFxuICAgIGhhcyhfLCBwcm9wKSB7XG4gICAgICB0YXJnZXQgPz8gKHRhcmdldCA9IGdldHRlcigpKTtcbiAgICAgIHJldHVybiBSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3ApO1xuICAgIH0sXG4gICAgZGVsZXRlUHJvcGVydHkoXywgcHJvcCkge1xuICAgICAgdGFyZ2V0ID8/ICh0YXJnZXQgPSBnZXR0ZXIoKSk7XG4gICAgICByZXR1cm4gUmVmbGVjdC5kZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3ApO1xuICAgIH0sXG4gICAgb3duS2V5cyhfKSB7XG4gICAgICB0YXJnZXQgPz8gKHRhcmdldCA9IGdldHRlcigpKTtcbiAgICAgIHJldHVybiBSZWZsZWN0Lm93bktleXModGFyZ2V0KTtcbiAgICB9LFxuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihfLCBwcm9wKSB7XG4gICAgICB0YXJnZXQgPz8gKHRhcmdldCA9IGdldHRlcigpKTtcbiAgICAgIHJldHVybiBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3ApO1xuICAgIH0sXG4gICAgZGVmaW5lUHJvcGVydHkoXywgcHJvcCwgZGVzY3JpcHRvcikge1xuICAgICAgdGFyZ2V0ID8/ICh0YXJnZXQgPSBnZXR0ZXIoKSk7XG4gICAgICByZXR1cm4gUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3AsIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlQcmltaXRpdmUodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIilcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKSArIFwiblwiO1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKVxuICAgIHJldHVybiBgXCIke3ZhbHVlfVwiYDtcbiAgcmV0dXJuIGAke3ZhbHVlfWA7XG59XG5mdW5jdGlvbiBvcHRpb25hbEtleXMoc2hhcGUpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHNoYXBlKS5maWx0ZXIoKGspID0+IHtcbiAgICByZXR1cm4gc2hhcGVba10uX3pvZC5vcHRpbiA9PT0gXCJvcHRpb25hbFwiICYmIHNoYXBlW2tdLl96b2Qub3B0b3V0ID09PSBcIm9wdGlvbmFsXCI7XG4gIH0pO1xufVxudmFyIE5VTUJFUl9GT1JNQVRfUkFOR0VTID0ge1xuICBzYWZlaW50OiBbTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIsIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXSxcbiAgaW50MzI6IFstMjE0NzQ4MzY0OCwgMjE0NzQ4MzY0N10sXG4gIHVpbnQzMjogWzAsIDQyOTQ5NjcyOTVdLFxuICBmbG9hdDMyOiBbLTM0MDI4MjM0NjYzODUyODg2ZTIyLCAzNDAyODIzNDY2Mzg1Mjg4NmUyMl0sXG4gIGZsb2F0NjQ6IFstTnVtYmVyLk1BWF9WQUxVRSwgTnVtYmVyLk1BWF9WQUxVRV1cbn07XG52YXIgQklHSU5UX0ZPUk1BVF9SQU5HRVMgPSB7XG4gIGludDY0OiBbLyogQF9fUFVSRV9fICovIEJpZ0ludChcIi05MjIzMzcyMDM2ODU0Nzc1ODA4XCIpLCAvKiBAX19QVVJFX18gKi8gQmlnSW50KFwiOTIyMzM3MjAzNjg1NDc3NTgwN1wiKV0sXG4gIHVpbnQ2NDogWy8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMCksIC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoXCIxODQ0Njc0NDA3MzcwOTU1MTYxNVwiKV1cbn07XG5mdW5jdGlvbiBwaWNrKHNjaGVtYSwgbWFzaykge1xuICBjb25zdCBuZXdTaGFwZSA9IHt9O1xuICBjb25zdCBjdXJyRGVmID0gc2NoZW1hLl96b2QuZGVmO1xuICBmb3IgKGNvbnN0IGtleSBpbiBtYXNrKSB7XG4gICAgaWYgKCEoa2V5IGluIGN1cnJEZWYuc2hhcGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBrZXk6IFwiJHtrZXl9XCJgKTtcbiAgICB9XG4gICAgaWYgKCFtYXNrW2tleV0pXG4gICAgICBjb250aW51ZTtcbiAgICBuZXdTaGFwZVtrZXldID0gY3VyckRlZi5zaGFwZVtrZXldO1xuICB9XG4gIHJldHVybiBjbG9uZShzY2hlbWEsIHtcbiAgICAuLi5zY2hlbWEuX3pvZC5kZWYsXG4gICAgc2hhcGU6IG5ld1NoYXBlLFxuICAgIGNoZWNrczogW11cbiAgfSk7XG59XG5mdW5jdGlvbiBvbWl0KHNjaGVtYSwgbWFzaykge1xuICBjb25zdCBuZXdTaGFwZSA9IHsgLi4uc2NoZW1hLl96b2QuZGVmLnNoYXBlIH07XG4gIGNvbnN0IGN1cnJEZWYgPSBzY2hlbWEuX3pvZC5kZWY7XG4gIGZvciAoY29uc3Qga2V5IGluIG1hc2spIHtcbiAgICBpZiAoIShrZXkgaW4gY3VyckRlZi5zaGFwZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIGtleTogXCIke2tleX1cImApO1xuICAgIH1cbiAgICBpZiAoIW1hc2tba2V5XSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIGRlbGV0ZSBuZXdTaGFwZVtrZXldO1xuICB9XG4gIHJldHVybiBjbG9uZShzY2hlbWEsIHtcbiAgICAuLi5zY2hlbWEuX3pvZC5kZWYsXG4gICAgc2hhcGU6IG5ld1NoYXBlLFxuICAgIGNoZWNrczogW11cbiAgfSk7XG59XG5mdW5jdGlvbiBleHRlbmQoc2NoZW1hLCBzaGFwZSkge1xuICBpZiAoIWlzUGxhaW5PYmplY3Qoc2hhcGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0byBleHRlbmQ6IGV4cGVjdGVkIGEgcGxhaW4gb2JqZWN0XCIpO1xuICB9XG4gIGNvbnN0IGRlZiA9IHtcbiAgICAuLi5zY2hlbWEuX3pvZC5kZWYsXG4gICAgZ2V0IHNoYXBlKCkge1xuICAgICAgY29uc3QgX3NoYXBlID0geyAuLi5zY2hlbWEuX3pvZC5kZWYuc2hhcGUsIC4uLnNoYXBlIH07XG4gICAgICBhc3NpZ25Qcm9wKHRoaXMsIFwic2hhcGVcIiwgX3NoYXBlKTtcbiAgICAgIHJldHVybiBfc2hhcGU7XG4gICAgfSxcbiAgICBjaGVja3M6IFtdXG4gICAgLy8gZGVsZXRlIGV4aXN0aW5nIGNoZWNrc1xuICB9O1xuICByZXR1cm4gY2xvbmUoc2NoZW1hLCBkZWYpO1xufVxuZnVuY3Rpb24gbWVyZ2UoYSwgYikge1xuICByZXR1cm4gY2xvbmUoYSwge1xuICAgIC4uLmEuX3pvZC5kZWYsXG4gICAgZ2V0IHNoYXBlKCkge1xuICAgICAgY29uc3QgX3NoYXBlID0geyAuLi5hLl96b2QuZGVmLnNoYXBlLCAuLi5iLl96b2QuZGVmLnNoYXBlIH07XG4gICAgICBhc3NpZ25Qcm9wKHRoaXMsIFwic2hhcGVcIiwgX3NoYXBlKTtcbiAgICAgIHJldHVybiBfc2hhcGU7XG4gICAgfSxcbiAgICBjYXRjaGFsbDogYi5fem9kLmRlZi5jYXRjaGFsbCxcbiAgICBjaGVja3M6IFtdXG4gICAgLy8gZGVsZXRlIGV4aXN0aW5nIGNoZWNrc1xuICB9KTtcbn1cbmZ1bmN0aW9uIHBhcnRpYWwoQ2xhc3MyLCBzY2hlbWEsIG1hc2spIHtcbiAgY29uc3Qgb2xkU2hhcGUgPSBzY2hlbWEuX3pvZC5kZWYuc2hhcGU7XG4gIGNvbnN0IHNoYXBlID0geyAuLi5vbGRTaGFwZSB9O1xuICBpZiAobWFzaykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIG1hc2spIHtcbiAgICAgIGlmICghKGtleSBpbiBvbGRTaGFwZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQga2V5OiBcIiR7a2V5fVwiYCk7XG4gICAgICB9XG4gICAgICBpZiAoIW1hc2tba2V5XSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBzaGFwZVtrZXldID0gQ2xhc3MyID8gbmV3IENsYXNzMih7XG4gICAgICAgIHR5cGU6IFwib3B0aW9uYWxcIixcbiAgICAgICAgaW5uZXJUeXBlOiBvbGRTaGFwZVtrZXldXG4gICAgICB9KSA6IG9sZFNoYXBlW2tleV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9sZFNoYXBlKSB7XG4gICAgICBzaGFwZVtrZXldID0gQ2xhc3MyID8gbmV3IENsYXNzMih7XG4gICAgICAgIHR5cGU6IFwib3B0aW9uYWxcIixcbiAgICAgICAgaW5uZXJUeXBlOiBvbGRTaGFwZVtrZXldXG4gICAgICB9KSA6IG9sZFNoYXBlW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiBjbG9uZShzY2hlbWEsIHtcbiAgICAuLi5zY2hlbWEuX3pvZC5kZWYsXG4gICAgc2hhcGUsXG4gICAgY2hlY2tzOiBbXVxuICB9KTtcbn1cbmZ1bmN0aW9uIHJlcXVpcmVkKENsYXNzMiwgc2NoZW1hLCBtYXNrKSB7XG4gIGNvbnN0IG9sZFNoYXBlID0gc2NoZW1hLl96b2QuZGVmLnNoYXBlO1xuICBjb25zdCBzaGFwZSA9IHsgLi4ub2xkU2hhcGUgfTtcbiAgaWYgKG1hc2spIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBtYXNrKSB7XG4gICAgICBpZiAoIShrZXkgaW4gc2hhcGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIGtleTogXCIke2tleX1cImApO1xuICAgICAgfVxuICAgICAgaWYgKCFtYXNrW2tleV0pXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgc2hhcGVba2V5XSA9IG5ldyBDbGFzczIoe1xuICAgICAgICB0eXBlOiBcIm5vbm9wdGlvbmFsXCIsXG4gICAgICAgIGlubmVyVHlwZTogb2xkU2hhcGVba2V5XVxuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9sZFNoYXBlKSB7XG4gICAgICBzaGFwZVtrZXldID0gbmV3IENsYXNzMih7XG4gICAgICAgIHR5cGU6IFwibm9ub3B0aW9uYWxcIixcbiAgICAgICAgaW5uZXJUeXBlOiBvbGRTaGFwZVtrZXldXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNsb25lKHNjaGVtYSwge1xuICAgIC4uLnNjaGVtYS5fem9kLmRlZixcbiAgICBzaGFwZSxcbiAgICAvLyBvcHRpb25hbDogW10sXG4gICAgY2hlY2tzOiBbXVxuICB9KTtcbn1cbmZ1bmN0aW9uIGFib3J0ZWQoeCwgc3RhcnRJbmRleCA9IDApIHtcbiAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXg7IGkgPCB4Lmlzc3Vlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmICh4Lmlzc3Vlc1tpXT8uY29udGludWUgIT09IHRydWUpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBwcmVmaXhJc3N1ZXMocGF0aCwgaXNzdWVzKSB7XG4gIHJldHVybiBpc3N1ZXMubWFwKChpc3MpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgKF9hID0gaXNzKS5wYXRoID8/IChfYS5wYXRoID0gW10pO1xuICAgIGlzcy5wYXRoLnVuc2hpZnQocGF0aCk7XG4gICAgcmV0dXJuIGlzcztcbiAgfSk7XG59XG5mdW5jdGlvbiB1bndyYXBNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiID8gbWVzc2FnZSA6IG1lc3NhZ2U/Lm1lc3NhZ2U7XG59XG5mdW5jdGlvbiBmaW5hbGl6ZUlzc3VlKGlzcywgY3R4LCBjb25maWcyKSB7XG4gIGNvbnN0IGZ1bGwgPSB7IC4uLmlzcywgcGF0aDogaXNzLnBhdGggPz8gW10gfTtcbiAgaWYgKCFpc3MubWVzc2FnZSkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSB1bndyYXBNZXNzYWdlKGlzcy5pbnN0Py5fem9kLmRlZj8uZXJyb3I/Lihpc3MpKSA/PyB1bndyYXBNZXNzYWdlKGN0eD8uZXJyb3I/Lihpc3MpKSA/PyB1bndyYXBNZXNzYWdlKGNvbmZpZzIuY3VzdG9tRXJyb3I/Lihpc3MpKSA/PyB1bndyYXBNZXNzYWdlKGNvbmZpZzIubG9jYWxlRXJyb3I/Lihpc3MpKSA/PyBcIkludmFsaWQgaW5wdXRcIjtcbiAgICBmdWxsLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB9XG4gIGRlbGV0ZSBmdWxsLmluc3Q7XG4gIGRlbGV0ZSBmdWxsLmNvbnRpbnVlO1xuICBpZiAoIWN0eD8ucmVwb3J0SW5wdXQpIHtcbiAgICBkZWxldGUgZnVsbC5pbnB1dDtcbiAgfVxuICByZXR1cm4gZnVsbDtcbn1cbmZ1bmN0aW9uIGdldFNpemFibGVPcmlnaW4oaW5wdXQpIHtcbiAgaWYgKGlucHV0IGluc3RhbmNlb2YgU2V0KVxuICAgIHJldHVybiBcInNldFwiO1xuICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBNYXApXG4gICAgcmV0dXJuIFwibWFwXCI7XG4gIGlmIChpbnB1dCBpbnN0YW5jZW9mIEZpbGUpXG4gICAgcmV0dXJuIFwiZmlsZVwiO1xuICByZXR1cm4gXCJ1bmtub3duXCI7XG59XG5mdW5jdGlvbiBnZXRMZW5ndGhhYmxlT3JpZ2luKGlucHV0KSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSlcbiAgICByZXR1cm4gXCJhcnJheVwiO1xuICBpZiAodHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiKVxuICAgIHJldHVybiBcInN0cmluZ1wiO1xuICByZXR1cm4gXCJ1bmtub3duXCI7XG59XG5mdW5jdGlvbiBpc3N1ZSguLi5hcmdzKSB7XG4gIGNvbnN0IFtpc3MsIGlucHV0LCBpbnN0XSA9IGFyZ3M7XG4gIGlmICh0eXBlb2YgaXNzID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1lc3NhZ2U6IGlzcyxcbiAgICAgIGNvZGU6IFwiY3VzdG9tXCIsXG4gICAgICBpbnB1dCxcbiAgICAgIGluc3RcbiAgICB9O1xuICB9XG4gIHJldHVybiB7IC4uLmlzcyB9O1xufVxuZnVuY3Rpb24gY2xlYW5FbnVtKG9iaikge1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMob2JqKS5maWx0ZXIoKFtrLCBfXSkgPT4ge1xuICAgIHJldHVybiBOdW1iZXIuaXNOYU4oTnVtYmVyLnBhcnNlSW50KGssIDEwKSk7XG4gIH0pLm1hcCgoZWwpID0+IGVsWzFdKTtcbn1cbnZhciBDbGFzcyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoLi4uX2FyZ3MpIHtcbiAgfVxufTtcblxuLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3pvZEA0LjAuMS9ub2RlX21vZHVsZXMvem9kL3Y0L2NvcmUvZXJyb3JzLmpzXG52YXIgaW5pdGlhbGl6ZXIgPSAoaW5zdCwgZGVmKSA9PiB7XG4gIGluc3QubmFtZSA9IFwiJFpvZEVycm9yXCI7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbnN0LCBcIl96b2RcIiwge1xuICAgIHZhbHVlOiBpbnN0Ll96b2QsXG4gICAgZW51bWVyYWJsZTogZmFsc2VcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbnN0LCBcImlzc3Vlc1wiLCB7XG4gICAgdmFsdWU6IGRlZixcbiAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGluc3QsIFwibWVzc2FnZVwiLCB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRlZiwganNvblN0cmluZ2lmeVJlcGxhY2VyLCAyKTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAvLyBjb25maWd1cmFibGU6IGZhbHNlLFxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGluc3QsIFwidG9TdHJpbmdcIiwge1xuICAgIHZhbHVlOiAoKSA9PiBpbnN0Lm1lc3NhZ2UsXG4gICAgZW51bWVyYWJsZTogZmFsc2VcbiAgfSk7XG59O1xudmFyICRab2RFcnJvciA9ICRjb25zdHJ1Y3RvcihcIiRab2RFcnJvclwiLCBpbml0aWFsaXplcik7XG52YXIgJFpvZFJlYWxFcnJvciA9ICRjb25zdHJ1Y3RvcihcIiRab2RFcnJvclwiLCBpbml0aWFsaXplciwgeyBQYXJlbnQ6IEVycm9yIH0pO1xuZnVuY3Rpb24gZmxhdHRlbkVycm9yKGVycm9yLCBtYXBwZXIgPSAoaXNzdWUyKSA9PiBpc3N1ZTIubWVzc2FnZSkge1xuICBjb25zdCBmaWVsZEVycm9ycyA9IHt9O1xuICBjb25zdCBmb3JtRXJyb3JzID0gW107XG4gIGZvciAoY29uc3Qgc3ViIG9mIGVycm9yLmlzc3Vlcykge1xuICAgIGlmIChzdWIucGF0aC5sZW5ndGggPiAwKSB7XG4gICAgICBmaWVsZEVycm9yc1tzdWIucGF0aFswXV0gPSBmaWVsZEVycm9yc1tzdWIucGF0aFswXV0gfHwgW107XG4gICAgICBmaWVsZEVycm9yc1tzdWIucGF0aFswXV0ucHVzaChtYXBwZXIoc3ViKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvcm1FcnJvcnMucHVzaChtYXBwZXIoc3ViKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7IGZvcm1FcnJvcnMsIGZpZWxkRXJyb3JzIH07XG59XG5mdW5jdGlvbiBmb3JtYXRFcnJvcihlcnJvciwgX21hcHBlcikge1xuICBjb25zdCBtYXBwZXIgPSBfbWFwcGVyIHx8IGZ1bmN0aW9uKGlzc3VlMikge1xuICAgIHJldHVybiBpc3N1ZTIubWVzc2FnZTtcbiAgfTtcbiAgY29uc3QgZmllbGRFcnJvcnMgPSB7IF9lcnJvcnM6IFtdIH07XG4gIGNvbnN0IHByb2Nlc3NFcnJvciA9IChlcnJvcjIpID0+IHtcbiAgICBmb3IgKGNvbnN0IGlzc3VlMiBvZiBlcnJvcjIuaXNzdWVzKSB7XG4gICAgICBpZiAoaXNzdWUyLmNvZGUgPT09IFwiaW52YWxpZF91bmlvblwiICYmIGlzc3VlMi5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIGlzc3VlMi5lcnJvcnMubWFwKChpc3N1ZXMpID0+IHByb2Nlc3NFcnJvcih7IGlzc3VlcyB9KSk7XG4gICAgICB9IGVsc2UgaWYgKGlzc3VlMi5jb2RlID09PSBcImludmFsaWRfa2V5XCIpIHtcbiAgICAgICAgcHJvY2Vzc0Vycm9yKHsgaXNzdWVzOiBpc3N1ZTIuaXNzdWVzIH0pO1xuICAgICAgfSBlbHNlIGlmIChpc3N1ZTIuY29kZSA9PT0gXCJpbnZhbGlkX2VsZW1lbnRcIikge1xuICAgICAgICBwcm9jZXNzRXJyb3IoeyBpc3N1ZXM6IGlzc3VlMi5pc3N1ZXMgfSk7XG4gICAgICB9IGVsc2UgaWYgKGlzc3VlMi5wYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBmaWVsZEVycm9ycy5fZXJyb3JzLnB1c2gobWFwcGVyKGlzc3VlMikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGN1cnIgPSBmaWVsZEVycm9ycztcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IGlzc3VlMi5wYXRoLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IGVsID0gaXNzdWUyLnBhdGhbaV07XG4gICAgICAgICAgY29uc3QgdGVybWluYWwgPSBpID09PSBpc3N1ZTIucGF0aC5sZW5ndGggLSAxO1xuICAgICAgICAgIGlmICghdGVybWluYWwpIHtcbiAgICAgICAgICAgIGN1cnJbZWxdID0gY3VycltlbF0gfHwgeyBfZXJyb3JzOiBbXSB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXJyW2VsXSA9IGN1cnJbZWxdIHx8IHsgX2Vycm9yczogW10gfTtcbiAgICAgICAgICAgIGN1cnJbZWxdLl9lcnJvcnMucHVzaChtYXBwZXIoaXNzdWUyKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN1cnIgPSBjdXJyW2VsXTtcbiAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHByb2Nlc3NFcnJvcihlcnJvcik7XG4gIHJldHVybiBmaWVsZEVycm9ycztcbn1cblxuLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3pvZEA0LjAuMS9ub2RlX21vZHVsZXMvem9kL3Y0L2NvcmUvcGFyc2UuanNcbnZhciBfcGFyc2UgPSAoX0VycikgPT4gKHNjaGVtYSwgdmFsdWUsIF9jdHgsIF9wYXJhbXMpID0+IHtcbiAgY29uc3QgY3R4ID0gX2N0eCA/IE9iamVjdC5hc3NpZ24oX2N0eCwgeyBhc3luYzogZmFsc2UgfSkgOiB7IGFzeW5jOiBmYWxzZSB9O1xuICBjb25zdCByZXN1bHQgPSBzY2hlbWEuX3pvZC5ydW4oeyB2YWx1ZSwgaXNzdWVzOiBbXSB9LCBjdHgpO1xuICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgIHRocm93IG5ldyAkWm9kQXN5bmNFcnJvcigpO1xuICB9XG4gIGlmIChyZXN1bHQuaXNzdWVzLmxlbmd0aCkge1xuICAgIGNvbnN0IGUgPSBuZXcgKF9wYXJhbXM/LkVyciA/PyBfRXJyKShyZXN1bHQuaXNzdWVzLm1hcCgoaXNzKSA9PiBmaW5hbGl6ZUlzc3VlKGlzcywgY3R4LCBjb25maWcoKSkpKTtcbiAgICBjYXB0dXJlU3RhY2tUcmFjZShlLCBfcGFyYW1zPy5jYWxsZWUpO1xuICAgIHRocm93IGU7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbn07XG52YXIgX3BhcnNlQXN5bmMgPSAoX0VycikgPT4gYXN5bmMgKHNjaGVtYSwgdmFsdWUsIF9jdHgsIHBhcmFtcykgPT4ge1xuICBjb25zdCBjdHggPSBfY3R4ID8gT2JqZWN0LmFzc2lnbihfY3R4LCB7IGFzeW5jOiB0cnVlIH0pIDogeyBhc3luYzogdHJ1ZSB9O1xuICBsZXQgcmVzdWx0ID0gc2NoZW1hLl96b2QucnVuKHsgdmFsdWUsIGlzc3VlczogW10gfSwgY3R4KTtcbiAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpXG4gICAgcmVzdWx0ID0gYXdhaXQgcmVzdWx0O1xuICBpZiAocmVzdWx0Lmlzc3Vlcy5sZW5ndGgpIHtcbiAgICBjb25zdCBlID0gbmV3IChwYXJhbXM/LkVyciA/PyBfRXJyKShyZXN1bHQuaXNzdWVzLm1hcCgoaXNzKSA9PiBmaW5hbGl6ZUlzc3VlKGlzcywgY3R4LCBjb25maWcoKSkpKTtcbiAgICBjYXB0dXJlU3RhY2tUcmFjZShlLCBwYXJhbXM/LmNhbGxlZSk7XG4gICAgdGhyb3cgZTtcbiAgfVxuICByZXR1cm4gcmVzdWx0LnZhbHVlO1xufTtcbnZhciBfc2FmZVBhcnNlID0gKF9FcnIpID0+IChzY2hlbWEsIHZhbHVlLCBfY3R4KSA9PiB7XG4gIGNvbnN0IGN0eCA9IF9jdHggPyB7IC4uLl9jdHgsIGFzeW5jOiBmYWxzZSB9IDogeyBhc3luYzogZmFsc2UgfTtcbiAgY29uc3QgcmVzdWx0ID0gc2NoZW1hLl96b2QucnVuKHsgdmFsdWUsIGlzc3VlczogW10gfSwgY3R4KTtcbiAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICB0aHJvdyBuZXcgJFpvZEFzeW5jRXJyb3IoKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0Lmlzc3Vlcy5sZW5ndGggPyB7XG4gICAgc3VjY2VzczogZmFsc2UsXG4gICAgZXJyb3I6IG5ldyAoX0VyciA/PyAkWm9kRXJyb3IpKHJlc3VsdC5pc3N1ZXMubWFwKChpc3MpID0+IGZpbmFsaXplSXNzdWUoaXNzLCBjdHgsIGNvbmZpZygpKSkpXG4gIH0gOiB7IHN1Y2Nlc3M6IHRydWUsIGRhdGE6IHJlc3VsdC52YWx1ZSB9O1xufTtcbnZhciBzYWZlUGFyc2UgPSAvKiBAX19QVVJFX18gKi8gX3NhZmVQYXJzZSgkWm9kUmVhbEVycm9yKTtcbnZhciBfc2FmZVBhcnNlQXN5bmMgPSAoX0VycikgPT4gYXN5bmMgKHNjaGVtYSwgdmFsdWUsIF9jdHgpID0+IHtcbiAgY29uc3QgY3R4ID0gX2N0eCA/IE9iamVjdC5hc3NpZ24oX2N0eCwgeyBhc3luYzogdHJ1ZSB9KSA6IHsgYXN5bmM6IHRydWUgfTtcbiAgbGV0IHJlc3VsdCA9IHNjaGVtYS5fem9kLnJ1bih7IHZhbHVlLCBpc3N1ZXM6IFtdIH0sIGN0eCk7XG4gIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKVxuICAgIHJlc3VsdCA9IGF3YWl0IHJlc3VsdDtcbiAgcmV0dXJuIHJlc3VsdC5pc3N1ZXMubGVuZ3RoID8ge1xuICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgIGVycm9yOiBuZXcgX0VycihyZXN1bHQuaXNzdWVzLm1hcCgoaXNzKSA9PiBmaW5hbGl6ZUlzc3VlKGlzcywgY3R4LCBjb25maWcoKSkpKVxuICB9IDogeyBzdWNjZXNzOiB0cnVlLCBkYXRhOiByZXN1bHQudmFsdWUgfTtcbn07XG52YXIgc2FmZVBhcnNlQXN5bmMgPSAvKiBAX19QVVJFX18gKi8gX3NhZmVQYXJzZUFzeW5jKCRab2RSZWFsRXJyb3IpO1xuXG4vLyBub2RlX21vZHVsZXMvLnBucG0vem9kQDQuMC4xL25vZGVfbW9kdWxlcy96b2QvdjQvY29yZS9jaGVja3MuanNcbnZhciAkWm9kQ2hlY2sgPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiJFpvZENoZWNrXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgdmFyIF9hO1xuICBpbnN0Ll96b2QgPz8gKGluc3QuX3pvZCA9IHt9KTtcbiAgaW5zdC5fem9kLmRlZiA9IGRlZjtcbiAgKF9hID0gaW5zdC5fem9kKS5vbmF0dGFjaCA/PyAoX2Eub25hdHRhY2ggPSBbXSk7XG59KTtcbnZhciAkWm9kQ2hlY2tNYXhMZW5ndGggPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiJFpvZENoZWNrTWF4TGVuZ3RoXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgdmFyIF9hO1xuICAkWm9kQ2hlY2suaW5pdChpbnN0LCBkZWYpO1xuICAoX2EgPSBpbnN0Ll96b2QuZGVmKS53aGVuID8/IChfYS53aGVuID0gKHBheWxvYWQpID0+IHtcbiAgICBjb25zdCB2YWwgPSBwYXlsb2FkLnZhbHVlO1xuICAgIHJldHVybiAhbnVsbGlzaCh2YWwpICYmIHZhbC5sZW5ndGggIT09IHZvaWQgMDtcbiAgfSk7XG4gIGluc3QuX3pvZC5vbmF0dGFjaC5wdXNoKChpbnN0MikgPT4ge1xuICAgIGNvbnN0IGN1cnIgPSBpbnN0Mi5fem9kLmJhZy5tYXhpbXVtID8/IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBpZiAoZGVmLm1heGltdW0gPCBjdXJyKVxuICAgICAgaW5zdDIuX3pvZC5iYWcubWF4aW11bSA9IGRlZi5tYXhpbXVtO1xuICB9KTtcbiAgaW5zdC5fem9kLmNoZWNrID0gKHBheWxvYWQpID0+IHtcbiAgICBjb25zdCBpbnB1dCA9IHBheWxvYWQudmFsdWU7XG4gICAgY29uc3QgbGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPD0gZGVmLm1heGltdW0pXG4gICAgICByZXR1cm47XG4gICAgY29uc3Qgb3JpZ2luID0gZ2V0TGVuZ3RoYWJsZU9yaWdpbihpbnB1dCk7XG4gICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICBvcmlnaW4sXG4gICAgICBjb2RlOiBcInRvb19iaWdcIixcbiAgICAgIG1heGltdW06IGRlZi5tYXhpbXVtLFxuICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgaW5wdXQsXG4gICAgICBpbnN0LFxuICAgICAgY29udGludWU6ICFkZWYuYWJvcnRcbiAgICB9KTtcbiAgfTtcbn0pO1xudmFyICRab2RDaGVja01pbkxlbmd0aCA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCIkWm9kQ2hlY2tNaW5MZW5ndGhcIiwgKGluc3QsIGRlZikgPT4ge1xuICB2YXIgX2E7XG4gICRab2RDaGVjay5pbml0KGluc3QsIGRlZik7XG4gIChfYSA9IGluc3QuX3pvZC5kZWYpLndoZW4gPz8gKF9hLndoZW4gPSAocGF5bG9hZCkgPT4ge1xuICAgIGNvbnN0IHZhbCA9IHBheWxvYWQudmFsdWU7XG4gICAgcmV0dXJuICFudWxsaXNoKHZhbCkgJiYgdmFsLmxlbmd0aCAhPT0gdm9pZCAwO1xuICB9KTtcbiAgaW5zdC5fem9kLm9uYXR0YWNoLnB1c2goKGluc3QyKSA9PiB7XG4gICAgY29uc3QgY3VyciA9IGluc3QyLl96b2QuYmFnLm1pbmltdW0gPz8gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgIGlmIChkZWYubWluaW11bSA+IGN1cnIpXG4gICAgICBpbnN0Mi5fem9kLmJhZy5taW5pbXVtID0gZGVmLm1pbmltdW07XG4gIH0pO1xuICBpbnN0Ll96b2QuY2hlY2sgPSAocGF5bG9hZCkgPT4ge1xuICAgIGNvbnN0IGlucHV0ID0gcGF5bG9hZC52YWx1ZTtcbiAgICBjb25zdCBsZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA+PSBkZWYubWluaW11bSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBvcmlnaW4gPSBnZXRMZW5ndGhhYmxlT3JpZ2luKGlucHV0KTtcbiAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgIG9yaWdpbixcbiAgICAgIGNvZGU6IFwidG9vX3NtYWxsXCIsXG4gICAgICBtaW5pbXVtOiBkZWYubWluaW11bSxcbiAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgIGlucHV0LFxuICAgICAgaW5zdCxcbiAgICAgIGNvbnRpbnVlOiAhZGVmLmFib3J0XG4gICAgfSk7XG4gIH07XG59KTtcbnZhciAkWm9kQ2hlY2tMZW5ndGhFcXVhbHMgPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiJFpvZENoZWNrTGVuZ3RoRXF1YWxzXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgdmFyIF9hO1xuICAkWm9kQ2hlY2suaW5pdChpbnN0LCBkZWYpO1xuICAoX2EgPSBpbnN0Ll96b2QuZGVmKS53aGVuID8/IChfYS53aGVuID0gKHBheWxvYWQpID0+IHtcbiAgICBjb25zdCB2YWwgPSBwYXlsb2FkLnZhbHVlO1xuICAgIHJldHVybiAhbnVsbGlzaCh2YWwpICYmIHZhbC5sZW5ndGggIT09IHZvaWQgMDtcbiAgfSk7XG4gIGluc3QuX3pvZC5vbmF0dGFjaC5wdXNoKChpbnN0MikgPT4ge1xuICAgIGNvbnN0IGJhZyA9IGluc3QyLl96b2QuYmFnO1xuICAgIGJhZy5taW5pbXVtID0gZGVmLmxlbmd0aDtcbiAgICBiYWcubWF4aW11bSA9IGRlZi5sZW5ndGg7XG4gICAgYmFnLmxlbmd0aCA9IGRlZi5sZW5ndGg7XG4gIH0pO1xuICBpbnN0Ll96b2QuY2hlY2sgPSAocGF5bG9hZCkgPT4ge1xuICAgIGNvbnN0IGlucHV0ID0gcGF5bG9hZC52YWx1ZTtcbiAgICBjb25zdCBsZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA9PT0gZGVmLmxlbmd0aClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBvcmlnaW4gPSBnZXRMZW5ndGhhYmxlT3JpZ2luKGlucHV0KTtcbiAgICBjb25zdCB0b29CaWcgPSBsZW5ndGggPiBkZWYubGVuZ3RoO1xuICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgb3JpZ2luLFxuICAgICAgLi4udG9vQmlnID8geyBjb2RlOiBcInRvb19iaWdcIiwgbWF4aW11bTogZGVmLmxlbmd0aCB9IDogeyBjb2RlOiBcInRvb19zbWFsbFwiLCBtaW5pbXVtOiBkZWYubGVuZ3RoIH0sXG4gICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICBleGFjdDogdHJ1ZSxcbiAgICAgIGlucHV0OiBwYXlsb2FkLnZhbHVlLFxuICAgICAgaW5zdCxcbiAgICAgIGNvbnRpbnVlOiAhZGVmLmFib3J0XG4gICAgfSk7XG4gIH07XG59KTtcbnZhciAkWm9kQ2hlY2tPdmVyd3JpdGUgPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiJFpvZENoZWNrT3ZlcndyaXRlXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgJFpvZENoZWNrLmluaXQoaW5zdCwgZGVmKTtcbiAgaW5zdC5fem9kLmNoZWNrID0gKHBheWxvYWQpID0+IHtcbiAgICBwYXlsb2FkLnZhbHVlID0gZGVmLnR4KHBheWxvYWQudmFsdWUpO1xuICB9O1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy8ucG5wbS96b2RANC4wLjEvbm9kZV9tb2R1bGVzL3pvZC92NC9jb3JlL2RvYy5qc1xudmFyIERvYyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoYXJncyA9IFtdKSB7XG4gICAgdGhpcy5jb250ZW50ID0gW107XG4gICAgdGhpcy5pbmRlbnQgPSAwO1xuICAgIGlmICh0aGlzKVxuICAgICAgdGhpcy5hcmdzID0gYXJncztcbiAgfVxuICBpbmRlbnRlZChmbikge1xuICAgIHRoaXMuaW5kZW50ICs9IDE7XG4gICAgZm4odGhpcyk7XG4gICAgdGhpcy5pbmRlbnQgLT0gMTtcbiAgfVxuICB3cml0ZShhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBhcmcodGhpcywgeyBleGVjdXRpb246IFwic3luY1wiIH0pO1xuICAgICAgYXJnKHRoaXMsIHsgZXhlY3V0aW9uOiBcImFzeW5jXCIgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvbnRlbnQgPSBhcmc7XG4gICAgY29uc3QgbGluZXMgPSBjb250ZW50LnNwbGl0KFwiXFxuXCIpLmZpbHRlcigoeCkgPT4geCk7XG4gICAgY29uc3QgbWluSW5kZW50ID0gTWF0aC5taW4oLi4ubGluZXMubWFwKCh4KSA9PiB4Lmxlbmd0aCAtIHgudHJpbVN0YXJ0KCkubGVuZ3RoKSk7XG4gICAgY29uc3QgZGVkZW50ZWQgPSBsaW5lcy5tYXAoKHgpID0+IHguc2xpY2UobWluSW5kZW50KSkubWFwKCh4KSA9PiBcIiBcIi5yZXBlYXQodGhpcy5pbmRlbnQgKiAyKSArIHgpO1xuICAgIGZvciAoY29uc3QgbGluZSBvZiBkZWRlbnRlZCkge1xuICAgICAgdGhpcy5jb250ZW50LnB1c2gobGluZSk7XG4gICAgfVxuICB9XG4gIGNvbXBpbGUoKSB7XG4gICAgY29uc3QgRiA9IEZ1bmN0aW9uO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzPy5hcmdzO1xuICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzPy5jb250ZW50ID8/IFtgYF07XG4gICAgY29uc3QgbGluZXMgPSBbLi4uY29udGVudC5tYXAoKHgpID0+IGAgICR7eH1gKV07XG4gICAgcmV0dXJuIG5ldyBGKC4uLmFyZ3MsIGxpbmVzLmpvaW4oXCJcXG5cIikpO1xuICB9XG59O1xuXG4vLyBub2RlX21vZHVsZXMvLnBucG0vem9kQDQuMC4xL25vZGVfbW9kdWxlcy96b2QvdjQvY29yZS92ZXJzaW9ucy5qc1xudmFyIHZlcnNpb24gPSB7XG4gIG1ham9yOiA0LFxuICBtaW5vcjogMCxcbiAgcGF0Y2g6IDBcbn07XG5cbi8vIG5vZGVfbW9kdWxlcy8ucG5wbS96b2RANC4wLjEvbm9kZV9tb2R1bGVzL3pvZC92NC9jb3JlL3NjaGVtYXMuanNcbnZhciAkWm9kVHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCIkWm9kVHlwZVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gIHZhciBfYTtcbiAgaW5zdCA/PyAoaW5zdCA9IHt9KTtcbiAgaW5zdC5fem9kLmRlZiA9IGRlZjtcbiAgaW5zdC5fem9kLmJhZyA9IGluc3QuX3pvZC5iYWcgfHwge307XG4gIGluc3QuX3pvZC52ZXJzaW9uID0gdmVyc2lvbjtcbiAgY29uc3QgY2hlY2tzID0gWy4uLmluc3QuX3pvZC5kZWYuY2hlY2tzID8/IFtdXTtcbiAgaWYgKGluc3QuX3pvZC50cmFpdHMuaGFzKFwiJFpvZENoZWNrXCIpKSB7XG4gICAgY2hlY2tzLnVuc2hpZnQoaW5zdCk7XG4gIH1cbiAgZm9yIChjb25zdCBjaCBvZiBjaGVja3MpIHtcbiAgICBmb3IgKGNvbnN0IGZuIG9mIGNoLl96b2Qub25hdHRhY2gpIHtcbiAgICAgIGZuKGluc3QpO1xuICAgIH1cbiAgfVxuICBpZiAoY2hlY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgIChfYSA9IGluc3QuX3pvZCkuZGVmZXJyZWQgPz8gKF9hLmRlZmVycmVkID0gW10pO1xuICAgIGluc3QuX3pvZC5kZWZlcnJlZD8ucHVzaCgoKSA9PiB7XG4gICAgICBpbnN0Ll96b2QucnVuID0gaW5zdC5fem9kLnBhcnNlO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHJ1bkNoZWNrcyA9IChwYXlsb2FkLCBjaGVja3MyLCBjdHgpID0+IHtcbiAgICAgIGxldCBpc0Fib3J0ZWQgPSBhYm9ydGVkKHBheWxvYWQpO1xuICAgICAgbGV0IGFzeW5jUmVzdWx0O1xuICAgICAgZm9yIChjb25zdCBjaCBvZiBjaGVja3MyKSB7XG4gICAgICAgIGlmIChjaC5fem9kLmRlZi53aGVuKSB7XG4gICAgICAgICAgY29uc3Qgc2hvdWxkUnVuID0gY2guX3pvZC5kZWYud2hlbihwYXlsb2FkKTtcbiAgICAgICAgICBpZiAoIXNob3VsZFJ1bilcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQWJvcnRlZCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJMZW4gPSBwYXlsb2FkLmlzc3Vlcy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IF8gPSBjaC5fem9kLmNoZWNrKHBheWxvYWQpO1xuICAgICAgICBpZiAoXyBpbnN0YW5jZW9mIFByb21pc2UgJiYgY3R4Py5hc3luYyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgJFpvZEFzeW5jRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXN5bmNSZXN1bHQgfHwgXyBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICBhc3luY1Jlc3VsdCA9IChhc3luY1Jlc3VsdCA/PyBQcm9taXNlLnJlc29sdmUoKSkudGhlbihhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCBfO1xuICAgICAgICAgICAgY29uc3QgbmV4dExlbiA9IHBheWxvYWQuaXNzdWVzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChuZXh0TGVuID09PSBjdXJyTGVuKVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoIWlzQWJvcnRlZClcbiAgICAgICAgICAgICAgaXNBYm9ydGVkID0gYWJvcnRlZChwYXlsb2FkLCBjdXJyTGVuKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBuZXh0TGVuID0gcGF5bG9hZC5pc3N1ZXMubGVuZ3RoO1xuICAgICAgICAgIGlmIChuZXh0TGVuID09PSBjdXJyTGVuKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgaWYgKCFpc0Fib3J0ZWQpXG4gICAgICAgICAgICBpc0Fib3J0ZWQgPSBhYm9ydGVkKHBheWxvYWQsIGN1cnJMZW4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYXN5bmNSZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIGFzeW5jUmVzdWx0LnRoZW4oKCkgPT4ge1xuICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH07XG4gICAgaW5zdC5fem9kLnJ1biA9IChwYXlsb2FkLCBjdHgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGluc3QuX3pvZC5wYXJzZShwYXlsb2FkLCBjdHgpO1xuICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgaWYgKGN0eC5hc3luYyA9PT0gZmFsc2UpXG4gICAgICAgICAgdGhyb3cgbmV3ICRab2RBc3luY0Vycm9yKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQudGhlbigocmVzdWx0MikgPT4gcnVuQ2hlY2tzKHJlc3VsdDIsIGNoZWNrcywgY3R4KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcnVuQ2hlY2tzKHJlc3VsdCwgY2hlY2tzLCBjdHgpO1xuICAgIH07XG4gIH1cbiAgaW5zdFtcIn5zdGFuZGFyZFwiXSA9IHtcbiAgICB2YWxpZGF0ZTogKHZhbHVlKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByID0gc2FmZVBhcnNlKGluc3QsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHIuc3VjY2VzcyA/IHsgdmFsdWU6IHIuZGF0YSB9IDogeyBpc3N1ZXM6IHIuZXJyb3I/Lmlzc3VlcyB9O1xuICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICByZXR1cm4gc2FmZVBhcnNlQXN5bmMoaW5zdCwgdmFsdWUpLnRoZW4oKHIpID0+IHIuc3VjY2VzcyA/IHsgdmFsdWU6IHIuZGF0YSB9IDogeyBpc3N1ZXM6IHIuZXJyb3I/Lmlzc3VlcyB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHZlbmRvcjogXCJ6b2RcIixcbiAgICB2ZXJzaW9uOiAxXG4gIH07XG59KTtcbnZhciAkWm9kVW5rbm93biA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCIkWm9kVW5rbm93blwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQpID0+IHBheWxvYWQ7XG59KTtcbnZhciAkWm9kTmV2ZXIgPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiJFpvZE5ldmVyXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgX2N0eCkgPT4ge1xuICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgZXhwZWN0ZWQ6IFwibmV2ZXJcIixcbiAgICAgIGNvZGU6IFwiaW52YWxpZF90eXBlXCIsXG4gICAgICBpbnB1dDogcGF5bG9hZC52YWx1ZSxcbiAgICAgIGluc3RcbiAgICB9KTtcbiAgICByZXR1cm4gcGF5bG9hZDtcbiAgfTtcbn0pO1xuZnVuY3Rpb24gaGFuZGxlQXJyYXlSZXN1bHQocmVzdWx0LCBmaW5hbCwgaW5kZXgpIHtcbiAgaWYgKHJlc3VsdC5pc3N1ZXMubGVuZ3RoKSB7XG4gICAgZmluYWwuaXNzdWVzLnB1c2goLi4ucHJlZml4SXNzdWVzKGluZGV4LCByZXN1bHQuaXNzdWVzKSk7XG4gIH1cbiAgZmluYWwudmFsdWVbaW5kZXhdID0gcmVzdWx0LnZhbHVlO1xufVxudmFyICRab2RBcnJheSA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCIkWm9kQXJyYXlcIiwgKGluc3QsIGRlZikgPT4ge1xuICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBjdHgpID0+IHtcbiAgICBjb25zdCBpbnB1dCA9IHBheWxvYWQudmFsdWU7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgIGV4cGVjdGVkOiBcImFycmF5XCIsXG4gICAgICAgIGNvZGU6IFwiaW52YWxpZF90eXBlXCIsXG4gICAgICAgIGlucHV0LFxuICAgICAgICBpbnN0XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH1cbiAgICBwYXlsb2FkLnZhbHVlID0gQXJyYXkoaW5wdXQubGVuZ3RoKTtcbiAgICBjb25zdCBwcm9tcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSBpbnB1dFtpXTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGRlZi5lbGVtZW50Ll96b2QucnVuKHtcbiAgICAgICAgdmFsdWU6IGl0ZW0sXG4gICAgICAgIGlzc3VlczogW11cbiAgICAgIH0sIGN0eCk7XG4gICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICBwcm9tcy5wdXNoKHJlc3VsdC50aGVuKChyZXN1bHQyKSA9PiBoYW5kbGVBcnJheVJlc3VsdChyZXN1bHQyLCBwYXlsb2FkLCBpKSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFuZGxlQXJyYXlSZXN1bHQocmVzdWx0LCBwYXlsb2FkLCBpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb21zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21zKS50aGVuKCgpID0+IHBheWxvYWQpO1xuICAgIH1cbiAgICByZXR1cm4gcGF5bG9hZDtcbiAgfTtcbn0pO1xuZnVuY3Rpb24gaGFuZGxlT2JqZWN0UmVzdWx0KHJlc3VsdCwgZmluYWwsIGtleSkge1xuICBpZiAocmVzdWx0Lmlzc3Vlcy5sZW5ndGgpIHtcbiAgICBmaW5hbC5pc3N1ZXMucHVzaCguLi5wcmVmaXhJc3N1ZXMoa2V5LCByZXN1bHQuaXNzdWVzKSk7XG4gIH1cbiAgZmluYWwudmFsdWVba2V5XSA9IHJlc3VsdC52YWx1ZTtcbn1cbmZ1bmN0aW9uIGhhbmRsZU9wdGlvbmFsT2JqZWN0UmVzdWx0KHJlc3VsdCwgZmluYWwsIGtleSwgaW5wdXQpIHtcbiAgaWYgKHJlc3VsdC5pc3N1ZXMubGVuZ3RoKSB7XG4gICAgaWYgKGlucHV0W2tleV0gPT09IHZvaWQgMCkge1xuICAgICAgaWYgKGtleSBpbiBpbnB1dCkge1xuICAgICAgICBmaW5hbC52YWx1ZVtrZXldID0gdm9pZCAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmluYWwudmFsdWVba2V5XSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZmluYWwuaXNzdWVzLnB1c2goLi4ucHJlZml4SXNzdWVzKGtleSwgcmVzdWx0Lmlzc3VlcykpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChyZXN1bHQudmFsdWUgPT09IHZvaWQgMCkge1xuICAgIGlmIChrZXkgaW4gaW5wdXQpXG4gICAgICBmaW5hbC52YWx1ZVtrZXldID0gdm9pZCAwO1xuICB9IGVsc2Uge1xuICAgIGZpbmFsLnZhbHVlW2tleV0gPSByZXN1bHQudmFsdWU7XG4gIH1cbn1cbnZhciAkWm9kT2JqZWN0ID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIiRab2RPYmplY3RcIiwgKGluc3QsIGRlZikgPT4ge1xuICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gIGNvbnN0IF9ub3JtYWxpemVkID0gY2FjaGVkKCgpID0+IHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZGVmLnNoYXBlKTtcbiAgICBmb3IgKGNvbnN0IGsgb2Yga2V5cykge1xuICAgICAgaWYgKCEoZGVmLnNoYXBlW2tdIGluc3RhbmNlb2YgJFpvZFR5cGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBlbGVtZW50IGF0IGtleSBcIiR7a31cIjogZXhwZWN0ZWQgYSBab2Qgc2NoZW1hYCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG9rZXlzID0gb3B0aW9uYWxLZXlzKGRlZi5zaGFwZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNoYXBlOiBkZWYuc2hhcGUsXG4gICAgICBrZXlzLFxuICAgICAga2V5U2V0OiBuZXcgU2V0KGtleXMpLFxuICAgICAgbnVtS2V5czoga2V5cy5sZW5ndGgsXG4gICAgICBvcHRpb25hbEtleXM6IG5ldyBTZXQob2tleXMpXG4gICAgfTtcbiAgfSk7XG4gIGRlZmluZUxhenkoaW5zdC5fem9kLCBcInByb3BWYWx1ZXNcIiwgKCkgPT4ge1xuICAgIGNvbnN0IHNoYXBlID0gZGVmLnNoYXBlO1xuICAgIGNvbnN0IHByb3BWYWx1ZXMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzaGFwZSkge1xuICAgICAgY29uc3QgZmllbGQgPSBzaGFwZVtrZXldLl96b2Q7XG4gICAgICBpZiAoZmllbGQudmFsdWVzKSB7XG4gICAgICAgIHByb3BWYWx1ZXNba2V5XSA/PyAocHJvcFZhbHVlc1trZXldID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSk7XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBmaWVsZC52YWx1ZXMpXG4gICAgICAgICAgcHJvcFZhbHVlc1trZXldLmFkZCh2KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb3BWYWx1ZXM7XG4gIH0pO1xuICBjb25zdCBnZW5lcmF0ZUZhc3RwYXNzID0gKHNoYXBlKSA9PiB7XG4gICAgY29uc3QgZG9jID0gbmV3IERvYyhbXCJzaGFwZVwiLCBcInBheWxvYWRcIiwgXCJjdHhcIl0pO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBfbm9ybWFsaXplZC52YWx1ZTtcbiAgICBjb25zdCBwYXJzZVN0ciA9IChrZXkpID0+IHtcbiAgICAgIGNvbnN0IGsgPSBlc2Moa2V5KTtcbiAgICAgIHJldHVybiBgc2hhcGVbJHtrfV0uX3pvZC5ydW4oeyB2YWx1ZTogaW5wdXRbJHtrfV0sIGlzc3VlczogW10gfSwgY3R4KWA7XG4gICAgfTtcbiAgICBkb2Mud3JpdGUoYGNvbnN0IGlucHV0ID0gcGF5bG9hZC52YWx1ZTtgKTtcbiAgICBjb25zdCBpZHMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBsZXQgY291bnRlciA9IDA7XG4gICAgZm9yIChjb25zdCBrZXkgb2Ygbm9ybWFsaXplZC5rZXlzKSB7XG4gICAgICBpZHNba2V5XSA9IGBrZXlfJHtjb3VudGVyKyt9YDtcbiAgICB9XG4gICAgZG9jLndyaXRlKGBjb25zdCBuZXdSZXN1bHQgPSB7fWApO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIG5vcm1hbGl6ZWQua2V5cykge1xuICAgICAgaWYgKG5vcm1hbGl6ZWQub3B0aW9uYWxLZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgIGNvbnN0IGlkID0gaWRzW2tleV07XG4gICAgICAgIGRvYy53cml0ZShgY29uc3QgJHtpZH0gPSAke3BhcnNlU3RyKGtleSl9O2ApO1xuICAgICAgICBjb25zdCBrID0gZXNjKGtleSk7XG4gICAgICAgIGRvYy53cml0ZShgXG4gICAgICAgIGlmICgke2lkfS5pc3N1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKGlucHV0WyR7a31dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICgke2t9IGluIGlucHV0KSB7XG4gICAgICAgICAgICAgIG5ld1Jlc3VsdFske2t9XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMgPSBwYXlsb2FkLmlzc3Vlcy5jb25jYXQoXG4gICAgICAgICAgICAgICR7aWR9Lmlzc3Vlcy5tYXAoKGlzcykgPT4gKHtcbiAgICAgICAgICAgICAgICAuLi5pc3MsXG4gICAgICAgICAgICAgICAgcGF0aDogaXNzLnBhdGggPyBbJHtrfSwgLi4uaXNzLnBhdGhdIDogWyR7a31dLFxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCR7aWR9LnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoJHtrfSBpbiBpbnB1dCkgbmV3UmVzdWx0WyR7a31dID0gdW5kZWZpbmVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld1Jlc3VsdFske2t9XSA9ICR7aWR9LnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgaWQgPSBpZHNba2V5XTtcbiAgICAgICAgZG9jLndyaXRlKGBjb25zdCAke2lkfSA9ICR7cGFyc2VTdHIoa2V5KX07YCk7XG4gICAgICAgIGRvYy53cml0ZShgXG4gICAgICAgICAgaWYgKCR7aWR9Lmlzc3Vlcy5sZW5ndGgpIHBheWxvYWQuaXNzdWVzID0gcGF5bG9hZC5pc3N1ZXMuY29uY2F0KCR7aWR9Lmlzc3Vlcy5tYXAoaXNzID0+ICh7XG4gICAgICAgICAgICAuLi5pc3MsXG4gICAgICAgICAgICBwYXRoOiBpc3MucGF0aCA/IFske2VzYyhrZXkpfSwgLi4uaXNzLnBhdGhdIDogWyR7ZXNjKGtleSl9XVxuICAgICAgICAgIH0pKSk7YCk7XG4gICAgICAgIGRvYy53cml0ZShgbmV3UmVzdWx0WyR7ZXNjKGtleSl9XSA9ICR7aWR9LnZhbHVlYCk7XG4gICAgICB9XG4gICAgfVxuICAgIGRvYy53cml0ZShgcGF5bG9hZC52YWx1ZSA9IG5ld1Jlc3VsdDtgKTtcbiAgICBkb2Mud3JpdGUoYHJldHVybiBwYXlsb2FkO2ApO1xuICAgIGNvbnN0IGZuID0gZG9jLmNvbXBpbGUoKTtcbiAgICByZXR1cm4gKHBheWxvYWQsIGN0eCkgPT4gZm4oc2hhcGUsIHBheWxvYWQsIGN0eCk7XG4gIH07XG4gIGxldCBmYXN0cGFzcztcbiAgY29uc3QgaXNPYmplY3QyID0gaXNPYmplY3Q7XG4gIGNvbnN0IGppdCA9ICFnbG9iYWxDb25maWcuaml0bGVzcztcbiAgY29uc3QgYWxsb3dzRXZhbDIgPSBhbGxvd3NFdmFsO1xuICBjb25zdCBmYXN0RW5hYmxlZCA9IGppdCAmJiBhbGxvd3NFdmFsMi52YWx1ZTtcbiAgY29uc3QgY2F0Y2hhbGwgPSBkZWYuY2F0Y2hhbGw7XG4gIGxldCB2YWx1ZTtcbiAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIGN0eCkgPT4ge1xuICAgIHZhbHVlID8/ICh2YWx1ZSA9IF9ub3JtYWxpemVkLnZhbHVlKTtcbiAgICBjb25zdCBpbnB1dCA9IHBheWxvYWQudmFsdWU7XG4gICAgaWYgKCFpc09iamVjdDIoaW5wdXQpKSB7XG4gICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgZXhwZWN0ZWQ6IFwib2JqZWN0XCIsXG4gICAgICAgIGNvZGU6IFwiaW52YWxpZF90eXBlXCIsXG4gICAgICAgIGlucHV0LFxuICAgICAgICBpbnN0XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH1cbiAgICBjb25zdCBwcm9tcyA9IFtdO1xuICAgIGlmIChqaXQgJiYgZmFzdEVuYWJsZWQgJiYgY3R4Py5hc3luYyA9PT0gZmFsc2UgJiYgY3R4LmppdGxlc3MgIT09IHRydWUpIHtcbiAgICAgIGlmICghZmFzdHBhc3MpXG4gICAgICAgIGZhc3RwYXNzID0gZ2VuZXJhdGVGYXN0cGFzcyhkZWYuc2hhcGUpO1xuICAgICAgcGF5bG9hZCA9IGZhc3RwYXNzKHBheWxvYWQsIGN0eCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBheWxvYWQudmFsdWUgPSB7fTtcbiAgICAgIGNvbnN0IHNoYXBlID0gdmFsdWUuc2hhcGU7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiB2YWx1ZS5rZXlzKSB7XG4gICAgICAgIGNvbnN0IGVsID0gc2hhcGVba2V5XTtcbiAgICAgICAgY29uc3QgciA9IGVsLl96b2QucnVuKHsgdmFsdWU6IGlucHV0W2tleV0sIGlzc3VlczogW10gfSwgY3R4KTtcbiAgICAgICAgY29uc3QgaXNPcHRpb25hbCA9IGVsLl96b2Qub3B0aW4gPT09IFwib3B0aW9uYWxcIiAmJiBlbC5fem9kLm9wdG91dCA9PT0gXCJvcHRpb25hbFwiO1xuICAgICAgICBpZiAociBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICBwcm9tcy5wdXNoKHIudGhlbigocjIpID0+IGlzT3B0aW9uYWwgPyBoYW5kbGVPcHRpb25hbE9iamVjdFJlc3VsdChyMiwgcGF5bG9hZCwga2V5LCBpbnB1dCkgOiBoYW5kbGVPYmplY3RSZXN1bHQocjIsIHBheWxvYWQsIGtleSkpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc09wdGlvbmFsKSB7XG4gICAgICAgICAgaGFuZGxlT3B0aW9uYWxPYmplY3RSZXN1bHQociwgcGF5bG9hZCwga2V5LCBpbnB1dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGFuZGxlT2JqZWN0UmVzdWx0KHIsIHBheWxvYWQsIGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFjYXRjaGFsbCkge1xuICAgICAgcmV0dXJuIHByb21zLmxlbmd0aCA/IFByb21pc2UuYWxsKHByb21zKS50aGVuKCgpID0+IHBheWxvYWQpIDogcGF5bG9hZDtcbiAgICB9XG4gICAgY29uc3QgdW5yZWNvZ25pemVkID0gW107XG4gICAgY29uc3Qga2V5U2V0ID0gdmFsdWUua2V5U2V0O1xuICAgIGNvbnN0IF9jYXRjaGFsbCA9IGNhdGNoYWxsLl96b2Q7XG4gICAgY29uc3QgdCA9IF9jYXRjaGFsbC5kZWYudHlwZTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhpbnB1dCkpIHtcbiAgICAgIGlmIChrZXlTZXQuaGFzKGtleSkpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgaWYgKHQgPT09IFwibmV2ZXJcIikge1xuICAgICAgICB1bnJlY29nbml6ZWQucHVzaChrZXkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHIgPSBfY2F0Y2hhbGwucnVuKHsgdmFsdWU6IGlucHV0W2tleV0sIGlzc3VlczogW10gfSwgY3R4KTtcbiAgICAgIGlmIChyIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICBwcm9tcy5wdXNoKHIudGhlbigocjIpID0+IGhhbmRsZU9iamVjdFJlc3VsdChyMiwgcGF5bG9hZCwga2V5KSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFuZGxlT2JqZWN0UmVzdWx0KHIsIHBheWxvYWQsIGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh1bnJlY29nbml6ZWQubGVuZ3RoKSB7XG4gICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgY29kZTogXCJ1bnJlY29nbml6ZWRfa2V5c1wiLFxuICAgICAgICBrZXlzOiB1bnJlY29nbml6ZWQsXG4gICAgICAgIGlucHV0LFxuICAgICAgICBpbnN0XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCFwcm9tcy5sZW5ndGgpXG4gICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbXMpLnRoZW4oKCkgPT4ge1xuICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfSk7XG4gIH07XG59KTtcbmZ1bmN0aW9uIGhhbmRsZVVuaW9uUmVzdWx0cyhyZXN1bHRzLCBmaW5hbCwgaW5zdCwgY3R4KSB7XG4gIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICBpZiAocmVzdWx0Lmlzc3Vlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGZpbmFsLnZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgcmV0dXJuIGZpbmFsO1xuICAgIH1cbiAgfVxuICBmaW5hbC5pc3N1ZXMucHVzaCh7XG4gICAgY29kZTogXCJpbnZhbGlkX3VuaW9uXCIsXG4gICAgaW5wdXQ6IGZpbmFsLnZhbHVlLFxuICAgIGluc3QsXG4gICAgZXJyb3JzOiByZXN1bHRzLm1hcCgocmVzdWx0KSA9PiByZXN1bHQuaXNzdWVzLm1hcCgoaXNzKSA9PiBmaW5hbGl6ZUlzc3VlKGlzcywgY3R4LCBjb25maWcoKSkpKVxuICB9KTtcbiAgcmV0dXJuIGZpbmFsO1xufVxudmFyICRab2RVbmlvbiA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCIkWm9kVW5pb25cIiwgKGluc3QsIGRlZikgPT4ge1xuICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gIGRlZmluZUxhenkoaW5zdC5fem9kLCBcIm9wdGluXCIsICgpID0+IGRlZi5vcHRpb25zLnNvbWUoKG8pID0+IG8uX3pvZC5vcHRpbiA9PT0gXCJvcHRpb25hbFwiKSA/IFwib3B0aW9uYWxcIiA6IHZvaWQgMCk7XG4gIGRlZmluZUxhenkoaW5zdC5fem9kLCBcIm9wdG91dFwiLCAoKSA9PiBkZWYub3B0aW9ucy5zb21lKChvKSA9PiBvLl96b2Qub3B0b3V0ID09PSBcIm9wdGlvbmFsXCIpID8gXCJvcHRpb25hbFwiIDogdm9pZCAwKTtcbiAgZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwidmFsdWVzXCIsICgpID0+IHtcbiAgICBpZiAoZGVmLm9wdGlvbnMuZXZlcnkoKG8pID0+IG8uX3pvZC52YWx1ZXMpKSB7XG4gICAgICByZXR1cm4gbmV3IFNldChkZWYub3B0aW9ucy5mbGF0TWFwKChvcHRpb24pID0+IEFycmF5LmZyb20ob3B0aW9uLl96b2QudmFsdWVzKSkpO1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9KTtcbiAgZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwicGF0dGVyblwiLCAoKSA9PiB7XG4gICAgaWYgKGRlZi5vcHRpb25zLmV2ZXJ5KChvKSA9PiBvLl96b2QucGF0dGVybikpIHtcbiAgICAgIGNvbnN0IHBhdHRlcm5zID0gZGVmLm9wdGlvbnMubWFwKChvKSA9PiBvLl96b2QucGF0dGVybik7XG4gICAgICByZXR1cm4gbmV3IFJlZ0V4cChgXigke3BhdHRlcm5zLm1hcCgocCkgPT4gY2xlYW5SZWdleChwLnNvdXJjZSkpLmpvaW4oXCJ8XCIpfSkkYCk7XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH0pO1xuICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgY3R4KSA9PiB7XG4gICAgbGV0IGFzeW5jID0gZmFsc2U7XG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIGRlZi5vcHRpb25zKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBvcHRpb24uX3pvZC5ydW4oe1xuICAgICAgICB2YWx1ZTogcGF5bG9hZC52YWx1ZSxcbiAgICAgICAgaXNzdWVzOiBbXVxuICAgICAgfSwgY3R4KTtcbiAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQpO1xuICAgICAgICBhc3luYyA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocmVzdWx0Lmlzc3Vlcy5sZW5ndGggPT09IDApXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghYXN5bmMpXG4gICAgICByZXR1cm4gaGFuZGxlVW5pb25SZXN1bHRzKHJlc3VsdHMsIHBheWxvYWQsIGluc3QsIGN0eCk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHJlc3VsdHMpLnRoZW4oKHJlc3VsdHMyKSA9PiB7XG4gICAgICByZXR1cm4gaGFuZGxlVW5pb25SZXN1bHRzKHJlc3VsdHMyLCBwYXlsb2FkLCBpbnN0LCBjdHgpO1xuICAgIH0pO1xuICB9O1xufSk7XG52YXIgJFpvZEludGVyc2VjdGlvbiA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCIkWm9kSW50ZXJzZWN0aW9uXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgY3R4KSA9PiB7XG4gICAgY29uc3QgaW5wdXQgPSBwYXlsb2FkLnZhbHVlO1xuICAgIGNvbnN0IGxlZnQgPSBkZWYubGVmdC5fem9kLnJ1bih7IHZhbHVlOiBpbnB1dCwgaXNzdWVzOiBbXSB9LCBjdHgpO1xuICAgIGNvbnN0IHJpZ2h0ID0gZGVmLnJpZ2h0Ll96b2QucnVuKHsgdmFsdWU6IGlucHV0LCBpc3N1ZXM6IFtdIH0sIGN0eCk7XG4gICAgY29uc3QgYXN5bmMgPSBsZWZ0IGluc3RhbmNlb2YgUHJvbWlzZSB8fCByaWdodCBpbnN0YW5jZW9mIFByb21pc2U7XG4gICAgaWYgKGFzeW5jKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW2xlZnQsIHJpZ2h0XSkudGhlbigoW2xlZnQyLCByaWdodDJdKSA9PiB7XG4gICAgICAgIHJldHVybiBoYW5kbGVJbnRlcnNlY3Rpb25SZXN1bHRzKHBheWxvYWQsIGxlZnQyLCByaWdodDIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBoYW5kbGVJbnRlcnNlY3Rpb25SZXN1bHRzKHBheWxvYWQsIGxlZnQsIHJpZ2h0KTtcbiAgfTtcbn0pO1xuZnVuY3Rpb24gbWVyZ2VWYWx1ZXMoYSwgYikge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBhIH07XG4gIH1cbiAgaWYgKGEgaW5zdGFuY2VvZiBEYXRlICYmIGIgaW5zdGFuY2VvZiBEYXRlICYmICthID09PSArYikge1xuICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBhIH07XG4gIH1cbiAgaWYgKGlzUGxhaW5PYmplY3QoYSkgJiYgaXNQbGFpbk9iamVjdChiKSkge1xuICAgIGNvbnN0IGJLZXlzID0gT2JqZWN0LmtleXMoYik7XG4gICAgY29uc3Qgc2hhcmVkS2V5cyA9IE9iamVjdC5rZXlzKGEpLmZpbHRlcigoa2V5KSA9PiBiS2V5cy5pbmRleE9mKGtleSkgIT09IC0xKTtcbiAgICBjb25zdCBuZXdPYmogPSB7IC4uLmEsIC4uLmIgfTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBzaGFyZWRLZXlzKSB7XG4gICAgICBjb25zdCBzaGFyZWRWYWx1ZSA9IG1lcmdlVmFsdWVzKGFba2V5XSwgYltrZXldKTtcbiAgICAgIGlmICghc2hhcmVkVmFsdWUudmFsaWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWxpZDogZmFsc2UsXG4gICAgICAgICAgbWVyZ2VFcnJvclBhdGg6IFtrZXksIC4uLnNoYXJlZFZhbHVlLm1lcmdlRXJyb3JQYXRoXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgbmV3T2JqW2tleV0gPSBzaGFyZWRWYWx1ZS5kYXRhO1xuICAgIH1cbiAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSwgZGF0YTogbmV3T2JqIH07XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoYSkgJiYgQXJyYXkuaXNBcnJheShiKSkge1xuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgbWVyZ2VFcnJvclBhdGg6IFtdIH07XG4gICAgfVxuICAgIGNvbnN0IG5ld0FycmF5ID0gW107XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGEubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBjb25zdCBpdGVtQSA9IGFbaW5kZXhdO1xuICAgICAgY29uc3QgaXRlbUIgPSBiW2luZGV4XTtcbiAgICAgIGNvbnN0IHNoYXJlZFZhbHVlID0gbWVyZ2VWYWx1ZXMoaXRlbUEsIGl0ZW1CKTtcbiAgICAgIGlmICghc2hhcmVkVmFsdWUudmFsaWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWxpZDogZmFsc2UsXG4gICAgICAgICAgbWVyZ2VFcnJvclBhdGg6IFtpbmRleCwgLi4uc2hhcmVkVmFsdWUubWVyZ2VFcnJvclBhdGhdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBuZXdBcnJheS5wdXNoKHNoYXJlZFZhbHVlLmRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSwgZGF0YTogbmV3QXJyYXkgfTtcbiAgfVxuICByZXR1cm4geyB2YWxpZDogZmFsc2UsIG1lcmdlRXJyb3JQYXRoOiBbXSB9O1xufVxuZnVuY3Rpb24gaGFuZGxlSW50ZXJzZWN0aW9uUmVzdWx0cyhyZXN1bHQsIGxlZnQsIHJpZ2h0KSB7XG4gIGlmIChsZWZ0Lmlzc3Vlcy5sZW5ndGgpIHtcbiAgICByZXN1bHQuaXNzdWVzLnB1c2goLi4ubGVmdC5pc3N1ZXMpO1xuICB9XG4gIGlmIChyaWdodC5pc3N1ZXMubGVuZ3RoKSB7XG4gICAgcmVzdWx0Lmlzc3Vlcy5wdXNoKC4uLnJpZ2h0Lmlzc3Vlcyk7XG4gIH1cbiAgaWYgKGFib3J0ZWQocmVzdWx0KSlcbiAgICByZXR1cm4gcmVzdWx0O1xuICBjb25zdCBtZXJnZWQgPSBtZXJnZVZhbHVlcyhsZWZ0LnZhbHVlLCByaWdodC52YWx1ZSk7XG4gIGlmICghbWVyZ2VkLnZhbGlkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbm1lcmdhYmxlIGludGVyc2VjdGlvbi4gRXJyb3IgcGF0aDogJHtKU09OLnN0cmluZ2lmeShtZXJnZWQubWVyZ2VFcnJvclBhdGgpfWApO1xuICB9XG4gIHJlc3VsdC52YWx1ZSA9IG1lcmdlZC5kYXRhO1xuICByZXR1cm4gcmVzdWx0O1xufVxudmFyICRab2RFbnVtID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIiRab2RFbnVtXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICBjb25zdCB2YWx1ZXMgPSBnZXRFbnVtVmFsdWVzKGRlZi5lbnRyaWVzKTtcbiAgaW5zdC5fem9kLnZhbHVlcyA9IG5ldyBTZXQodmFsdWVzKTtcbiAgaW5zdC5fem9kLnBhdHRlcm4gPSBuZXcgUmVnRXhwKGBeKCR7dmFsdWVzLmZpbHRlcigoaykgPT4gcHJvcGVydHlLZXlUeXBlcy5oYXModHlwZW9mIGspKS5tYXAoKG8pID0+IHR5cGVvZiBvID09PSBcInN0cmluZ1wiID8gZXNjYXBlUmVnZXgobykgOiBvLnRvU3RyaW5nKCkpLmpvaW4oXCJ8XCIpfSkkYCk7XG4gIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBfY3R4KSA9PiB7XG4gICAgY29uc3QgaW5wdXQgPSBwYXlsb2FkLnZhbHVlO1xuICAgIGlmIChpbnN0Ll96b2QudmFsdWVzLmhhcyhpbnB1dCkpIHtcbiAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH1cbiAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgIGNvZGU6IFwiaW52YWxpZF92YWx1ZVwiLFxuICAgICAgdmFsdWVzLFxuICAgICAgaW5wdXQsXG4gICAgICBpbnN0XG4gICAgfSk7XG4gICAgcmV0dXJuIHBheWxvYWQ7XG4gIH07XG59KTtcbnZhciAkWm9kVHJhbnNmb3JtID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIiRab2RUcmFuc2Zvcm1cIiwgKGluc3QsIGRlZikgPT4ge1xuICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBfY3R4KSA9PiB7XG4gICAgY29uc3QgX291dCA9IGRlZi50cmFuc2Zvcm0ocGF5bG9hZC52YWx1ZSwgcGF5bG9hZCk7XG4gICAgaWYgKF9jdHguYXN5bmMpIHtcbiAgICAgIGNvbnN0IG91dHB1dCA9IF9vdXQgaW5zdGFuY2VvZiBQcm9taXNlID8gX291dCA6IFByb21pc2UucmVzb2x2ZShfb3V0KTtcbiAgICAgIHJldHVybiBvdXRwdXQudGhlbigob3V0cHV0MikgPT4ge1xuICAgICAgICBwYXlsb2FkLnZhbHVlID0gb3V0cHV0MjtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKF9vdXQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICB0aHJvdyBuZXcgJFpvZEFzeW5jRXJyb3IoKTtcbiAgICB9XG4gICAgcGF5bG9hZC52YWx1ZSA9IF9vdXQ7XG4gICAgcmV0dXJuIHBheWxvYWQ7XG4gIH07XG59KTtcbnZhciAkWm9kT3B0aW9uYWwgPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiJFpvZE9wdGlvbmFsXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICBpbnN0Ll96b2Qub3B0aW4gPSBcIm9wdGlvbmFsXCI7XG4gIGluc3QuX3pvZC5vcHRvdXQgPSBcIm9wdGlvbmFsXCI7XG4gIGRlZmluZUxhenkoaW5zdC5fem9kLCBcInZhbHVlc1wiLCAoKSA9PiB7XG4gICAgcmV0dXJuIGRlZi5pbm5lclR5cGUuX3pvZC52YWx1ZXMgPyAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbLi4uZGVmLmlubmVyVHlwZS5fem9kLnZhbHVlcywgdm9pZCAwXSkgOiB2b2lkIDA7XG4gIH0pO1xuICBkZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJwYXR0ZXJuXCIsICgpID0+IHtcbiAgICBjb25zdCBwYXR0ZXJuID0gZGVmLmlubmVyVHlwZS5fem9kLnBhdHRlcm47XG4gICAgcmV0dXJuIHBhdHRlcm4gPyBuZXcgUmVnRXhwKGBeKCR7Y2xlYW5SZWdleChwYXR0ZXJuLnNvdXJjZSl9KT8kYCkgOiB2b2lkIDA7XG4gIH0pO1xuICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgY3R4KSA9PiB7XG4gICAgaWYgKGRlZi5pbm5lclR5cGUuX3pvZC5vcHRpbiA9PT0gXCJvcHRpb25hbFwiKSB7XG4gICAgICByZXR1cm4gZGVmLmlubmVyVHlwZS5fem9kLnJ1bihwYXlsb2FkLCBjdHgpO1xuICAgIH1cbiAgICBpZiAocGF5bG9hZC52YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICB9XG4gICAgcmV0dXJuIGRlZi5pbm5lclR5cGUuX3pvZC5ydW4ocGF5bG9hZCwgY3R4KTtcbiAgfTtcbn0pO1xudmFyICRab2ROdWxsYWJsZSA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCIkWm9kTnVsbGFibGVcIiwgKGluc3QsIGRlZikgPT4ge1xuICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gIGRlZmluZUxhenkoaW5zdC5fem9kLCBcIm9wdGluXCIsICgpID0+IGRlZi5pbm5lclR5cGUuX3pvZC5vcHRpbik7XG4gIGRlZmluZUxhenkoaW5zdC5fem9kLCBcIm9wdG91dFwiLCAoKSA9PiBkZWYuaW5uZXJUeXBlLl96b2Qub3B0b3V0KTtcbiAgZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwicGF0dGVyblwiLCAoKSA9PiB7XG4gICAgY29uc3QgcGF0dGVybiA9IGRlZi5pbm5lclR5cGUuX3pvZC5wYXR0ZXJuO1xuICAgIHJldHVybiBwYXR0ZXJuID8gbmV3IFJlZ0V4cChgXigke2NsZWFuUmVnZXgocGF0dGVybi5zb3VyY2UpfXxudWxsKSRgKSA6IHZvaWQgMDtcbiAgfSk7XG4gIGRlZmluZUxhenkoaW5zdC5fem9kLCBcInZhbHVlc1wiLCAoKSA9PiB7XG4gICAgcmV0dXJuIGRlZi5pbm5lclR5cGUuX3pvZC52YWx1ZXMgPyAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbLi4uZGVmLmlubmVyVHlwZS5fem9kLnZhbHVlcywgbnVsbF0pIDogdm9pZCAwO1xuICB9KTtcbiAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIGN0eCkgPT4ge1xuICAgIGlmIChwYXlsb2FkLnZhbHVlID09PSBudWxsKVxuICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgcmV0dXJuIGRlZi5pbm5lclR5cGUuX3pvZC5ydW4ocGF5bG9hZCwgY3R4KTtcbiAgfTtcbn0pO1xudmFyICRab2REZWZhdWx0ID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIiRab2REZWZhdWx0XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICBpbnN0Ll96b2Qub3B0aW4gPSBcIm9wdGlvbmFsXCI7XG4gIGRlZmluZUxhenkoaW5zdC5fem9kLCBcInZhbHVlc1wiLCAoKSA9PiBkZWYuaW5uZXJUeXBlLl96b2QudmFsdWVzKTtcbiAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIGN0eCkgPT4ge1xuICAgIGlmIChwYXlsb2FkLnZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHBheWxvYWQudmFsdWUgPSBkZWYuZGVmYXVsdFZhbHVlO1xuICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGRlZi5pbm5lclR5cGUuX3pvZC5ydW4ocGF5bG9hZCwgY3R4KTtcbiAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKChyZXN1bHQyKSA9PiBoYW5kbGVEZWZhdWx0UmVzdWx0KHJlc3VsdDIsIGRlZikpO1xuICAgIH1cbiAgICByZXR1cm4gaGFuZGxlRGVmYXVsdFJlc3VsdChyZXN1bHQsIGRlZik7XG4gIH07XG59KTtcbmZ1bmN0aW9uIGhhbmRsZURlZmF1bHRSZXN1bHQocGF5bG9hZCwgZGVmKSB7XG4gIGlmIChwYXlsb2FkLnZhbHVlID09PSB2b2lkIDApIHtcbiAgICBwYXlsb2FkLnZhbHVlID0gZGVmLmRlZmF1bHRWYWx1ZTtcbiAgfVxuICByZXR1cm4gcGF5bG9hZDtcbn1cbnZhciAkWm9kUHJlZmF1bHQgPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiJFpvZFByZWZhdWx0XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICBpbnN0Ll96b2Qub3B0aW4gPSBcIm9wdGlvbmFsXCI7XG4gIGRlZmluZUxhenkoaW5zdC5fem9kLCBcInZhbHVlc1wiLCAoKSA9PiBkZWYuaW5uZXJUeXBlLl96b2QudmFsdWVzKTtcbiAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIGN0eCkgPT4ge1xuICAgIGlmIChwYXlsb2FkLnZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHBheWxvYWQudmFsdWUgPSBkZWYuZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gZGVmLmlubmVyVHlwZS5fem9kLnJ1bihwYXlsb2FkLCBjdHgpO1xuICB9O1xufSk7XG52YXIgJFpvZE5vbk9wdGlvbmFsID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIiRab2ROb25PcHRpb25hbFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwidmFsdWVzXCIsICgpID0+IHtcbiAgICBjb25zdCB2ID0gZGVmLmlubmVyVHlwZS5fem9kLnZhbHVlcztcbiAgICByZXR1cm4gdiA/IG5ldyBTZXQoWy4uLnZdLmZpbHRlcigoeCkgPT4geCAhPT0gdm9pZCAwKSkgOiB2b2lkIDA7XG4gIH0pO1xuICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgY3R4KSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gZGVmLmlubmVyVHlwZS5fem9kLnJ1bihwYXlsb2FkLCBjdHgpO1xuICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICByZXR1cm4gcmVzdWx0LnRoZW4oKHJlc3VsdDIpID0+IGhhbmRsZU5vbk9wdGlvbmFsUmVzdWx0KHJlc3VsdDIsIGluc3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhbmRsZU5vbk9wdGlvbmFsUmVzdWx0KHJlc3VsdCwgaW5zdCk7XG4gIH07XG59KTtcbmZ1bmN0aW9uIGhhbmRsZU5vbk9wdGlvbmFsUmVzdWx0KHBheWxvYWQsIGluc3QpIHtcbiAgaWYgKCFwYXlsb2FkLmlzc3Vlcy5sZW5ndGggJiYgcGF5bG9hZC52YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICBjb2RlOiBcImludmFsaWRfdHlwZVwiLFxuICAgICAgZXhwZWN0ZWQ6IFwibm9ub3B0aW9uYWxcIixcbiAgICAgIGlucHV0OiBwYXlsb2FkLnZhbHVlLFxuICAgICAgaW5zdFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBwYXlsb2FkO1xufVxudmFyICRab2RDYXRjaCA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCIkWm9kQ2F0Y2hcIiwgKGluc3QsIGRlZikgPT4ge1xuICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gIGluc3QuX3pvZC5vcHRpbiA9IFwib3B0aW9uYWxcIjtcbiAgZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwib3B0b3V0XCIsICgpID0+IGRlZi5pbm5lclR5cGUuX3pvZC5vcHRvdXQpO1xuICBkZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJ2YWx1ZXNcIiwgKCkgPT4gZGVmLmlubmVyVHlwZS5fem9kLnZhbHVlcyk7XG4gIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBjdHgpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBkZWYuaW5uZXJUeXBlLl96b2QucnVuKHBheWxvYWQsIGN0eCk7XG4gICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgIHJldHVybiByZXN1bHQudGhlbigocmVzdWx0MikgPT4ge1xuICAgICAgICBwYXlsb2FkLnZhbHVlID0gcmVzdWx0Mi52YWx1ZTtcbiAgICAgICAgaWYgKHJlc3VsdDIuaXNzdWVzLmxlbmd0aCkge1xuICAgICAgICAgIHBheWxvYWQudmFsdWUgPSBkZWYuY2F0Y2hWYWx1ZSh7XG4gICAgICAgICAgICAuLi5wYXlsb2FkLFxuICAgICAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgICAgaXNzdWVzOiByZXN1bHQyLmlzc3Vlcy5tYXAoKGlzcykgPT4gZmluYWxpemVJc3N1ZShpc3MsIGN0eCwgY29uZmlnKCkpKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlucHV0OiBwYXlsb2FkLnZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcGF5bG9hZC5pc3N1ZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBwYXlsb2FkLnZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgIGlmIChyZXN1bHQuaXNzdWVzLmxlbmd0aCkge1xuICAgICAgcGF5bG9hZC52YWx1ZSA9IGRlZi5jYXRjaFZhbHVlKHtcbiAgICAgICAgLi4ucGF5bG9hZCxcbiAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICBpc3N1ZXM6IHJlc3VsdC5pc3N1ZXMubWFwKChpc3MpID0+IGZpbmFsaXplSXNzdWUoaXNzLCBjdHgsIGNvbmZpZygpKSlcbiAgICAgICAgfSxcbiAgICAgICAgaW5wdXQ6IHBheWxvYWQudmFsdWVcbiAgICAgIH0pO1xuICAgICAgcGF5bG9hZC5pc3N1ZXMgPSBbXTtcbiAgICB9XG4gICAgcmV0dXJuIHBheWxvYWQ7XG4gIH07XG59KTtcbnZhciAkWm9kUGlwZSA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCIkWm9kUGlwZVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwidmFsdWVzXCIsICgpID0+IGRlZi5pbi5fem9kLnZhbHVlcyk7XG4gIGRlZmluZUxhenkoaW5zdC5fem9kLCBcIm9wdGluXCIsICgpID0+IGRlZi5pbi5fem9kLm9wdGluKTtcbiAgZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwib3B0b3V0XCIsICgpID0+IGRlZi5vdXQuX3pvZC5vcHRvdXQpO1xuICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgY3R4KSA9PiB7XG4gICAgY29uc3QgbGVmdCA9IGRlZi5pbi5fem9kLnJ1bihwYXlsb2FkLCBjdHgpO1xuICAgIGlmIChsZWZ0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgcmV0dXJuIGxlZnQudGhlbigobGVmdDIpID0+IGhhbmRsZVBpcGVSZXN1bHQobGVmdDIsIGRlZiwgY3R4KSk7XG4gICAgfVxuICAgIHJldHVybiBoYW5kbGVQaXBlUmVzdWx0KGxlZnQsIGRlZiwgY3R4KTtcbiAgfTtcbn0pO1xuZnVuY3Rpb24gaGFuZGxlUGlwZVJlc3VsdChsZWZ0LCBkZWYsIGN0eCkge1xuICBpZiAoYWJvcnRlZChsZWZ0KSkge1xuICAgIHJldHVybiBsZWZ0O1xuICB9XG4gIHJldHVybiBkZWYub3V0Ll96b2QucnVuKHsgdmFsdWU6IGxlZnQudmFsdWUsIGlzc3VlczogbGVmdC5pc3N1ZXMgfSwgY3R4KTtcbn1cbnZhciAkWm9kUmVhZG9ubHkgPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiJFpvZFJlYWRvbmx5XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICBkZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJwcm9wVmFsdWVzXCIsICgpID0+IGRlZi5pbm5lclR5cGUuX3pvZC5wcm9wVmFsdWVzKTtcbiAgZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwidmFsdWVzXCIsICgpID0+IGRlZi5pbm5lclR5cGUuX3pvZC52YWx1ZXMpO1xuICBkZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJvcHRpblwiLCAoKSA9PiBkZWYuaW5uZXJUeXBlLl96b2Qub3B0aW4pO1xuICBkZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJvcHRvdXRcIiwgKCkgPT4gZGVmLmlubmVyVHlwZS5fem9kLm9wdG91dCk7XG4gIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBjdHgpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBkZWYuaW5uZXJUeXBlLl96b2QucnVuKHBheWxvYWQsIGN0eCk7XG4gICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgIHJldHVybiByZXN1bHQudGhlbihoYW5kbGVSZWFkb25seVJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiBoYW5kbGVSZWFkb25seVJlc3VsdChyZXN1bHQpO1xuICB9O1xufSk7XG5mdW5jdGlvbiBoYW5kbGVSZWFkb25seVJlc3VsdChwYXlsb2FkKSB7XG4gIHBheWxvYWQudmFsdWUgPSBPYmplY3QuZnJlZXplKHBheWxvYWQudmFsdWUpO1xuICByZXR1cm4gcGF5bG9hZDtcbn1cbnZhciAkWm9kQ3VzdG9tID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIiRab2RDdXN0b21cIiwgKGluc3QsIGRlZikgPT4ge1xuICAkWm9kQ2hlY2suaW5pdChpbnN0LCBkZWYpO1xuICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBfKSA9PiB7XG4gICAgcmV0dXJuIHBheWxvYWQ7XG4gIH07XG4gIGluc3QuX3pvZC5jaGVjayA9IChwYXlsb2FkKSA9PiB7XG4gICAgY29uc3QgaW5wdXQgPSBwYXlsb2FkLnZhbHVlO1xuICAgIGNvbnN0IHIgPSBkZWYuZm4oaW5wdXQpO1xuICAgIGlmIChyIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgcmV0dXJuIHIudGhlbigocjIpID0+IGhhbmRsZVJlZmluZVJlc3VsdChyMiwgcGF5bG9hZCwgaW5wdXQsIGluc3QpKTtcbiAgICB9XG4gICAgaGFuZGxlUmVmaW5lUmVzdWx0KHIsIHBheWxvYWQsIGlucHV0LCBpbnN0KTtcbiAgICByZXR1cm47XG4gIH07XG59KTtcbmZ1bmN0aW9uIGhhbmRsZVJlZmluZVJlc3VsdChyZXN1bHQsIHBheWxvYWQsIGlucHV0LCBpbnN0KSB7XG4gIGlmICghcmVzdWx0KSB7XG4gICAgY29uc3QgX2lzcyA9IHtcbiAgICAgIGNvZGU6IFwiY3VzdG9tXCIsXG4gICAgICBpbnB1dCxcbiAgICAgIGluc3QsXG4gICAgICAvLyBpbmNvcnBvcmF0ZXMgcGFyYW1zLmVycm9yIGludG8gaXNzdWUgcmVwb3J0aW5nXG4gICAgICBwYXRoOiBbLi4uaW5zdC5fem9kLmRlZi5wYXRoID8/IFtdXSxcbiAgICAgIC8vIGluY29ycG9yYXRlcyBwYXJhbXMuZXJyb3IgaW50byBpc3N1ZSByZXBvcnRpbmdcbiAgICAgIGNvbnRpbnVlOiAhaW5zdC5fem9kLmRlZi5hYm9ydFxuICAgICAgLy8gcGFyYW1zOiBpbnN0Ll96b2QuZGVmLnBhcmFtcyxcbiAgICB9O1xuICAgIGlmIChpbnN0Ll96b2QuZGVmLnBhcmFtcylcbiAgICAgIF9pc3MucGFyYW1zID0gaW5zdC5fem9kLmRlZi5wYXJhbXM7XG4gICAgcGF5bG9hZC5pc3N1ZXMucHVzaChpc3N1ZShfaXNzKSk7XG4gIH1cbn1cblxuLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3pvZEA0LjAuMS9ub2RlX21vZHVsZXMvem9kL3Y0L2NvcmUvcmVnaXN0cmllcy5qc1xudmFyICRvdXRwdXQgPSBTeW1ib2woXCJab2RPdXRwdXRcIik7XG52YXIgJGlucHV0ID0gU3ltYm9sKFwiWm9kSW5wdXRcIik7XG52YXIgJFpvZFJlZ2lzdHJ5ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9tYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuX2lkbWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICBhZGQoc2NoZW1hLCAuLi5fbWV0YSkge1xuICAgIGNvbnN0IG1ldGEgPSBfbWV0YVswXTtcbiAgICB0aGlzLl9tYXAuc2V0KHNjaGVtYSwgbWV0YSk7XG4gICAgaWYgKG1ldGEgJiYgdHlwZW9mIG1ldGEgPT09IFwib2JqZWN0XCIgJiYgXCJpZFwiIGluIG1ldGEpIHtcbiAgICAgIGlmICh0aGlzLl9pZG1hcC5oYXMobWV0YS5pZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJRCAke21ldGEuaWR9IGFscmVhZHkgZXhpc3RzIGluIHRoZSByZWdpc3RyeWApO1xuICAgICAgfVxuICAgICAgdGhpcy5faWRtYXAuc2V0KG1ldGEuaWQsIHNjaGVtYSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMuX21hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5faWRtYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlbW92ZShzY2hlbWEpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fbWFwLmdldChzY2hlbWEpO1xuICAgIGlmIChtZXRhICYmIHR5cGVvZiBtZXRhID09PSBcIm9iamVjdFwiICYmIFwiaWRcIiBpbiBtZXRhKSB7XG4gICAgICB0aGlzLl9pZG1hcC5kZWxldGUobWV0YS5pZCk7XG4gICAgfVxuICAgIHRoaXMuX21hcC5kZWxldGUoc2NoZW1hKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBnZXQoc2NoZW1hKSB7XG4gICAgY29uc3QgcCA9IHNjaGVtYS5fem9kLnBhcmVudDtcbiAgICBpZiAocCkge1xuICAgICAgY29uc3QgcG0gPSB7IC4uLnRoaXMuZ2V0KHApID8/IHt9IH07XG4gICAgICBkZWxldGUgcG0uaWQ7XG4gICAgICByZXR1cm4geyAuLi5wbSwgLi4udGhpcy5fbWFwLmdldChzY2hlbWEpIH07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9tYXAuZ2V0KHNjaGVtYSk7XG4gIH1cbiAgaGFzKHNjaGVtYSkge1xuICAgIHJldHVybiB0aGlzLl9tYXAuaGFzKHNjaGVtYSk7XG4gIH1cbn07XG5mdW5jdGlvbiByZWdpc3RyeSgpIHtcbiAgcmV0dXJuIG5ldyAkWm9kUmVnaXN0cnkoKTtcbn1cbnZhciBnbG9iYWxSZWdpc3RyeSA9IC8qIEBfX1BVUkVfXyAqLyByZWdpc3RyeSgpO1xuXG4vLyBub2RlX21vZHVsZXMvLnBucG0vem9kQDQuMC4xL25vZGVfbW9kdWxlcy96b2QvdjQvY29yZS9hcGkuanNcbmZ1bmN0aW9uIF91bmtub3duKENsYXNzMikge1xuICByZXR1cm4gbmV3IENsYXNzMih7XG4gICAgdHlwZTogXCJ1bmtub3duXCJcbiAgfSk7XG59XG5mdW5jdGlvbiBfbmV2ZXIoQ2xhc3MyLCBwYXJhbXMpIHtcbiAgcmV0dXJuIG5ldyBDbGFzczIoe1xuICAgIHR5cGU6IFwibmV2ZXJcIixcbiAgICAuLi5ub3JtYWxpemVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn1cbmZ1bmN0aW9uIF9tYXhMZW5ndGgobWF4aW11bSwgcGFyYW1zKSB7XG4gIGNvbnN0IGNoID0gbmV3ICRab2RDaGVja01heExlbmd0aCh7XG4gICAgY2hlY2s6IFwibWF4X2xlbmd0aFwiLFxuICAgIC4uLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIG1heGltdW1cbiAgfSk7XG4gIHJldHVybiBjaDtcbn1cbmZ1bmN0aW9uIF9taW5MZW5ndGgobWluaW11bSwgcGFyYW1zKSB7XG4gIHJldHVybiBuZXcgJFpvZENoZWNrTWluTGVuZ3RoKHtcbiAgICBjaGVjazogXCJtaW5fbGVuZ3RoXCIsXG4gICAgLi4ubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgbWluaW11bVxuICB9KTtcbn1cbmZ1bmN0aW9uIF9sZW5ndGgobGVuZ3RoLCBwYXJhbXMpIHtcbiAgcmV0dXJuIG5ldyAkWm9kQ2hlY2tMZW5ndGhFcXVhbHMoe1xuICAgIGNoZWNrOiBcImxlbmd0aF9lcXVhbHNcIixcbiAgICAuLi5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICBsZW5ndGhcbiAgfSk7XG59XG5mdW5jdGlvbiBfb3ZlcndyaXRlKHR4KSB7XG4gIHJldHVybiBuZXcgJFpvZENoZWNrT3ZlcndyaXRlKHtcbiAgICBjaGVjazogXCJvdmVyd3JpdGVcIixcbiAgICB0eFxuICB9KTtcbn1cbmZ1bmN0aW9uIF9hcnJheShDbGFzczIsIGVsZW1lbnQsIHBhcmFtcykge1xuICByZXR1cm4gbmV3IENsYXNzMih7XG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIGVsZW1lbnQsXG4gICAgLy8gZ2V0IGVsZW1lbnQoKSB7XG4gICAgLy8gICByZXR1cm4gZWxlbWVudDtcbiAgICAvLyB9LFxuICAgIC4uLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpXG4gIH0pO1xufVxuZnVuY3Rpb24gX3JlZmluZShDbGFzczIsIGZuLCBfcGFyYW1zKSB7XG4gIGNvbnN0IHNjaGVtYSA9IG5ldyBDbGFzczIoe1xuICAgIHR5cGU6IFwiY3VzdG9tXCIsXG4gICAgY2hlY2s6IFwiY3VzdG9tXCIsXG4gICAgZm4sXG4gICAgLi4ubm9ybWFsaXplUGFyYW1zKF9wYXJhbXMpXG4gIH0pO1xuICByZXR1cm4gc2NoZW1hO1xufVxuXG4vLyBub2RlX21vZHVsZXMvLnBucG0vem9kQDQuMC4xL25vZGVfbW9kdWxlcy96b2QvdjQvY2xhc3NpYy9lcnJvcnMuanNcbnZhciBpbml0aWFsaXplcjIgPSAoaW5zdCwgaXNzdWVzKSA9PiB7XG4gICRab2RFcnJvci5pbml0KGluc3QsIGlzc3Vlcyk7XG4gIGluc3QubmFtZSA9IFwiWm9kRXJyb3JcIjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoaW5zdCwge1xuICAgIGZvcm1hdDoge1xuICAgICAgdmFsdWU6IChtYXBwZXIpID0+IGZvcm1hdEVycm9yKGluc3QsIG1hcHBlcilcbiAgICAgIC8vIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIH0sXG4gICAgZmxhdHRlbjoge1xuICAgICAgdmFsdWU6IChtYXBwZXIpID0+IGZsYXR0ZW5FcnJvcihpbnN0LCBtYXBwZXIpXG4gICAgICAvLyBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB9LFxuICAgIGFkZElzc3VlOiB7XG4gICAgICB2YWx1ZTogKGlzc3VlMikgPT4gaW5zdC5pc3N1ZXMucHVzaChpc3N1ZTIpXG4gICAgICAvLyBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB9LFxuICAgIGFkZElzc3Vlczoge1xuICAgICAgdmFsdWU6IChpc3N1ZXMyKSA9PiBpbnN0Lmlzc3Vlcy5wdXNoKC4uLmlzc3VlczIpXG4gICAgICAvLyBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB9LFxuICAgIGlzRW1wdHk6IHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIGluc3QuaXNzdWVzLmxlbmd0aCA9PT0gMDtcbiAgICAgIH1cbiAgICAgIC8vIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIH1cbiAgfSk7XG59O1xudmFyIFpvZEVycm9yID0gJGNvbnN0cnVjdG9yKFwiWm9kRXJyb3JcIiwgaW5pdGlhbGl6ZXIyKTtcbnZhciBab2RSZWFsRXJyb3IgPSAkY29uc3RydWN0b3IoXCJab2RFcnJvclwiLCBpbml0aWFsaXplcjIsIHtcbiAgUGFyZW50OiBFcnJvclxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy8ucG5wbS96b2RANC4wLjEvbm9kZV9tb2R1bGVzL3pvZC92NC9jbGFzc2ljL3BhcnNlLmpzXG52YXIgcGFyc2UgPSAvKiBAX19QVVJFX18gKi8gX3BhcnNlKFpvZFJlYWxFcnJvcik7XG52YXIgcGFyc2VBc3luYyA9IC8qIEBfX1BVUkVfXyAqLyBfcGFyc2VBc3luYyhab2RSZWFsRXJyb3IpO1xudmFyIHNhZmVQYXJzZTIgPSAvKiBAX19QVVJFX18gKi8gX3NhZmVQYXJzZShab2RSZWFsRXJyb3IpO1xudmFyIHNhZmVQYXJzZUFzeW5jMiA9IC8qIEBfX1BVUkVfXyAqLyBfc2FmZVBhcnNlQXN5bmMoWm9kUmVhbEVycm9yKTtcblxuLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3pvZEA0LjAuMS9ub2RlX21vZHVsZXMvem9kL3Y0L2NsYXNzaWMvc2NoZW1hcy5qc1xudmFyIFpvZFR5cGUgPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiWm9kVHlwZVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgaW5zdC5kZWYgPSBkZWY7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbnN0LCBcIl9kZWZcIiwgeyB2YWx1ZTogZGVmIH0pO1xuICBpbnN0LmNoZWNrID0gKC4uLmNoZWNrcykgPT4ge1xuICAgIHJldHVybiBpbnN0LmNsb25lKFxuICAgICAge1xuICAgICAgICAuLi5kZWYsXG4gICAgICAgIGNoZWNrczogW1xuICAgICAgICAgIC4uLmRlZi5jaGVja3MgPz8gW10sXG4gICAgICAgICAgLi4uY2hlY2tzLm1hcCgoY2gpID0+IHR5cGVvZiBjaCA9PT0gXCJmdW5jdGlvblwiID8geyBfem9kOiB7IGNoZWNrOiBjaCwgZGVmOiB7IGNoZWNrOiBcImN1c3RvbVwiIH0sIG9uYXR0YWNoOiBbXSB9IH0gOiBjaClcbiAgICAgICAgXVxuICAgICAgfVxuICAgICAgLy8geyBwYXJlbnQ6IHRydWUgfVxuICAgICk7XG4gIH07XG4gIGluc3QuY2xvbmUgPSAoZGVmMiwgcGFyYW1zKSA9PiBjbG9uZShpbnN0LCBkZWYyLCBwYXJhbXMpO1xuICBpbnN0LmJyYW5kID0gKCkgPT4gaW5zdDtcbiAgaW5zdC5yZWdpc3RlciA9IChyZWcsIG1ldGEpID0+IHtcbiAgICByZWcuYWRkKGluc3QsIG1ldGEpO1xuICAgIHJldHVybiBpbnN0O1xuICB9O1xuICBpbnN0LnBhcnNlID0gKGRhdGEsIHBhcmFtcykgPT4gcGFyc2UoaW5zdCwgZGF0YSwgcGFyYW1zLCB7IGNhbGxlZTogaW5zdC5wYXJzZSB9KTtcbiAgaW5zdC5zYWZlUGFyc2UgPSAoZGF0YSwgcGFyYW1zKSA9PiBzYWZlUGFyc2UyKGluc3QsIGRhdGEsIHBhcmFtcyk7XG4gIGluc3QucGFyc2VBc3luYyA9IGFzeW5jIChkYXRhLCBwYXJhbXMpID0+IHBhcnNlQXN5bmMoaW5zdCwgZGF0YSwgcGFyYW1zLCB7IGNhbGxlZTogaW5zdC5wYXJzZUFzeW5jIH0pO1xuICBpbnN0LnNhZmVQYXJzZUFzeW5jID0gYXN5bmMgKGRhdGEsIHBhcmFtcykgPT4gc2FmZVBhcnNlQXN5bmMyKGluc3QsIGRhdGEsIHBhcmFtcyk7XG4gIGluc3Quc3BhID0gaW5zdC5zYWZlUGFyc2VBc3luYztcbiAgaW5zdC5yZWZpbmUgPSAoY2hlY2syLCBwYXJhbXMpID0+IGluc3QuY2hlY2socmVmaW5lKGNoZWNrMiwgcGFyYW1zKSk7XG4gIGluc3Quc3VwZXJSZWZpbmUgPSAocmVmaW5lbWVudCkgPT4gaW5zdC5jaGVjayhzdXBlclJlZmluZShyZWZpbmVtZW50KSk7XG4gIGluc3Qub3ZlcndyaXRlID0gKGZuKSA9PiBpbnN0LmNoZWNrKF9vdmVyd3JpdGUoZm4pKTtcbiAgaW5zdC5vcHRpb25hbCA9ICgpID0+IG9wdGlvbmFsKGluc3QpO1xuICBpbnN0Lm51bGxhYmxlID0gKCkgPT4gbnVsbGFibGUoaW5zdCk7XG4gIGluc3QubnVsbGlzaCA9ICgpID0+IG9wdGlvbmFsKG51bGxhYmxlKGluc3QpKTtcbiAgaW5zdC5ub25vcHRpb25hbCA9IChwYXJhbXMpID0+IG5vbm9wdGlvbmFsKGluc3QsIHBhcmFtcyk7XG4gIGluc3QuYXJyYXkgPSAoKSA9PiBhcnJheShpbnN0KTtcbiAgaW5zdC5vciA9IChhcmcpID0+IHVuaW9uKFtpbnN0LCBhcmddKTtcbiAgaW5zdC5hbmQgPSAoYXJnKSA9PiBpbnRlcnNlY3Rpb24oaW5zdCwgYXJnKTtcbiAgaW5zdC50cmFuc2Zvcm0gPSAodHgpID0+IHBpcGUoaW5zdCwgdHJhbnNmb3JtKHR4KSk7XG4gIGluc3QuZGVmYXVsdCA9IChkZWYyKSA9PiBfZGVmYXVsdChpbnN0LCBkZWYyKTtcbiAgaW5zdC5wcmVmYXVsdCA9IChkZWYyKSA9PiBwcmVmYXVsdChpbnN0LCBkZWYyKTtcbiAgaW5zdC5jYXRjaCA9IChwYXJhbXMpID0+IF9jYXRjaChpbnN0LCBwYXJhbXMpO1xuICBpbnN0LnBpcGUgPSAodGFyZ2V0KSA9PiBwaXBlKGluc3QsIHRhcmdldCk7XG4gIGluc3QucmVhZG9ubHkgPSAoKSA9PiByZWFkb25seShpbnN0KTtcbiAgaW5zdC5kZXNjcmliZSA9IChkZXNjcmlwdGlvbikgPT4ge1xuICAgIGNvbnN0IGNsID0gaW5zdC5jbG9uZSgpO1xuICAgIGdsb2JhbFJlZ2lzdHJ5LmFkZChjbCwgeyBkZXNjcmlwdGlvbiB9KTtcbiAgICByZXR1cm4gY2w7XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbnN0LCBcImRlc2NyaXB0aW9uXCIsIHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gZ2xvYmFsUmVnaXN0cnkuZ2V0KGluc3QpPy5kZXNjcmlwdGlvbjtcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgaW5zdC5tZXRhID0gKC4uLmFyZ3MpID0+IHtcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBnbG9iYWxSZWdpc3RyeS5nZXQoaW5zdCk7XG4gICAgfVxuICAgIGNvbnN0IGNsID0gaW5zdC5jbG9uZSgpO1xuICAgIGdsb2JhbFJlZ2lzdHJ5LmFkZChjbCwgYXJnc1swXSk7XG4gICAgcmV0dXJuIGNsO1xuICB9O1xuICBpbnN0LmlzT3B0aW9uYWwgPSAoKSA9PiBpbnN0LnNhZmVQYXJzZSh2b2lkIDApLnN1Y2Nlc3M7XG4gIGluc3QuaXNOdWxsYWJsZSA9ICgpID0+IGluc3Quc2FmZVBhcnNlKG51bGwpLnN1Y2Nlc3M7XG4gIHJldHVybiBpbnN0O1xufSk7XG52YXIgWm9kVW5rbm93biA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCJab2RVbmtub3duXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgJFpvZFVua25vd24uaW5pdChpbnN0LCBkZWYpO1xuICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZnVuY3Rpb24gdW5rbm93bigpIHtcbiAgcmV0dXJuIF91bmtub3duKFpvZFVua25vd24pO1xufVxudmFyIFpvZE5ldmVyID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIlpvZE5ldmVyXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgJFpvZE5ldmVyLmluaXQoaW5zdCwgZGVmKTtcbiAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG59KTtcbmZ1bmN0aW9uIG5ldmVyKHBhcmFtcykge1xuICByZXR1cm4gX25ldmVyKFpvZE5ldmVyLCBwYXJhbXMpO1xufVxudmFyIFpvZEFycmF5ID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIlpvZEFycmF5XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgJFpvZEFycmF5LmluaXQoaW5zdCwgZGVmKTtcbiAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gIGluc3QuZWxlbWVudCA9IGRlZi5lbGVtZW50O1xuICBpbnN0Lm1pbiA9IChtaW5MZW5ndGgsIHBhcmFtcykgPT4gaW5zdC5jaGVjayhfbWluTGVuZ3RoKG1pbkxlbmd0aCwgcGFyYW1zKSk7XG4gIGluc3Qubm9uZW1wdHkgPSAocGFyYW1zKSA9PiBpbnN0LmNoZWNrKF9taW5MZW5ndGgoMSwgcGFyYW1zKSk7XG4gIGluc3QubWF4ID0gKG1heExlbmd0aCwgcGFyYW1zKSA9PiBpbnN0LmNoZWNrKF9tYXhMZW5ndGgobWF4TGVuZ3RoLCBwYXJhbXMpKTtcbiAgaW5zdC5sZW5ndGggPSAobGVuLCBwYXJhbXMpID0+IGluc3QuY2hlY2soX2xlbmd0aChsZW4sIHBhcmFtcykpO1xuICBpbnN0LnVud3JhcCA9ICgpID0+IGluc3QuZWxlbWVudDtcbn0pO1xuZnVuY3Rpb24gYXJyYXkoZWxlbWVudCwgcGFyYW1zKSB7XG4gIHJldHVybiBfYXJyYXkoWm9kQXJyYXksIGVsZW1lbnQsIHBhcmFtcyk7XG59XG52YXIgWm9kT2JqZWN0ID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIlpvZE9iamVjdFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICRab2RPYmplY3QuaW5pdChpbnN0LCBkZWYpO1xuICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgdXRpbF9leHBvcnRzLmRlZmluZUxhenkoaW5zdCwgXCJzaGFwZVwiLCAoKSA9PiBkZWYuc2hhcGUpO1xuICBpbnN0LmtleW9mID0gKCkgPT4gX2VudW0oT2JqZWN0LmtleXMoaW5zdC5fem9kLmRlZi5zaGFwZSkpO1xuICBpbnN0LmNhdGNoYWxsID0gKGNhdGNoYWxsKSA9PiBpbnN0LmNsb25lKHsgLi4uaW5zdC5fem9kLmRlZiwgY2F0Y2hhbGwgfSk7XG4gIGluc3QucGFzc3Rocm91Z2ggPSAoKSA9PiBpbnN0LmNsb25lKHsgLi4uaW5zdC5fem9kLmRlZiwgY2F0Y2hhbGw6IHVua25vd24oKSB9KTtcbiAgaW5zdC5sb29zZSA9ICgpID0+IGluc3QuY2xvbmUoeyAuLi5pbnN0Ll96b2QuZGVmLCBjYXRjaGFsbDogdW5rbm93bigpIH0pO1xuICBpbnN0LnN0cmljdCA9ICgpID0+IGluc3QuY2xvbmUoeyAuLi5pbnN0Ll96b2QuZGVmLCBjYXRjaGFsbDogbmV2ZXIoKSB9KTtcbiAgaW5zdC5zdHJpcCA9ICgpID0+IGluc3QuY2xvbmUoeyAuLi5pbnN0Ll96b2QuZGVmLCBjYXRjaGFsbDogdm9pZCAwIH0pO1xuICBpbnN0LmV4dGVuZCA9IChpbmNvbWluZykgPT4ge1xuICAgIHJldHVybiB1dGlsX2V4cG9ydHMuZXh0ZW5kKGluc3QsIGluY29taW5nKTtcbiAgfTtcbiAgaW5zdC5tZXJnZSA9IChvdGhlcikgPT4gdXRpbF9leHBvcnRzLm1lcmdlKGluc3QsIG90aGVyKTtcbiAgaW5zdC5waWNrID0gKG1hc2spID0+IHV0aWxfZXhwb3J0cy5waWNrKGluc3QsIG1hc2spO1xuICBpbnN0Lm9taXQgPSAobWFzaykgPT4gdXRpbF9leHBvcnRzLm9taXQoaW5zdCwgbWFzayk7XG4gIGluc3QucGFydGlhbCA9ICguLi5hcmdzKSA9PiB1dGlsX2V4cG9ydHMucGFydGlhbChab2RPcHRpb25hbCwgaW5zdCwgYXJnc1swXSk7XG4gIGluc3QucmVxdWlyZWQgPSAoLi4uYXJncykgPT4gdXRpbF9leHBvcnRzLnJlcXVpcmVkKFpvZE5vbk9wdGlvbmFsLCBpbnN0LCBhcmdzWzBdKTtcbn0pO1xudmFyIFpvZFVuaW9uID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIlpvZFVuaW9uXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgJFpvZFVuaW9uLmluaXQoaW5zdCwgZGVmKTtcbiAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gIGluc3Qub3B0aW9ucyA9IGRlZi5vcHRpb25zO1xufSk7XG5mdW5jdGlvbiB1bmlvbihvcHRpb25zLCBwYXJhbXMpIHtcbiAgcmV0dXJuIG5ldyBab2RVbmlvbih7XG4gICAgdHlwZTogXCJ1bmlvblwiLFxuICAgIG9wdGlvbnMsXG4gICAgLi4udXRpbF9leHBvcnRzLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpXG4gIH0pO1xufVxudmFyIFpvZEludGVyc2VjdGlvbiA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCJab2RJbnRlcnNlY3Rpb25cIiwgKGluc3QsIGRlZikgPT4ge1xuICAkWm9kSW50ZXJzZWN0aW9uLmluaXQoaW5zdCwgZGVmKTtcbiAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG59KTtcbmZ1bmN0aW9uIGludGVyc2VjdGlvbihsZWZ0LCByaWdodCkge1xuICByZXR1cm4gbmV3IFpvZEludGVyc2VjdGlvbih7XG4gICAgdHlwZTogXCJpbnRlcnNlY3Rpb25cIixcbiAgICBsZWZ0LFxuICAgIHJpZ2h0XG4gIH0pO1xufVxudmFyIFpvZEVudW0gPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiWm9kRW51bVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICRab2RFbnVtLmluaXQoaW5zdCwgZGVmKTtcbiAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gIGluc3QuZW51bSA9IGRlZi5lbnRyaWVzO1xuICBpbnN0Lm9wdGlvbnMgPSBPYmplY3QudmFsdWVzKGRlZi5lbnRyaWVzKTtcbiAgY29uc3Qga2V5cyA9IG5ldyBTZXQoT2JqZWN0LmtleXMoZGVmLmVudHJpZXMpKTtcbiAgaW5zdC5leHRyYWN0ID0gKHZhbHVlcywgcGFyYW1zKSA9PiB7XG4gICAgY29uc3QgbmV3RW50cmllcyA9IHt9O1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICBpZiAoa2V5cy5oYXModmFsdWUpKSB7XG4gICAgICAgIG5ld0VudHJpZXNbdmFsdWVdID0gZGVmLmVudHJpZXNbdmFsdWVdO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5ICR7dmFsdWV9IG5vdCBmb3VuZCBpbiBlbnVtYCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgWm9kRW51bSh7XG4gICAgICAuLi5kZWYsXG4gICAgICBjaGVja3M6IFtdLFxuICAgICAgLi4udXRpbF9leHBvcnRzLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgICAgZW50cmllczogbmV3RW50cmllc1xuICAgIH0pO1xuICB9O1xuICBpbnN0LmV4Y2x1ZGUgPSAodmFsdWVzLCBwYXJhbXMpID0+IHtcbiAgICBjb25zdCBuZXdFbnRyaWVzID0geyAuLi5kZWYuZW50cmllcyB9O1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICBpZiAoa2V5cy5oYXModmFsdWUpKSB7XG4gICAgICAgIGRlbGV0ZSBuZXdFbnRyaWVzW3ZhbHVlXTtcbiAgICAgIH0gZWxzZVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEtleSAke3ZhbHVlfSBub3QgZm91bmQgaW4gZW51bWApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFpvZEVudW0oe1xuICAgICAgLi4uZGVmLFxuICAgICAgY2hlY2tzOiBbXSxcbiAgICAgIC4uLnV0aWxfZXhwb3J0cy5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICAgIGVudHJpZXM6IG5ld0VudHJpZXNcbiAgICB9KTtcbiAgfTtcbn0pO1xuZnVuY3Rpb24gX2VudW0odmFsdWVzLCBwYXJhbXMpIHtcbiAgY29uc3QgZW50cmllcyA9IEFycmF5LmlzQXJyYXkodmFsdWVzKSA/IE9iamVjdC5mcm9tRW50cmllcyh2YWx1ZXMubWFwKCh2KSA9PiBbdiwgdl0pKSA6IHZhbHVlcztcbiAgcmV0dXJuIG5ldyBab2RFbnVtKHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICBlbnRyaWVzLFxuICAgIC4uLnV0aWxfZXhwb3J0cy5ub3JtYWxpemVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn1cbnZhciBab2RUcmFuc2Zvcm0gPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiWm9kVHJhbnNmb3JtXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgJFpvZFRyYW5zZm9ybS5pbml0KGluc3QsIGRlZik7XG4gIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgX2N0eCkgPT4ge1xuICAgIHBheWxvYWQuYWRkSXNzdWUgPSAoaXNzdWUyKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGlzc3VlMiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHV0aWxfZXhwb3J0cy5pc3N1ZShpc3N1ZTIsIHBheWxvYWQudmFsdWUsIGRlZikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgX2lzc3VlID0gaXNzdWUyO1xuICAgICAgICBpZiAoX2lzc3VlLmZhdGFsKVxuICAgICAgICAgIF9pc3N1ZS5jb250aW51ZSA9IGZhbHNlO1xuICAgICAgICBfaXNzdWUuY29kZSA/PyAoX2lzc3VlLmNvZGUgPSBcImN1c3RvbVwiKTtcbiAgICAgICAgX2lzc3VlLmlucHV0ID8/IChfaXNzdWUuaW5wdXQgPSBwYXlsb2FkLnZhbHVlKTtcbiAgICAgICAgX2lzc3VlLmluc3QgPz8gKF9pc3N1ZS5pbnN0ID0gaW5zdCk7XG4gICAgICAgIF9pc3N1ZS5jb250aW51ZSA/PyAoX2lzc3VlLmNvbnRpbnVlID0gdHJ1ZSk7XG4gICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2godXRpbF9leHBvcnRzLmlzc3VlKF9pc3N1ZSkpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgb3V0cHV0ID0gZGVmLnRyYW5zZm9ybShwYXlsb2FkLnZhbHVlLCBwYXlsb2FkKTtcbiAgICBpZiAob3V0cHV0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgcmV0dXJuIG91dHB1dC50aGVuKChvdXRwdXQyKSA9PiB7XG4gICAgICAgIHBheWxvYWQudmFsdWUgPSBvdXRwdXQyO1xuICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBwYXlsb2FkLnZhbHVlID0gb3V0cHV0O1xuICAgIHJldHVybiBwYXlsb2FkO1xuICB9O1xufSk7XG5mdW5jdGlvbiB0cmFuc2Zvcm0oZm4pIHtcbiAgcmV0dXJuIG5ldyBab2RUcmFuc2Zvcm0oe1xuICAgIHR5cGU6IFwidHJhbnNmb3JtXCIsXG4gICAgdHJhbnNmb3JtOiBmblxuICB9KTtcbn1cbnZhciBab2RPcHRpb25hbCA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCJab2RPcHRpb25hbFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICRab2RPcHRpb25hbC5pbml0KGluc3QsIGRlZik7XG4gIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICBpbnN0LnVud3JhcCA9ICgpID0+IGluc3QuX3pvZC5kZWYuaW5uZXJUeXBlO1xufSk7XG5mdW5jdGlvbiBvcHRpb25hbChpbm5lclR5cGUpIHtcbiAgcmV0dXJuIG5ldyBab2RPcHRpb25hbCh7XG4gICAgdHlwZTogXCJvcHRpb25hbFwiLFxuICAgIGlubmVyVHlwZVxuICB9KTtcbn1cbnZhciBab2ROdWxsYWJsZSA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCJab2ROdWxsYWJsZVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICRab2ROdWxsYWJsZS5pbml0KGluc3QsIGRlZik7XG4gIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICBpbnN0LnVud3JhcCA9ICgpID0+IGluc3QuX3pvZC5kZWYuaW5uZXJUeXBlO1xufSk7XG5mdW5jdGlvbiBudWxsYWJsZShpbm5lclR5cGUpIHtcbiAgcmV0dXJuIG5ldyBab2ROdWxsYWJsZSh7XG4gICAgdHlwZTogXCJudWxsYWJsZVwiLFxuICAgIGlubmVyVHlwZVxuICB9KTtcbn1cbnZhciBab2REZWZhdWx0ID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIlpvZERlZmF1bHRcIiwgKGluc3QsIGRlZikgPT4ge1xuICAkWm9kRGVmYXVsdC5pbml0KGluc3QsIGRlZik7XG4gIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICBpbnN0LnVud3JhcCA9ICgpID0+IGluc3QuX3pvZC5kZWYuaW5uZXJUeXBlO1xuICBpbnN0LnJlbW92ZURlZmF1bHQgPSBpbnN0LnVud3JhcDtcbn0pO1xuZnVuY3Rpb24gX2RlZmF1bHQoaW5uZXJUeXBlLCBkZWZhdWx0VmFsdWUpIHtcbiAgcmV0dXJuIG5ldyBab2REZWZhdWx0KHtcbiAgICB0eXBlOiBcImRlZmF1bHRcIixcbiAgICBpbm5lclR5cGUsXG4gICAgZ2V0IGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgZGVmYXVsdFZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBkZWZhdWx0VmFsdWUoKSA6IGRlZmF1bHRWYWx1ZTtcbiAgICB9XG4gIH0pO1xufVxudmFyIFpvZFByZWZhdWx0ID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIlpvZFByZWZhdWx0XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgJFpvZFByZWZhdWx0LmluaXQoaW5zdCwgZGVmKTtcbiAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gIGluc3QudW53cmFwID0gKCkgPT4gaW5zdC5fem9kLmRlZi5pbm5lclR5cGU7XG59KTtcbmZ1bmN0aW9uIHByZWZhdWx0KGlubmVyVHlwZSwgZGVmYXVsdFZhbHVlKSB7XG4gIHJldHVybiBuZXcgWm9kUHJlZmF1bHQoe1xuICAgIHR5cGU6IFwicHJlZmF1bHRcIixcbiAgICBpbm5lclR5cGUsXG4gICAgZ2V0IGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgZGVmYXVsdFZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBkZWZhdWx0VmFsdWUoKSA6IGRlZmF1bHRWYWx1ZTtcbiAgICB9XG4gIH0pO1xufVxudmFyIFpvZE5vbk9wdGlvbmFsID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIlpvZE5vbk9wdGlvbmFsXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgJFpvZE5vbk9wdGlvbmFsLmluaXQoaW5zdCwgZGVmKTtcbiAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gIGluc3QudW53cmFwID0gKCkgPT4gaW5zdC5fem9kLmRlZi5pbm5lclR5cGU7XG59KTtcbmZ1bmN0aW9uIG5vbm9wdGlvbmFsKGlubmVyVHlwZSwgcGFyYW1zKSB7XG4gIHJldHVybiBuZXcgWm9kTm9uT3B0aW9uYWwoe1xuICAgIHR5cGU6IFwibm9ub3B0aW9uYWxcIixcbiAgICBpbm5lclR5cGUsXG4gICAgLi4udXRpbF9leHBvcnRzLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpXG4gIH0pO1xufVxudmFyIFpvZENhdGNoID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIlpvZENhdGNoXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgJFpvZENhdGNoLmluaXQoaW5zdCwgZGVmKTtcbiAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gIGluc3QudW53cmFwID0gKCkgPT4gaW5zdC5fem9kLmRlZi5pbm5lclR5cGU7XG4gIGluc3QucmVtb3ZlQ2F0Y2ggPSBpbnN0LnVud3JhcDtcbn0pO1xuZnVuY3Rpb24gX2NhdGNoKGlubmVyVHlwZSwgY2F0Y2hWYWx1ZSkge1xuICByZXR1cm4gbmV3IFpvZENhdGNoKHtcbiAgICB0eXBlOiBcImNhdGNoXCIsXG4gICAgaW5uZXJUeXBlLFxuICAgIGNhdGNoVmFsdWU6IHR5cGVvZiBjYXRjaFZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBjYXRjaFZhbHVlIDogKCkgPT4gY2F0Y2hWYWx1ZVxuICB9KTtcbn1cbnZhciBab2RQaXBlID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIlpvZFBpcGVcIiwgKGluc3QsIGRlZikgPT4ge1xuICAkWm9kUGlwZS5pbml0KGluc3QsIGRlZik7XG4gIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICBpbnN0LmluID0gZGVmLmluO1xuICBpbnN0Lm91dCA9IGRlZi5vdXQ7XG59KTtcbmZ1bmN0aW9uIHBpcGUoaW5fLCBvdXQpIHtcbiAgcmV0dXJuIG5ldyBab2RQaXBlKHtcbiAgICB0eXBlOiBcInBpcGVcIixcbiAgICBpbjogaW5fLFxuICAgIG91dFxuICAgIC8vIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gIH0pO1xufVxudmFyIFpvZFJlYWRvbmx5ID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIlpvZFJlYWRvbmx5XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgJFpvZFJlYWRvbmx5LmluaXQoaW5zdCwgZGVmKTtcbiAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG59KTtcbmZ1bmN0aW9uIHJlYWRvbmx5KGlubmVyVHlwZSkge1xuICByZXR1cm4gbmV3IFpvZFJlYWRvbmx5KHtcbiAgICB0eXBlOiBcInJlYWRvbmx5XCIsXG4gICAgaW5uZXJUeXBlXG4gIH0pO1xufVxudmFyIFpvZEN1c3RvbSA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCJab2RDdXN0b21cIiwgKGluc3QsIGRlZikgPT4ge1xuICAkWm9kQ3VzdG9tLmluaXQoaW5zdCwgZGVmKTtcbiAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG59KTtcbmZ1bmN0aW9uIGNoZWNrKGZuKSB7XG4gIGNvbnN0IGNoID0gbmV3ICRab2RDaGVjayh7XG4gICAgY2hlY2s6IFwiY3VzdG9tXCJcbiAgICAvLyAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICB9KTtcbiAgY2guX3pvZC5jaGVjayA9IGZuO1xuICByZXR1cm4gY2g7XG59XG5mdW5jdGlvbiByZWZpbmUoZm4sIF9wYXJhbXMgPSB7fSkge1xuICByZXR1cm4gX3JlZmluZShab2RDdXN0b20sIGZuLCBfcGFyYW1zKTtcbn1cbmZ1bmN0aW9uIHN1cGVyUmVmaW5lKGZuKSB7XG4gIGNvbnN0IGNoID0gY2hlY2soKHBheWxvYWQpID0+IHtcbiAgICBwYXlsb2FkLmFkZElzc3VlID0gKGlzc3VlMikgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBpc3N1ZTIgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh1dGlsX2V4cG9ydHMuaXNzdWUoaXNzdWUyLCBwYXlsb2FkLnZhbHVlLCBjaC5fem9kLmRlZikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgX2lzc3VlID0gaXNzdWUyO1xuICAgICAgICBpZiAoX2lzc3VlLmZhdGFsKVxuICAgICAgICAgIF9pc3N1ZS5jb250aW51ZSA9IGZhbHNlO1xuICAgICAgICBfaXNzdWUuY29kZSA/PyAoX2lzc3VlLmNvZGUgPSBcImN1c3RvbVwiKTtcbiAgICAgICAgX2lzc3VlLmlucHV0ID8/IChfaXNzdWUuaW5wdXQgPSBwYXlsb2FkLnZhbHVlKTtcbiAgICAgICAgX2lzc3VlLmluc3QgPz8gKF9pc3N1ZS5pbnN0ID0gY2gpO1xuICAgICAgICBfaXNzdWUuY29udGludWUgPz8gKF9pc3N1ZS5jb250aW51ZSA9ICFjaC5fem9kLmRlZi5hYm9ydCk7XG4gICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2godXRpbF9leHBvcnRzLmlzc3VlKF9pc3N1ZSkpO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGZuKHBheWxvYWQudmFsdWUsIHBheWxvYWQpO1xuICB9KTtcbiAgcmV0dXJuIGNoO1xufVxuXG4vLyBzcmMvb3BlbmFwaS50c1xudmFyIHBhdGhzID0ge307XG5mdW5jdGlvbiBnZXRUeXBlRnJvbVpvZFR5cGUoem9kVHlwZSkge1xuICBzd2l0Y2ggKHpvZFR5cGUuY29uc3RydWN0b3IubmFtZSkge1xuICAgIGNhc2UgXCJab2RTdHJpbmdcIjpcbiAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgIGNhc2UgXCJab2ROdW1iZXJcIjpcbiAgICAgIHJldHVybiBcIm51bWJlclwiO1xuICAgIGNhc2UgXCJab2RCb29sZWFuXCI6XG4gICAgICByZXR1cm4gXCJib29sZWFuXCI7XG4gICAgY2FzZSBcIlpvZE9iamVjdFwiOlxuICAgICAgcmV0dXJuIFwib2JqZWN0XCI7XG4gICAgY2FzZSBcIlpvZEFycmF5XCI6XG4gICAgICByZXR1cm4gXCJhcnJheVwiO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0UGFyYW1ldGVycyhvcHRpb25zKSB7XG4gIGNvbnN0IHBhcmFtZXRlcnMgPSBbXTtcbiAgaWYgKG9wdGlvbnMubWV0YWRhdGE/Lm9wZW5hcGk/LnBhcmFtZXRlcnMpIHtcbiAgICBwYXJhbWV0ZXJzLnB1c2goLi4ub3B0aW9ucy5tZXRhZGF0YS5vcGVuYXBpLnBhcmFtZXRlcnMpO1xuICAgIHJldHVybiBwYXJhbWV0ZXJzO1xuICB9XG4gIGlmIChvcHRpb25zLnF1ZXJ5IGluc3RhbmNlb2YgWm9kT2JqZWN0KSB7XG4gICAgT2JqZWN0LmVudHJpZXMob3B0aW9ucy5xdWVyeS5zaGFwZSkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBab2RPYmplY3QpIHtcbiAgICAgICAgcGFyYW1ldGVycy5wdXNoKHtcbiAgICAgICAgICBuYW1lOiBrZXksXG4gICAgICAgICAgaW46IFwicXVlcnlcIixcbiAgICAgICAgICBzY2hlbWE6IHtcbiAgICAgICAgICAgIHR5cGU6IGdldFR5cGVGcm9tWm9kVHlwZSh2YWx1ZSksXG4gICAgICAgICAgICAuLi5cIm1pbkxlbmd0aFwiIGluIHZhbHVlICYmIHZhbHVlLm1pbkxlbmd0aCA/IHtcbiAgICAgICAgICAgICAgbWluTGVuZ3RoOiB2YWx1ZS5taW5MZW5ndGhcbiAgICAgICAgICAgIH0gOiB7fSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiB2YWx1ZS5kZXNjcmlwdGlvblxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHBhcmFtZXRlcnM7XG59XG5mdW5jdGlvbiBnZXRSZXF1ZXN0Qm9keShvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLm1ldGFkYXRhPy5vcGVuYXBpPy5yZXF1ZXN0Qm9keSkge1xuICAgIHJldHVybiBvcHRpb25zLm1ldGFkYXRhLm9wZW5hcGkucmVxdWVzdEJvZHk7XG4gIH1cbiAgaWYgKCFvcHRpb25zLmJvZHkpIHJldHVybiB2b2lkIDA7XG4gIGlmIChvcHRpb25zLmJvZHkgaW5zdGFuY2VvZiBab2RPYmplY3QgfHwgb3B0aW9ucy5ib2R5IGluc3RhbmNlb2YgWm9kT3B0aW9uYWwpIHtcbiAgICBjb25zdCBzaGFwZSA9IG9wdGlvbnMuYm9keS5zaGFwZTtcbiAgICBpZiAoIXNoYXBlKSByZXR1cm4gdm9pZCAwO1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7fTtcbiAgICBjb25zdCByZXF1aXJlZDIgPSBbXTtcbiAgICBPYmplY3QuZW50cmllcyhzaGFwZSkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBab2RPYmplY3QpIHtcbiAgICAgICAgcHJvcGVydGllc1trZXldID0ge1xuICAgICAgICAgIHR5cGU6IGdldFR5cGVGcm9tWm9kVHlwZSh2YWx1ZSksXG4gICAgICAgICAgZGVzY3JpcHRpb246IHZhbHVlLmRlc2NyaXB0aW9uXG4gICAgICAgIH07XG4gICAgICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgWm9kT3B0aW9uYWwpKSB7XG4gICAgICAgICAgcmVxdWlyZWQyLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICByZXF1aXJlZDogb3B0aW9ucy5ib2R5IGluc3RhbmNlb2YgWm9kT3B0aW9uYWwgPyBmYWxzZSA6IG9wdGlvbnMuYm9keSA/IHRydWUgOiBmYWxzZSxcbiAgICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgXCJhcHBsaWNhdGlvbi9qc29uXCI6IHtcbiAgICAgICAgICBzY2hlbWE6IHtcbiAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzLFxuICAgICAgICAgICAgcmVxdWlyZWQ6IHJlcXVpcmVkMlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGdldFJlc3BvbnNlKHJlc3BvbnNlcykge1xuICByZXR1cm4ge1xuICAgIFwiNDAwXCI6IHtcbiAgICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgXCJhcHBsaWNhdGlvbi9qc29uXCI6IHtcbiAgICAgICAgICBzY2hlbWE6IHtcbiAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgIG1lc3NhZ2U6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXF1aXJlZDogW1wibWVzc2FnZVwiXVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRlc2NyaXB0aW9uOiBcIkJhZCBSZXF1ZXN0LiBVc3VhbGx5IGR1ZSB0byBtaXNzaW5nIHBhcmFtZXRlcnMsIG9yIGludmFsaWQgcGFyYW1ldGVycy5cIlxuICAgIH0sXG4gICAgXCI0MDFcIjoge1xuICAgICAgY29udGVudDoge1xuICAgICAgICBcImFwcGxpY2F0aW9uL2pzb25cIjoge1xuICAgICAgICAgIHNjaGVtYToge1xuICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgbWVzc2FnZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlcXVpcmVkOiBbXCJtZXNzYWdlXCJdXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGVzY3JpcHRpb246IFwiVW5hdXRob3JpemVkLiBEdWUgdG8gbWlzc2luZyBvciBpbnZhbGlkIGF1dGhlbnRpY2F0aW9uLlwiXG4gICAgfSxcbiAgICBcIjQwM1wiOiB7XG4gICAgICBjb250ZW50OiB7XG4gICAgICAgIFwiYXBwbGljYXRpb24vanNvblwiOiB7XG4gICAgICAgICAgc2NoZW1hOiB7XG4gICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgICBtZXNzYWdlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGVzY3JpcHRpb246IFwiRm9yYmlkZGVuLiBZb3UgZG8gbm90IGhhdmUgcGVybWlzc2lvbiB0byBhY2Nlc3MgdGhpcyByZXNvdXJjZSBvciB0byBwZXJmb3JtIHRoaXMgYWN0aW9uLlwiXG4gICAgfSxcbiAgICBcIjQwNFwiOiB7XG4gICAgICBjb250ZW50OiB7XG4gICAgICAgIFwiYXBwbGljYXRpb24vanNvblwiOiB7XG4gICAgICAgICAgc2NoZW1hOiB7XG4gICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgICBtZXNzYWdlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGVzY3JpcHRpb246IFwiTm90IEZvdW5kLiBUaGUgcmVxdWVzdGVkIHJlc291cmNlIHdhcyBub3QgZm91bmQuXCJcbiAgICB9LFxuICAgIFwiNDI5XCI6IHtcbiAgICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgXCJhcHBsaWNhdGlvbi9qc29uXCI6IHtcbiAgICAgICAgICBzY2hlbWE6IHtcbiAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgIG1lc3NhZ2U6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkZXNjcmlwdGlvbjogXCJUb28gTWFueSBSZXF1ZXN0cy4gWW91IGhhdmUgZXhjZWVkZWQgdGhlIHJhdGUgbGltaXQuIFRyeSBhZ2FpbiBsYXRlci5cIlxuICAgIH0sXG4gICAgXCI1MDBcIjoge1xuICAgICAgY29udGVudDoge1xuICAgICAgICBcImFwcGxpY2F0aW9uL2pzb25cIjoge1xuICAgICAgICAgIHNjaGVtYToge1xuICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgbWVzc2FnZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRlc2NyaXB0aW9uOiBcIkludGVybmFsIFNlcnZlciBFcnJvci4gVGhpcyBpcyBhIHByb2JsZW0gd2l0aCB0aGUgc2VydmVyIHRoYXQgeW91IGNhbm5vdCBmaXguXCJcbiAgICB9LFxuICAgIC4uLnJlc3BvbnNlc1xuICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdG9yKGVuZHBvaW50cywgY29uZmlnMikge1xuICBjb25zdCBjb21wb25lbnRzID0ge1xuICAgIHNjaGVtYXM6IHt9XG4gIH07XG4gIE9iamVjdC5lbnRyaWVzKGVuZHBvaW50cykuZm9yRWFjaCgoW18sIHZhbHVlXSkgPT4ge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB2YWx1ZS5vcHRpb25zO1xuICAgIGlmIChvcHRpb25zLm1ldGFkYXRhPy5TRVJWRVJfT05MWSkgcmV0dXJuO1xuICAgIGlmIChvcHRpb25zLm1ldGhvZCA9PT0gXCJHRVRcIikge1xuICAgICAgcGF0aHNbdmFsdWUucGF0aF0gPSB7XG4gICAgICAgIGdldDoge1xuICAgICAgICAgIHRhZ3M6IFtcIkRlZmF1bHRcIiwgLi4ub3B0aW9ucy5tZXRhZGF0YT8ub3BlbmFwaT8udGFncyB8fCBbXV0sXG4gICAgICAgICAgZGVzY3JpcHRpb246IG9wdGlvbnMubWV0YWRhdGE/Lm9wZW5hcGk/LmRlc2NyaXB0aW9uLFxuICAgICAgICAgIG9wZXJhdGlvbklkOiBvcHRpb25zLm1ldGFkYXRhPy5vcGVuYXBpPy5vcGVyYXRpb25JZCxcbiAgICAgICAgICBzZWN1cml0eTogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBiZWFyZXJBdXRoOiBbXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIF0sXG4gICAgICAgICAgcGFyYW1ldGVyczogZ2V0UGFyYW1ldGVycyhvcHRpb25zKSxcbiAgICAgICAgICByZXNwb25zZXM6IGdldFJlc3BvbnNlKG9wdGlvbnMubWV0YWRhdGE/Lm9wZW5hcGk/LnJlc3BvbnNlcylcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubWV0aG9kID09PSBcIlBPU1RcIikge1xuICAgICAgY29uc3QgYm9keSA9IGdldFJlcXVlc3RCb2R5KG9wdGlvbnMpO1xuICAgICAgcGF0aHNbdmFsdWUucGF0aF0gPSB7XG4gICAgICAgIHBvc3Q6IHtcbiAgICAgICAgICB0YWdzOiBbXCJEZWZhdWx0XCIsIC4uLm9wdGlvbnMubWV0YWRhdGE/Lm9wZW5hcGk/LnRhZ3MgfHwgW11dLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBvcHRpb25zLm1ldGFkYXRhPy5vcGVuYXBpPy5kZXNjcmlwdGlvbixcbiAgICAgICAgICBvcGVyYXRpb25JZDogb3B0aW9ucy5tZXRhZGF0YT8ub3BlbmFwaT8ub3BlcmF0aW9uSWQsXG4gICAgICAgICAgc2VjdXJpdHk6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgYmVhcmVyQXV0aDogW11cbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdLFxuICAgICAgICAgIHBhcmFtZXRlcnM6IGdldFBhcmFtZXRlcnMob3B0aW9ucyksXG4gICAgICAgICAgLi4uYm9keSA/IHsgcmVxdWVzdEJvZHk6IGJvZHkgfSA6IHtcbiAgICAgICAgICAgIHJlcXVlc3RCb2R5OiB7XG4gICAgICAgICAgICAgIC8vc2V0IGJvZHkgbm9uZVxuICAgICAgICAgICAgICBjb250ZW50OiB7XG4gICAgICAgICAgICAgICAgXCJhcHBsaWNhdGlvbi9qc29uXCI6IHtcbiAgICAgICAgICAgICAgICAgIHNjaGVtYToge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB7fVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVzcG9uc2VzOiBnZXRSZXNwb25zZShvcHRpb25zLm1ldGFkYXRhPy5vcGVuYXBpPy5yZXNwb25zZXMpXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9KTtcbiAgY29uc3QgcmVzID0ge1xuICAgIG9wZW5hcGk6IFwiMy4xLjFcIixcbiAgICBpbmZvOiB7XG4gICAgICB0aXRsZTogXCJCZXR0ZXIgQXV0aFwiLFxuICAgICAgZGVzY3JpcHRpb246IFwiQVBJIFJlZmVyZW5jZSBmb3IgeW91ciBCZXR0ZXIgQXV0aCBJbnN0YW5jZVwiLFxuICAgICAgdmVyc2lvbjogXCIxLjEuMFwiXG4gICAgfSxcbiAgICBjb21wb25lbnRzLFxuICAgIHNlY3VyaXR5OiBbXG4gICAgICB7XG4gICAgICAgIGFwaUtleUNvb2tpZTogW11cbiAgICAgIH1cbiAgICBdLFxuICAgIHNlcnZlcnM6IFtcbiAgICAgIHtcbiAgICAgICAgdXJsOiBjb25maWcyPy51cmxcbiAgICAgIH1cbiAgICBdLFxuICAgIHRhZ3M6IFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJEZWZhdWx0XCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkRlZmF1bHQgZW5kcG9pbnRzIHRoYXQgYXJlIGluY2x1ZGVkIHdpdGggQmV0dGVyIEF1dGggYnkgZGVmYXVsdC4gVGhlc2UgZW5kcG9pbnRzIGFyZSBub3QgcGFydCBvZiBhbnkgcGx1Z2luLlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBwYXRoc1xuICB9O1xuICByZXR1cm4gcmVzO1xufVxudmFyIGdldEhUTUwgPSAoYXBpUmVmZXJlbmNlLCBjb25maWcyKSA9PiBgPCFkb2N0eXBlIGh0bWw+XG48aHRtbD5cbiAgPGhlYWQ+XG4gICAgPHRpdGxlPlNjYWxhciBBUEkgUmVmZXJlbmNlPC90aXRsZT5cbiAgICA8bWV0YSBjaGFyc2V0PVwidXRmLThcIiAvPlxuICAgIDxtZXRhXG4gICAgICBuYW1lPVwidmlld3BvcnRcIlxuICAgICAgY29udGVudD1cIndpZHRoPWRldmljZS13aWR0aCwgaW5pdGlhbC1zY2FsZT0xXCIgLz5cbiAgPC9oZWFkPlxuICA8Ym9keT5cbiAgICA8c2NyaXB0XG4gICAgICBpZD1cImFwaS1yZWZlcmVuY2VcIlxuICAgICAgdHlwZT1cImFwcGxpY2F0aW9uL2pzb25cIj5cbiAgICAke0pTT04uc3RyaW5naWZ5KGFwaVJlZmVyZW5jZSl9XG4gICAgPC9zY3JpcHQ+XG5cdCA8c2NyaXB0PlxuICAgICAgdmFyIGNvbmZpZ3VyYXRpb24gPSB7XG5cdCAgXHRmYXZpY29uOiAke2NvbmZpZzI/LmxvZ28gPyBgZGF0YTppbWFnZS9zdmcreG1sO3V0ZjgsJHtlbmNvZGVVUklDb21wb25lbnQoY29uZmlnMi5sb2dvKX1gIDogdm9pZCAwfSAsXG5cdCAgIFx0dGhlbWU6ICR7Y29uZmlnMj8udGhlbWUgfHwgXCJzYXR1cm5cIn0sXG4gICAgICAgIG1ldGFEYXRhOiB7XG5cdFx0XHR0aXRsZTogJHtjb25maWcyPy50aXRsZSB8fCBcIk9wZW4gQVBJIFJlZmVyZW5jZVwifSxcblx0XHRcdGRlc2NyaXB0aW9uOiAke2NvbmZpZzI/LmRlc2NyaXB0aW9uIHx8IFwiQmV0dGVyIENhbGwgT3BlbiBBUElcIn0sXG5cdFx0fVxuICAgICAgfVxuICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FwaS1yZWZlcmVuY2UnKS5kYXRhc2V0LmNvbmZpZ3VyYXRpb24gPVxuICAgICAgICBKU09OLnN0cmluZ2lmeShjb25maWd1cmF0aW9uKVxuICAgIDwvc2NyaXB0PlxuXHQgIDxzY3JpcHQgc3JjPVwiaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9Ac2NhbGFyL2FwaS1yZWZlcmVuY2VcIj48L3NjcmlwdD5cbiAgPC9ib2R5PlxuPC9odG1sPmA7XG5cbi8vIHNyYy9yb3V0ZXIudHNcbnZhciBjcmVhdGVSb3V0ZXIgPSAoZW5kcG9pbnRzLCBjb25maWcyKSA9PiB7XG4gIGlmICghY29uZmlnMj8ub3BlbmFwaT8uZGlzYWJsZWQpIHtcbiAgICBjb25zdCBvcGVuYXBpID0ge1xuICAgICAgcGF0aDogXCIvYXBpL3JlZmVyZW5jZVwiLFxuICAgICAgLi4uY29uZmlnMj8ub3BlbmFwaVxuICAgIH07XG4gICAgZW5kcG9pbnRzW1wib3BlbmFwaVwiXSA9IGNyZWF0ZUVuZHBvaW50MihcbiAgICAgIG9wZW5hcGkucGF0aCxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiXG4gICAgICB9LFxuICAgICAgYXN5bmMgKGMpID0+IHtcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gYXdhaXQgZ2VuZXJhdG9yKGVuZHBvaW50cyk7XG4gICAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UoZ2V0SFRNTChzY2hlbWEsIG9wZW5hcGkuc2NhbGFyKSwge1xuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwidGV4dC9odG1sXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICk7XG4gIH1cbiAgY29uc3Qgcm91dGVyID0gY3JlYXRlUm91M1JvdXRlcigpO1xuICBjb25zdCBtaWRkbGV3YXJlUm91dGVyID0gY3JlYXRlUm91M1JvdXRlcigpO1xuICBmb3IgKGNvbnN0IGVuZHBvaW50IG9mIE9iamVjdC52YWx1ZXMoZW5kcG9pbnRzKSkge1xuICAgIGlmICghZW5kcG9pbnQub3B0aW9ucykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChlbmRwb2ludC5vcHRpb25zPy5tZXRhZGF0YT8uU0VSVkVSX09OTFkpIGNvbnRpbnVlO1xuICAgIGNvbnN0IG1ldGhvZHMgPSBBcnJheS5pc0FycmF5KGVuZHBvaW50Lm9wdGlvbnM/Lm1ldGhvZCkgPyBlbmRwb2ludC5vcHRpb25zLm1ldGhvZCA6IFtlbmRwb2ludC5vcHRpb25zPy5tZXRob2RdO1xuICAgIGZvciAoY29uc3QgbWV0aG9kIG9mIG1ldGhvZHMpIHtcbiAgICAgIGFkZFJvdXRlKHJvdXRlciwgbWV0aG9kLCBlbmRwb2ludC5wYXRoLCBlbmRwb2ludCk7XG4gICAgfVxuICB9XG4gIGlmIChjb25maWcyPy5yb3V0ZXJNaWRkbGV3YXJlPy5sZW5ndGgpIHtcbiAgICBmb3IgKGNvbnN0IHsgcGF0aCwgbWlkZGxld2FyZSB9IG9mIGNvbmZpZzIucm91dGVyTWlkZGxld2FyZSkge1xuICAgICAgYWRkUm91dGUobWlkZGxld2FyZVJvdXRlciwgXCIqXCIsIHBhdGgsIG1pZGRsZXdhcmUpO1xuICAgIH1cbiAgfVxuICBjb25zdCBwcm9jZXNzUmVxdWVzdCA9IGFzeW5jIChyZXF1ZXN0KSA9PiB7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gICAgY29uc3QgcGF0aCA9IGNvbmZpZzI/LmJhc2VQYXRoID8gdXJsLnBhdGhuYW1lLnNwbGl0KGNvbmZpZzIuYmFzZVBhdGgpLnJlZHVjZSgoYWNjLCBjdXJyLCBpbmRleCkgPT4ge1xuICAgICAgaWYgKGluZGV4ICE9PSAwKSB7XG4gICAgICAgIGlmIChpbmRleCA+IDEpIHtcbiAgICAgICAgICBhY2MucHVzaChgJHtjb25maWcyLmJhc2VQYXRofSR7Y3Vycn1gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhY2MucHVzaChjdXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBbXSkuam9pbihcIlwiKSA6IHVybC5wYXRobmFtZTtcbiAgICBpZiAoIXBhdGg/Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7IHN0YXR1czogNDA0LCBzdGF0dXNUZXh0OiBcIk5vdCBGb3VuZFwiIH0pO1xuICAgIH1cbiAgICBjb25zdCByb3V0ZSA9IGZpbmRSb3V0ZShyb3V0ZXIsIHJlcXVlc3QubWV0aG9kLCBwYXRoKTtcbiAgICBpZiAoIXJvdXRlPy5kYXRhKSB7XG4gICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHsgc3RhdHVzOiA0MDQsIHN0YXR1c1RleHQ6IFwiTm90IEZvdW5kXCIgfSk7XG4gICAgfVxuICAgIGNvbnN0IHF1ZXJ5ID0ge307XG4gICAgdXJsLnNlYXJjaFBhcmFtcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICBpZiAoa2V5IGluIHF1ZXJ5KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHF1ZXJ5W2tleV0pKSB7XG4gICAgICAgICAgcXVlcnlba2V5XS5wdXNoKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBxdWVyeVtrZXldID0gW3F1ZXJ5W2tleV0sIHZhbHVlXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcXVlcnlba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGhhbmRsZXIgPSByb3V0ZS5kYXRhO1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICBwYXRoLFxuICAgICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgIGhlYWRlcnM6IHJlcXVlc3QuaGVhZGVycyxcbiAgICAgIHBhcmFtczogcm91dGUucGFyYW1zID8gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShyb3V0ZS5wYXJhbXMpKSA6IHt9LFxuICAgICAgcmVxdWVzdCxcbiAgICAgIGJvZHk6IGhhbmRsZXIub3B0aW9ucy5kaXNhYmxlQm9keSA/IHZvaWQgMCA6IGF3YWl0IGdldEJvZHkoaGFuZGxlci5vcHRpb25zLmNsb25lUmVxdWVzdCA/IHJlcXVlc3QuY2xvbmUoKSA6IHJlcXVlc3QpLFxuICAgICAgcXVlcnksXG4gICAgICBfZmxhZzogXCJyb3V0ZXJcIixcbiAgICAgIGFzUmVzcG9uc2U6IHRydWUsXG4gICAgICBjb250ZXh0OiBjb25maWcyPy5yb3V0ZXJDb250ZXh0XG4gICAgfTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbWlkZGxld2FyZVJvdXRlcyA9IGZpbmRBbGxSb3V0ZXMobWlkZGxld2FyZVJvdXRlciwgXCIqXCIsIHBhdGgpO1xuICAgICAgaWYgKG1pZGRsZXdhcmVSb3V0ZXM/Lmxlbmd0aCkge1xuICAgICAgICBmb3IgKGNvbnN0IHsgZGF0YTogbWlkZGxld2FyZSwgcGFyYW1zIH0gb2YgbWlkZGxld2FyZVJvdXRlcykge1xuICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IG1pZGRsZXdhcmUoe1xuICAgICAgICAgICAgLi4uY29udGV4dCxcbiAgICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgICAgIGFzUmVzcG9uc2U6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHJlcyBpbnN0YW5jZW9mIFJlc3BvbnNlKSByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGhhbmRsZXIoY29udGV4dCk7XG4gICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0FQSUVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4gdG9SZXNwb25zZShlcnJvcik7XG4gICAgICB9XG4gICAgICBjb25zb2xlLmVycm9yKGAjIFNFUlZFUl9FUlJPUjogYCwgZXJyb3IpO1xuICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7XG4gICAgICAgIHN0YXR1czogNTAwLFxuICAgICAgICBzdGF0dXNUZXh0OiBcIkludGVybmFsIFNlcnZlciBFcnJvclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIHJldHVybiB7XG4gICAgaGFuZGxlcjogYXN5bmMgKHJlcXVlc3QpID0+IHtcbiAgICAgIGNvbnN0IG9uUmVxID0gYXdhaXQgY29uZmlnMj8ub25SZXF1ZXN0Py4ocmVxdWVzdCk7XG4gICAgICBpZiAob25SZXEgaW5zdGFuY2VvZiBSZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gb25SZXE7XG4gICAgICB9XG4gICAgICBjb25zdCByZXEgPSBvblJlcSBpbnN0YW5jZW9mIFJlcXVlc3QgPyBvblJlcSA6IHJlcXVlc3Q7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCBwcm9jZXNzUmVxdWVzdChyZXEpO1xuICAgICAgY29uc3Qgb25SZXMgPSBhd2FpdCBjb25maWcyPy5vblJlc3BvbnNlPy4ocmVzKTtcbiAgICAgIGlmIChvblJlcyBpbnN0YW5jZW9mIFJlc3BvbnNlKSB7XG4gICAgICAgIHJldHVybiBvblJlcztcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXM7XG4gICAgfSxcbiAgICBlbmRwb2ludHNcbiAgfTtcbn07XG5leHBvcnQge1xuICBBUElFcnJvcixcbiAgX3N0YXR1c0NvZGUsXG4gIGNyZWF0ZUVuZHBvaW50MiBhcyBjcmVhdGVFbmRwb2ludCxcbiAgY3JlYXRlSW50ZXJuYWxDb250ZXh0LFxuICBjcmVhdGVNaWRkbGV3YXJlLFxuICBjcmVhdGVSb3V0ZXIsXG4gIGdlbmVyYXRvcixcbiAgZ2V0Q29va2llS2V5LFxuICBnZXRIVE1MLFxuICBwYXJzZUNvb2tpZXMsXG4gIHNlcmlhbGl6ZUNvb2tpZSxcbiAgc2VyaWFsaXplU2lnbmVkQ29va2llLFxuICB0b1Jlc3BvbnNlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../../node_modules/better-call/dist/index.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/better-call/dist/index.js":
/*!****************************************************!*\
  !*** ../../node_modules/better-call/dist/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   APIError: () => (/* binding */ APIError),\n/* harmony export */   _statusCode: () => (/* binding */ _statusCode),\n/* harmony export */   createEndpoint: () => (/* binding */ createEndpoint2),\n/* harmony export */   createInternalContext: () => (/* binding */ createInternalContext),\n/* harmony export */   createMiddleware: () => (/* binding */ createMiddleware),\n/* harmony export */   createRouter: () => (/* binding */ createRouter),\n/* harmony export */   generator: () => (/* binding */ generator),\n/* harmony export */   getCookieKey: () => (/* binding */ getCookieKey),\n/* harmony export */   getHTML: () => (/* binding */ getHTML),\n/* harmony export */   parseCookies: () => (/* binding */ parseCookies),\n/* harmony export */   serializeCookie: () => (/* binding */ serializeCookie),\n/* harmony export */   serializeSignedCookie: () => (/* binding */ serializeSignedCookie),\n/* harmony export */   toResponse: () => (/* binding */ toResponse)\n/* harmony export */ });\n/* harmony import */ var uncrypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uncrypto */ \"(rsc)/../../node_modules/uncrypto/dist/crypto.node.mjs\");\n/* harmony import */ var rou3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rou3 */ \"(rsc)/../../node_modules/rou3/dist/index.mjs\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/error.ts\nvar _statusCode = {\n  OK: 200,\n  CREATED: 201,\n  ACCEPTED: 202,\n  NO_CONTENT: 204,\n  MULTIPLE_CHOICES: 300,\n  MOVED_PERMANENTLY: 301,\n  FOUND: 302,\n  SEE_OTHER: 303,\n  NOT_MODIFIED: 304,\n  TEMPORARY_REDIRECT: 307,\n  BAD_REQUEST: 400,\n  UNAUTHORIZED: 401,\n  PAYMENT_REQUIRED: 402,\n  FORBIDDEN: 403,\n  NOT_FOUND: 404,\n  METHOD_NOT_ALLOWED: 405,\n  NOT_ACCEPTABLE: 406,\n  PROXY_AUTHENTICATION_REQUIRED: 407,\n  REQUEST_TIMEOUT: 408,\n  CONFLICT: 409,\n  GONE: 410,\n  LENGTH_REQUIRED: 411,\n  PRECONDITION_FAILED: 412,\n  PAYLOAD_TOO_LARGE: 413,\n  URI_TOO_LONG: 414,\n  UNSUPPORTED_MEDIA_TYPE: 415,\n  RANGE_NOT_SATISFIABLE: 416,\n  EXPECTATION_FAILED: 417,\n  \"I'M_A_TEAPOT\": 418,\n  MISDIRECTED_REQUEST: 421,\n  UNPROCESSABLE_ENTITY: 422,\n  LOCKED: 423,\n  FAILED_DEPENDENCY: 424,\n  TOO_EARLY: 425,\n  UPGRADE_REQUIRED: 426,\n  PRECONDITION_REQUIRED: 428,\n  TOO_MANY_REQUESTS: 429,\n  REQUEST_HEADER_FIELDS_TOO_LARGE: 431,\n  UNAVAILABLE_FOR_LEGAL_REASONS: 451,\n  INTERNAL_SERVER_ERROR: 500,\n  NOT_IMPLEMENTED: 501,\n  BAD_GATEWAY: 502,\n  SERVICE_UNAVAILABLE: 503,\n  GATEWAY_TIMEOUT: 504,\n  HTTP_VERSION_NOT_SUPPORTED: 505,\n  VARIANT_ALSO_NEGOTIATES: 506,\n  INSUFFICIENT_STORAGE: 507,\n  LOOP_DETECTED: 508,\n  NOT_EXTENDED: 510,\n  NETWORK_AUTHENTICATION_REQUIRED: 511\n};\nvar APIError = class extends Error {\n  constructor(status = \"INTERNAL_SERVER_ERROR\", body = void 0, headers = {}, statusCode = typeof status === \"number\" ? status : _statusCode[status]) {\n    super(body?.message);\n    this.status = status;\n    this.body = body;\n    this.headers = headers;\n    this.statusCode = statusCode;\n    this.name = \"APIError\";\n    this.status = status;\n    this.headers = headers;\n    this.statusCode = statusCode;\n    this.body = body ? {\n      code: body?.message?.toUpperCase().replace(/ /g, \"_\").replace(/[^A-Z0-9_]/g, \"\"),\n      ...body\n    } : void 0;\n    this.stack = \"\";\n  }\n};\n\n// src/utils.ts\nasync function getBody(request) {\n  const contentType = request.headers.get(\"content-type\") || \"\";\n  if (!request.body) {\n    return void 0;\n  }\n  if (contentType.includes(\"application/json\")) {\n    return await request.json();\n  }\n  if (contentType.includes(\"application/x-www-form-urlencoded\")) {\n    const formData = await request.formData();\n    const result = {};\n    formData.forEach((value, key) => {\n      result[key] = value.toString();\n    });\n    return result;\n  }\n  if (contentType.includes(\"multipart/form-data\")) {\n    const formData = await request.formData();\n    const result = {};\n    formData.forEach((value, key) => {\n      result[key] = value;\n    });\n    return result;\n  }\n  if (contentType.includes(\"text/plain\")) {\n    return await request.text();\n  }\n  if (contentType.includes(\"application/octet-stream\")) {\n    return await request.arrayBuffer();\n  }\n  if (contentType.includes(\"application/pdf\") || contentType.includes(\"image/\") || contentType.includes(\"video/\")) {\n    const blob = await request.blob();\n    return blob;\n  }\n  if (contentType.includes(\"application/stream\") || request.body instanceof ReadableStream) {\n    return request.body;\n  }\n  return await request.text();\n}\nfunction isAPIError(error) {\n  return error instanceof APIError || error?.name === \"APIError\";\n}\nfunction tryDecode(str) {\n  try {\n    return str.includes(\"%\") ? decodeURIComponent(str) : str;\n  } catch {\n    return str;\n  }\n}\n\n// src/to-response.ts\nfunction isJSONSerializable(value) {\n  if (value === void 0) {\n    return false;\n  }\n  const t = typeof value;\n  if (t === \"string\" || t === \"number\" || t === \"boolean\" || t === null) {\n    return true;\n  }\n  if (t !== \"object\") {\n    return false;\n  }\n  if (Array.isArray(value)) {\n    return true;\n  }\n  if (value.buffer) {\n    return false;\n  }\n  return value.constructor && value.constructor.name === \"Object\" || typeof value.toJSON === \"function\";\n}\nfunction safeStringify(obj, replacer, space) {\n  let id = 0;\n  const seen = /* @__PURE__ */ new WeakMap();\n  const safeReplacer = (key, value) => {\n    if (typeof value === \"bigint\") {\n      return value.toString();\n    }\n    if (typeof value === \"object\" && value !== null) {\n      if (seen.has(value)) {\n        return `[Circular ref-${seen.get(value)}]`;\n      }\n      seen.set(value, id++);\n    }\n    if (replacer) {\n      return replacer(key, value);\n    }\n    return value;\n  };\n  return JSON.stringify(obj, safeReplacer, space);\n}\nfunction isJSONResponse(value) {\n  if (!value || typeof value !== \"object\") {\n    return false;\n  }\n  return \"_flag\" in value && value._flag === \"json\";\n}\nfunction toResponse(data, init) {\n  if (data instanceof Response) {\n    if (init?.headers instanceof Headers) {\n      init.headers.forEach((value, key) => {\n        data.headers.set(key, value);\n      });\n    }\n    return data;\n  }\n  const isJSON = isJSONResponse(data);\n  if (isJSON) {\n    const body2 = data.body;\n    const routerResponse = data.routerResponse;\n    if (routerResponse instanceof Response) {\n      return routerResponse;\n    }\n    const headers2 = new Headers({\n      ...routerResponse?.headers,\n      ...data.headers,\n      ...init?.headers,\n      \"Content-Type\": \"application/json\"\n    });\n    return new Response(JSON.stringify(body2), {\n      ...routerResponse,\n      headers: headers2,\n      status: data.status ?? init?.status ?? routerResponse?.status,\n      statusText: init?.statusText ?? routerResponse?.statusText\n    });\n  }\n  if (isAPIError(data)) {\n    return toResponse(data.body, {\n      status: init?.status ?? data.statusCode,\n      statusText: data.status.toString(),\n      headers: init?.headers || data.headers\n    });\n  }\n  let body = data;\n  let headers = new Headers(init?.headers);\n  if (!data) {\n    if (data === null) {\n      body = JSON.stringify(null);\n    }\n    headers.set(\"content-type\", \"application/json\");\n  } else if (typeof data === \"string\") {\n    body = data;\n    headers.set(\"Content-Type\", \"text/plain\");\n  } else if (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) {\n    body = data;\n    headers.set(\"Content-Type\", \"application/octet-stream\");\n  } else if (data instanceof Blob) {\n    body = data;\n    headers.set(\"Content-Type\", data.type || \"application/octet-stream\");\n  } else if (data instanceof FormData) {\n    body = data;\n  } else if (data instanceof URLSearchParams) {\n    body = data;\n    headers.set(\"Content-Type\", \"application/x-www-form-urlencoded\");\n  } else if (data instanceof ReadableStream) {\n    body = data;\n    headers.set(\"Content-Type\", \"application/octet-stream\");\n  } else if (isJSONSerializable(data)) {\n    body = safeStringify(data);\n    headers.set(\"Content-Type\", \"application/json\");\n  }\n  return new Response(body, {\n    ...init,\n    headers\n  });\n}\n\n// src/validator.ts\nasync function runValidation(options, context = {}) {\n  let request = {\n    body: context.body,\n    query: context.query\n  };\n  if (options.body) {\n    const result = await options.body[\"~standard\"].validate(context.body);\n    if (result.issues) {\n      return {\n        data: null,\n        error: fromError(result.issues, \"body\")\n      };\n    }\n    request.body = result.value;\n  }\n  if (options.query) {\n    const result = await options.query[\"~standard\"].validate(context.query);\n    if (result.issues) {\n      return {\n        data: null,\n        error: fromError(result.issues, \"query\")\n      };\n    }\n    request.query = result.value;\n  }\n  if (options.requireHeaders && !context.headers) {\n    return {\n      data: null,\n      error: { message: \"Headers is required\" }\n    };\n  }\n  if (options.requireRequest && !context.request) {\n    return {\n      data: null,\n      error: { message: \"Request is required\" }\n    };\n  }\n  return {\n    data: request,\n    error: null\n  };\n}\nfunction fromError(error, validating) {\n  const errorMessages = [];\n  for (const issue2 of error) {\n    const message = issue2.message;\n    errorMessages.push(message);\n  }\n  return {\n    message: `Invalid ${validating} parameters`\n  };\n}\n\n// src/crypto.ts\n\nvar algorithm = { name: \"HMAC\", hash: \"SHA-256\" };\nvar getCryptoKey = async (secret) => {\n  const secretBuf = typeof secret === \"string\" ? new TextEncoder().encode(secret) : secret;\n  return await uncrypto__WEBPACK_IMPORTED_MODULE_0__.subtle.importKey(\"raw\", secretBuf, algorithm, false, [\"sign\", \"verify\"]);\n};\nvar verifySignature = async (base64Signature, value, secret) => {\n  try {\n    const signatureBinStr = atob(base64Signature);\n    const signature = new Uint8Array(signatureBinStr.length);\n    for (let i = 0, len = signatureBinStr.length; i < len; i++) {\n      signature[i] = signatureBinStr.charCodeAt(i);\n    }\n    return await uncrypto__WEBPACK_IMPORTED_MODULE_0__.subtle.verify(algorithm, secret, signature, new TextEncoder().encode(value));\n  } catch (e) {\n    return false;\n  }\n};\nvar makeSignature = async (value, secret) => {\n  const key = await getCryptoKey(secret);\n  const signature = await uncrypto__WEBPACK_IMPORTED_MODULE_0__.subtle.sign(algorithm.name, key, new TextEncoder().encode(value));\n  return btoa(String.fromCharCode(...new Uint8Array(signature)));\n};\nvar signCookieValue = async (value, secret) => {\n  const signature = await makeSignature(value, secret);\n  value = `${value}.${signature}`;\n  value = encodeURIComponent(value);\n  return value;\n};\n\n// src/cookies.ts\nvar getCookieKey = (key, prefix) => {\n  let finalKey = key;\n  if (prefix) {\n    if (prefix === \"secure\") {\n      finalKey = \"__Secure-\" + key;\n    } else if (prefix === \"host\") {\n      finalKey = \"__Host-\" + key;\n    } else {\n      return void 0;\n    }\n  }\n  return finalKey;\n};\nfunction parseCookies(str) {\n  if (typeof str !== \"string\") {\n    throw new TypeError(\"argument str must be a string\");\n  }\n  const cookies = /* @__PURE__ */ new Map();\n  let index = 0;\n  while (index < str.length) {\n    const eqIdx = str.indexOf(\"=\", index);\n    if (eqIdx === -1) {\n      break;\n    }\n    let endIdx = str.indexOf(\";\", index);\n    if (endIdx === -1) {\n      endIdx = str.length;\n    } else if (endIdx < eqIdx) {\n      index = str.lastIndexOf(\";\", eqIdx - 1) + 1;\n      continue;\n    }\n    const key = str.slice(index, eqIdx).trim();\n    if (!cookies.has(key)) {\n      let val = str.slice(eqIdx + 1, endIdx).trim();\n      if (val.codePointAt(0) === 34) {\n        val = val.slice(1, -1);\n      }\n      cookies.set(key, tryDecode(val));\n    }\n    index = endIdx + 1;\n  }\n  return cookies;\n}\nvar _serialize = (key, value, opt = {}) => {\n  let cookie;\n  if (opt?.prefix === \"secure\") {\n    cookie = `${`__Secure-${key}`}=${value}`;\n  } else if (opt?.prefix === \"host\") {\n    cookie = `${`__Host-${key}`}=${value}`;\n  } else {\n    cookie = `${key}=${value}`;\n  }\n  if (key.startsWith(\"__Secure-\") && !opt.secure) {\n    opt.secure = true;\n  }\n  if (key.startsWith(\"__Host-\")) {\n    if (!opt.secure) {\n      opt.secure = true;\n    }\n    if (opt.path !== \"/\") {\n      opt.path = \"/\";\n    }\n    if (opt.domain) {\n      opt.domain = void 0;\n    }\n  }\n  if (opt && typeof opt.maxAge === \"number\" && opt.maxAge >= 0) {\n    if (opt.maxAge > 3456e4) {\n      throw new Error(\n        \"Cookies Max-Age SHOULD NOT be greater than 400 days (34560000 seconds) in duration.\"\n      );\n    }\n    cookie += `; Max-Age=${Math.floor(opt.maxAge)}`;\n  }\n  if (opt.domain && opt.prefix !== \"host\") {\n    cookie += `; Domain=${opt.domain}`;\n  }\n  if (opt.path) {\n    cookie += `; Path=${opt.path}`;\n  }\n  if (opt.expires) {\n    if (opt.expires.getTime() - Date.now() > 3456e7) {\n      throw new Error(\n        \"Cookies Expires SHOULD NOT be greater than 400 days (34560000 seconds) in the future.\"\n      );\n    }\n    cookie += `; Expires=${opt.expires.toUTCString()}`;\n  }\n  if (opt.httpOnly) {\n    cookie += \"; HttpOnly\";\n  }\n  if (opt.secure) {\n    cookie += \"; Secure\";\n  }\n  if (opt.sameSite) {\n    cookie += `; SameSite=${opt.sameSite.charAt(0).toUpperCase() + opt.sameSite.slice(1)}`;\n  }\n  if (opt.partitioned) {\n    if (!opt.secure) {\n      opt.secure = true;\n    }\n    cookie += \"; Partitioned\";\n  }\n  return cookie;\n};\nvar serializeCookie = (key, value, opt) => {\n  value = encodeURIComponent(value);\n  return _serialize(key, value, opt);\n};\nvar serializeSignedCookie = async (key, value, secret, opt) => {\n  value = await signCookieValue(value, secret);\n  return _serialize(key, value, opt);\n};\n\n// src/context.ts\nvar createInternalContext = async (context, {\n  options,\n  path\n}) => {\n  const headers = new Headers();\n  const { data, error } = await runValidation(options, context);\n  if (error) {\n    throw new APIError(400, {\n      message: error.message,\n      code: \"VALIDATION_ERROR\"\n    });\n  }\n  const requestHeaders = \"headers\" in context ? context.headers instanceof Headers ? context.headers : new Headers(context.headers) : \"request\" in context && context.request instanceof Request ? context.request.headers : null;\n  const requestCookies = requestHeaders?.get(\"cookie\");\n  const parsedCookies = requestCookies ? parseCookies(requestCookies) : void 0;\n  const internalContext = {\n    ...context,\n    body: data.body,\n    query: data.query,\n    path: context.path || path,\n    context: \"context\" in context && context.context ? context.context : {},\n    returned: void 0,\n    headers: context?.headers,\n    request: context?.request,\n    params: \"params\" in context ? context.params : void 0,\n    method: context.method,\n    setHeader: (key, value) => {\n      headers.set(key, value);\n    },\n    getHeader: (key) => {\n      if (!requestHeaders) return null;\n      return requestHeaders.get(key);\n    },\n    getCookie: (key, prefix) => {\n      const finalKey = getCookieKey(key, prefix);\n      if (!finalKey) {\n        return null;\n      }\n      return parsedCookies?.get(finalKey) || null;\n    },\n    getSignedCookie: async (key, secret, prefix) => {\n      const finalKey = getCookieKey(key, prefix);\n      if (!finalKey) {\n        return null;\n      }\n      const value = parsedCookies?.get(finalKey);\n      if (!value) {\n        return null;\n      }\n      const signatureStartPos = value.lastIndexOf(\".\");\n      if (signatureStartPos < 1) {\n        return null;\n      }\n      const signedValue = value.substring(0, signatureStartPos);\n      const signature = value.substring(signatureStartPos + 1);\n      if (signature.length !== 44 || !signature.endsWith(\"=\")) {\n        return null;\n      }\n      const secretKey = await getCryptoKey(secret);\n      const isVerified = await verifySignature(signature, signedValue, secretKey);\n      return isVerified ? signedValue : false;\n    },\n    setCookie: (key, value, options2) => {\n      const cookie = serializeCookie(key, value, options2);\n      headers.append(\"set-cookie\", cookie);\n      return cookie;\n    },\n    setSignedCookie: async (key, value, secret, options2) => {\n      const cookie = await serializeSignedCookie(key, value, secret, options2);\n      headers.append(\"set-cookie\", cookie);\n      return cookie;\n    },\n    redirect: (url) => {\n      headers.set(\"location\", url);\n      return new APIError(\"FOUND\", void 0, headers);\n    },\n    error: (status, body, headers2) => {\n      return new APIError(status, body, headers2);\n    },\n    json: (json, routerResponse) => {\n      if (!context.asResponse) {\n        return json;\n      }\n      return {\n        body: routerResponse?.body || json,\n        routerResponse,\n        _flag: \"json\"\n      };\n    },\n    responseHeaders: headers\n  };\n  for (const middleware of options.use || []) {\n    const response = await middleware({\n      ...internalContext,\n      returnHeaders: true,\n      asResponse: false\n    });\n    if (response.response) {\n      Object.assign(internalContext.context, response.response);\n    }\n    if (response.headers) {\n      response.headers.forEach((value, key) => {\n        internalContext.responseHeaders.set(key, value);\n      });\n    }\n  }\n  return internalContext;\n};\n\n// src/middleware.ts\nfunction createMiddleware(optionsOrHandler, handler) {\n  const internalHandler = async (inputCtx) => {\n    const context = inputCtx;\n    const _handler = typeof optionsOrHandler === \"function\" ? optionsOrHandler : handler;\n    const options = typeof optionsOrHandler === \"function\" ? {} : optionsOrHandler;\n    const internalContext = await createInternalContext(context, {\n      options,\n      path: \"/\"\n    });\n    if (!_handler) {\n      throw new Error(\"handler must be defined\");\n    }\n    const response = await _handler(internalContext);\n    const headers = internalContext.responseHeaders;\n    return context.returnHeaders ? {\n      headers,\n      response\n    } : response;\n  };\n  internalHandler.options = typeof optionsOrHandler === \"function\" ? {} : optionsOrHandler;\n  return internalHandler;\n}\ncreateMiddleware.create = (opts) => {\n  function fn(optionsOrHandler, handler) {\n    if (typeof optionsOrHandler === \"function\") {\n      return createMiddleware(\n        {\n          use: opts?.use\n        },\n        optionsOrHandler\n      );\n    }\n    if (!handler) {\n      throw new Error(\"Middleware handler is required\");\n    }\n    const middleware = createMiddleware(\n      {\n        ...optionsOrHandler,\n        method: \"*\",\n        use: [...opts?.use || [], ...optionsOrHandler.use || []]\n      },\n      handler\n    );\n    return middleware;\n  }\n  return fn;\n};\n\n// src/endpoint.ts\nvar createEndpoint2 = (path, options, handler) => {\n  const internalHandler = async (...inputCtx) => {\n    const context = inputCtx[0] || {};\n    const internalContext = await createInternalContext(context, {\n      options,\n      path\n    });\n    const response = await handler(internalContext).catch(async (e) => {\n      if (isAPIError(e)) {\n        const onAPIError = options.onAPIError;\n        if (onAPIError) {\n          await onAPIError(e);\n        }\n        if (context.asResponse) {\n          return e;\n        }\n      }\n      throw e;\n    });\n    const headers = internalContext.responseHeaders;\n    return context.asResponse ? toResponse(response, {\n      headers\n    }) : context.returnHeaders ? {\n      headers,\n      response\n    } : response;\n  };\n  internalHandler.options = options;\n  internalHandler.path = path;\n  return internalHandler;\n};\ncreateEndpoint2.create = (opts) => {\n  return (path, options, handler) => {\n    return createEndpoint2(\n      path,\n      {\n        ...options,\n        use: [...options?.use || [], ...opts?.use || []]\n      },\n      handler\n    );\n  };\n};\n\n// src/router.ts\n\n\n// node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/core/core.js\nvar NEVER = Object.freeze({\n  status: \"aborted\"\n});\n// @__NO_SIDE_EFFECTS__\nfunction $constructor(name, initializer3, params) {\n  function init(inst, def) {\n    var _a;\n    Object.defineProperty(inst, \"_zod\", {\n      value: inst._zod ?? {},\n      enumerable: false\n    });\n    (_a = inst._zod).traits ?? (_a.traits = /* @__PURE__ */ new Set());\n    inst._zod.traits.add(name);\n    initializer3(inst, def);\n    for (const k in _.prototype) {\n      if (!(k in inst))\n        Object.defineProperty(inst, k, { value: _.prototype[k].bind(inst) });\n    }\n    inst._zod.constr = _;\n    inst._zod.def = def;\n  }\n  const Parent = params?.Parent ?? Object;\n  class Definition extends Parent {\n  }\n  Object.defineProperty(Definition, \"name\", { value: name });\n  function _(def) {\n    var _a;\n    const inst = params?.Parent ? new Definition() : this;\n    init(inst, def);\n    (_a = inst._zod).deferred ?? (_a.deferred = []);\n    for (const fn of inst._zod.deferred) {\n      fn();\n    }\n    return inst;\n  }\n  Object.defineProperty(_, \"init\", { value: init });\n  Object.defineProperty(_, Symbol.hasInstance, {\n    value: (inst) => {\n      if (params?.Parent && inst instanceof params.Parent)\n        return true;\n      return inst?._zod?.traits?.has(name);\n    }\n  });\n  Object.defineProperty(_, \"name\", { value: name });\n  return _;\n}\nvar $brand = Symbol(\"zod_brand\");\nvar $ZodAsyncError = class extends Error {\n  constructor() {\n    super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);\n  }\n};\nvar globalConfig = {};\nfunction config(newConfig) {\n  if (newConfig)\n    Object.assign(globalConfig, newConfig);\n  return globalConfig;\n}\n\n// node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/core/util.js\nvar util_exports = {};\n__export(util_exports, {\n  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES,\n  Class: () => Class,\n  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,\n  aborted: () => aborted,\n  allowsEval: () => allowsEval,\n  assert: () => assert,\n  assertEqual: () => assertEqual,\n  assertIs: () => assertIs,\n  assertNever: () => assertNever,\n  assertNotEqual: () => assertNotEqual,\n  assignProp: () => assignProp,\n  cached: () => cached,\n  captureStackTrace: () => captureStackTrace,\n  cleanEnum: () => cleanEnum,\n  cleanRegex: () => cleanRegex,\n  clone: () => clone,\n  createTransparentProxy: () => createTransparentProxy,\n  defineLazy: () => defineLazy,\n  esc: () => esc,\n  escapeRegex: () => escapeRegex,\n  extend: () => extend,\n  finalizeIssue: () => finalizeIssue,\n  floatSafeRemainder: () => floatSafeRemainder,\n  getElementAtPath: () => getElementAtPath,\n  getEnumValues: () => getEnumValues,\n  getLengthableOrigin: () => getLengthableOrigin,\n  getParsedType: () => getParsedType,\n  getSizableOrigin: () => getSizableOrigin,\n  isObject: () => isObject,\n  isPlainObject: () => isPlainObject,\n  issue: () => issue,\n  joinValues: () => joinValues,\n  jsonStringifyReplacer: () => jsonStringifyReplacer,\n  merge: () => merge,\n  normalizeParams: () => normalizeParams,\n  nullish: () => nullish,\n  numKeys: () => numKeys,\n  omit: () => omit,\n  optionalKeys: () => optionalKeys,\n  partial: () => partial,\n  pick: () => pick,\n  prefixIssues: () => prefixIssues,\n  primitiveTypes: () => primitiveTypes,\n  promiseAllObject: () => promiseAllObject,\n  propertyKeyTypes: () => propertyKeyTypes,\n  randomString: () => randomString,\n  required: () => required,\n  stringifyPrimitive: () => stringifyPrimitive,\n  unwrapMessage: () => unwrapMessage\n});\nfunction assertEqual(val) {\n  return val;\n}\nfunction assertNotEqual(val) {\n  return val;\n}\nfunction assertIs(_arg) {\n}\nfunction assertNever(_x) {\n  throw new Error();\n}\nfunction assert(_) {\n}\nfunction getEnumValues(entries) {\n  const numericValues = Object.values(entries).filter((v) => typeof v === \"number\");\n  const values = Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);\n  return values;\n}\nfunction joinValues(array2, separator = \"|\") {\n  return array2.map((val) => stringifyPrimitive(val)).join(separator);\n}\nfunction jsonStringifyReplacer(_, value) {\n  if (typeof value === \"bigint\")\n    return value.toString();\n  return value;\n}\nfunction cached(getter) {\n  const set = false;\n  return {\n    get value() {\n      if (!set) {\n        const value = getter();\n        Object.defineProperty(this, \"value\", { value });\n        return value;\n      }\n      throw new Error(\"cached value already set\");\n    }\n  };\n}\nfunction nullish(input) {\n  return input === null || input === void 0;\n}\nfunction cleanRegex(source) {\n  const start = source.startsWith(\"^\") ? 1 : 0;\n  const end = source.endsWith(\"$\") ? source.length - 1 : source.length;\n  return source.slice(start, end);\n}\nfunction floatSafeRemainder(val, step) {\n  const valDecCount = (val.toString().split(\".\")[1] || \"\").length;\n  const stepDecCount = (step.toString().split(\".\")[1] || \"\").length;\n  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\n  const valInt = Number.parseInt(val.toFixed(decCount).replace(\".\", \"\"));\n  const stepInt = Number.parseInt(step.toFixed(decCount).replace(\".\", \"\"));\n  return valInt % stepInt / 10 ** decCount;\n}\nfunction defineLazy(object, key, getter) {\n  const set = false;\n  Object.defineProperty(object, key, {\n    get() {\n      if (!set) {\n        const value = getter();\n        object[key] = value;\n        return value;\n      }\n      throw new Error(\"cached value already set\");\n    },\n    set(v) {\n      Object.defineProperty(object, key, {\n        value: v\n        // configurable: true,\n      });\n    },\n    configurable: true\n  });\n}\nfunction assignProp(target, prop, value) {\n  Object.defineProperty(target, prop, {\n    value,\n    writable: true,\n    enumerable: true,\n    configurable: true\n  });\n}\nfunction getElementAtPath(obj, path) {\n  if (!path)\n    return obj;\n  return path.reduce((acc, key) => acc?.[key], obj);\n}\nfunction promiseAllObject(promisesObj) {\n  const keys = Object.keys(promisesObj);\n  const promises = keys.map((key) => promisesObj[key]);\n  return Promise.all(promises).then((results) => {\n    const resolvedObj = {};\n    for (let i = 0; i < keys.length; i++) {\n      resolvedObj[keys[i]] = results[i];\n    }\n    return resolvedObj;\n  });\n}\nfunction randomString(length = 10) {\n  const chars = \"abcdefghijklmnopqrstuvwxyz\";\n  let str = \"\";\n  for (let i = 0; i < length; i++) {\n    str += chars[Math.floor(Math.random() * chars.length)];\n  }\n  return str;\n}\nfunction esc(str) {\n  return JSON.stringify(str);\n}\nvar captureStackTrace = Error.captureStackTrace ? Error.captureStackTrace : (..._args) => {\n};\nfunction isObject(data) {\n  return typeof data === \"object\" && data !== null && !Array.isArray(data);\n}\nvar allowsEval = cached(() => {\n  if (typeof navigator !== \"undefined\" && navigator?.userAgent?.includes(\"Cloudflare\")) {\n    return false;\n  }\n  try {\n    const F = Function;\n    new F(\"\");\n    return true;\n  } catch (_) {\n    return false;\n  }\n});\nfunction isPlainObject(o) {\n  if (isObject(o) === false)\n    return false;\n  const ctor = o.constructor;\n  if (ctor === void 0)\n    return true;\n  const prot = ctor.prototype;\n  if (isObject(prot) === false)\n    return false;\n  if (Object.prototype.hasOwnProperty.call(prot, \"isPrototypeOf\") === false) {\n    return false;\n  }\n  return true;\n}\nfunction numKeys(data) {\n  let keyCount = 0;\n  for (const key in data) {\n    if (Object.prototype.hasOwnProperty.call(data, key)) {\n      keyCount++;\n    }\n  }\n  return keyCount;\n}\nvar getParsedType = (data) => {\n  const t = typeof data;\n  switch (t) {\n    case \"undefined\":\n      return \"undefined\";\n    case \"string\":\n      return \"string\";\n    case \"number\":\n      return Number.isNaN(data) ? \"nan\" : \"number\";\n    case \"boolean\":\n      return \"boolean\";\n    case \"function\":\n      return \"function\";\n    case \"bigint\":\n      return \"bigint\";\n    case \"symbol\":\n      return \"symbol\";\n    case \"object\":\n      if (Array.isArray(data)) {\n        return \"array\";\n      }\n      if (data === null) {\n        return \"null\";\n      }\n      if (data.then && typeof data.then === \"function\" && data.catch && typeof data.catch === \"function\") {\n        return \"promise\";\n      }\n      if (typeof Map !== \"undefined\" && data instanceof Map) {\n        return \"map\";\n      }\n      if (typeof Set !== \"undefined\" && data instanceof Set) {\n        return \"set\";\n      }\n      if (typeof Date !== \"undefined\" && data instanceof Date) {\n        return \"date\";\n      }\n      if (typeof File !== \"undefined\" && data instanceof File) {\n        return \"file\";\n      }\n      return \"object\";\n    default:\n      throw new Error(`Unknown data type: ${t}`);\n  }\n};\nvar propertyKeyTypes = /* @__PURE__ */ new Set([\"string\", \"number\", \"symbol\"]);\nvar primitiveTypes = /* @__PURE__ */ new Set([\"string\", \"number\", \"bigint\", \"boolean\", \"symbol\", \"undefined\"]);\nfunction escapeRegex(str) {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\nfunction clone(inst, def, params) {\n  const cl = new inst._zod.constr(def ?? inst._zod.def);\n  if (!def || params?.parent)\n    cl._zod.parent = inst;\n  return cl;\n}\nfunction normalizeParams(_params) {\n  const params = _params;\n  if (!params)\n    return {};\n  if (typeof params === \"string\")\n    return { error: () => params };\n  if (params?.message !== void 0) {\n    if (params?.error !== void 0)\n      throw new Error(\"Cannot specify both `message` and `error` params\");\n    params.error = params.message;\n  }\n  delete params.message;\n  if (typeof params.error === \"string\")\n    return { ...params, error: () => params.error };\n  return params;\n}\nfunction createTransparentProxy(getter) {\n  let target;\n  return new Proxy({}, {\n    get(_, prop, receiver) {\n      target ?? (target = getter());\n      return Reflect.get(target, prop, receiver);\n    },\n    set(_, prop, value, receiver) {\n      target ?? (target = getter());\n      return Reflect.set(target, prop, value, receiver);\n    },\n    has(_, prop) {\n      target ?? (target = getter());\n      return Reflect.has(target, prop);\n    },\n    deleteProperty(_, prop) {\n      target ?? (target = getter());\n      return Reflect.deleteProperty(target, prop);\n    },\n    ownKeys(_) {\n      target ?? (target = getter());\n      return Reflect.ownKeys(target);\n    },\n    getOwnPropertyDescriptor(_, prop) {\n      target ?? (target = getter());\n      return Reflect.getOwnPropertyDescriptor(target, prop);\n    },\n    defineProperty(_, prop, descriptor) {\n      target ?? (target = getter());\n      return Reflect.defineProperty(target, prop, descriptor);\n    }\n  });\n}\nfunction stringifyPrimitive(value) {\n  if (typeof value === \"bigint\")\n    return value.toString() + \"n\";\n  if (typeof value === \"string\")\n    return `\"${value}\"`;\n  return `${value}`;\n}\nfunction optionalKeys(shape) {\n  return Object.keys(shape).filter((k) => {\n    return shape[k]._zod.optin === \"optional\" && shape[k]._zod.optout === \"optional\";\n  });\n}\nvar NUMBER_FORMAT_RANGES = {\n  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],\n  int32: [-2147483648, 2147483647],\n  uint32: [0, 4294967295],\n  float32: [-34028234663852886e22, 34028234663852886e22],\n  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]\n};\nvar BIGINT_FORMAT_RANGES = {\n  int64: [/* @__PURE__ */ BigInt(\"-9223372036854775808\"), /* @__PURE__ */ BigInt(\"9223372036854775807\")],\n  uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt(\"18446744073709551615\")]\n};\nfunction pick(schema, mask) {\n  const newShape = {};\n  const currDef = schema._zod.def;\n  for (const key in mask) {\n    if (!(key in currDef.shape)) {\n      throw new Error(`Unrecognized key: \"${key}\"`);\n    }\n    if (!mask[key])\n      continue;\n    newShape[key] = currDef.shape[key];\n  }\n  return clone(schema, {\n    ...schema._zod.def,\n    shape: newShape,\n    checks: []\n  });\n}\nfunction omit(schema, mask) {\n  const newShape = { ...schema._zod.def.shape };\n  const currDef = schema._zod.def;\n  for (const key in mask) {\n    if (!(key in currDef.shape)) {\n      throw new Error(`Unrecognized key: \"${key}\"`);\n    }\n    if (!mask[key])\n      continue;\n    delete newShape[key];\n  }\n  return clone(schema, {\n    ...schema._zod.def,\n    shape: newShape,\n    checks: []\n  });\n}\nfunction extend(schema, shape) {\n  if (!isPlainObject(shape)) {\n    throw new Error(\"Invalid input to extend: expected a plain object\");\n  }\n  const def = {\n    ...schema._zod.def,\n    get shape() {\n      const _shape = { ...schema._zod.def.shape, ...shape };\n      assignProp(this, \"shape\", _shape);\n      return _shape;\n    },\n    checks: []\n    // delete existing checks\n  };\n  return clone(schema, def);\n}\nfunction merge(a, b) {\n  return clone(a, {\n    ...a._zod.def,\n    get shape() {\n      const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };\n      assignProp(this, \"shape\", _shape);\n      return _shape;\n    },\n    catchall: b._zod.def.catchall,\n    checks: []\n    // delete existing checks\n  });\n}\nfunction partial(Class2, schema, mask) {\n  const oldShape = schema._zod.def.shape;\n  const shape = { ...oldShape };\n  if (mask) {\n    for (const key in mask) {\n      if (!(key in oldShape)) {\n        throw new Error(`Unrecognized key: \"${key}\"`);\n      }\n      if (!mask[key])\n        continue;\n      shape[key] = Class2 ? new Class2({\n        type: \"optional\",\n        innerType: oldShape[key]\n      }) : oldShape[key];\n    }\n  } else {\n    for (const key in oldShape) {\n      shape[key] = Class2 ? new Class2({\n        type: \"optional\",\n        innerType: oldShape[key]\n      }) : oldShape[key];\n    }\n  }\n  return clone(schema, {\n    ...schema._zod.def,\n    shape,\n    checks: []\n  });\n}\nfunction required(Class2, schema, mask) {\n  const oldShape = schema._zod.def.shape;\n  const shape = { ...oldShape };\n  if (mask) {\n    for (const key in mask) {\n      if (!(key in shape)) {\n        throw new Error(`Unrecognized key: \"${key}\"`);\n      }\n      if (!mask[key])\n        continue;\n      shape[key] = new Class2({\n        type: \"nonoptional\",\n        innerType: oldShape[key]\n      });\n    }\n  } else {\n    for (const key in oldShape) {\n      shape[key] = new Class2({\n        type: \"nonoptional\",\n        innerType: oldShape[key]\n      });\n    }\n  }\n  return clone(schema, {\n    ...schema._zod.def,\n    shape,\n    // optional: [],\n    checks: []\n  });\n}\nfunction aborted(x, startIndex = 0) {\n  for (let i = startIndex; i < x.issues.length; i++) {\n    if (x.issues[i]?.continue !== true)\n      return true;\n  }\n  return false;\n}\nfunction prefixIssues(path, issues) {\n  return issues.map((iss) => {\n    var _a;\n    (_a = iss).path ?? (_a.path = []);\n    iss.path.unshift(path);\n    return iss;\n  });\n}\nfunction unwrapMessage(message) {\n  return typeof message === \"string\" ? message : message?.message;\n}\nfunction finalizeIssue(iss, ctx, config2) {\n  const full = { ...iss, path: iss.path ?? [] };\n  if (!iss.message) {\n    const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config2.customError?.(iss)) ?? unwrapMessage(config2.localeError?.(iss)) ?? \"Invalid input\";\n    full.message = message;\n  }\n  delete full.inst;\n  delete full.continue;\n  if (!ctx?.reportInput) {\n    delete full.input;\n  }\n  return full;\n}\nfunction getSizableOrigin(input) {\n  if (input instanceof Set)\n    return \"set\";\n  if (input instanceof Map)\n    return \"map\";\n  if (input instanceof File)\n    return \"file\";\n  return \"unknown\";\n}\nfunction getLengthableOrigin(input) {\n  if (Array.isArray(input))\n    return \"array\";\n  if (typeof input === \"string\")\n    return \"string\";\n  return \"unknown\";\n}\nfunction issue(...args) {\n  const [iss, input, inst] = args;\n  if (typeof iss === \"string\") {\n    return {\n      message: iss,\n      code: \"custom\",\n      input,\n      inst\n    };\n  }\n  return { ...iss };\n}\nfunction cleanEnum(obj) {\n  return Object.entries(obj).filter(([k, _]) => {\n    return Number.isNaN(Number.parseInt(k, 10));\n  }).map((el) => el[1]);\n}\nvar Class = class {\n  constructor(..._args) {\n  }\n};\n\n// node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/core/errors.js\nvar initializer = (inst, def) => {\n  inst.name = \"$ZodError\";\n  Object.defineProperty(inst, \"_zod\", {\n    value: inst._zod,\n    enumerable: false\n  });\n  Object.defineProperty(inst, \"issues\", {\n    value: def,\n    enumerable: false\n  });\n  Object.defineProperty(inst, \"message\", {\n    get() {\n      return JSON.stringify(def, jsonStringifyReplacer, 2);\n    },\n    enumerable: true\n    // configurable: false,\n  });\n  Object.defineProperty(inst, \"toString\", {\n    value: () => inst.message,\n    enumerable: false\n  });\n};\nvar $ZodError = $constructor(\"$ZodError\", initializer);\nvar $ZodRealError = $constructor(\"$ZodError\", initializer, { Parent: Error });\nfunction flattenError(error, mapper = (issue2) => issue2.message) {\n  const fieldErrors = {};\n  const formErrors = [];\n  for (const sub of error.issues) {\n    if (sub.path.length > 0) {\n      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];\n      fieldErrors[sub.path[0]].push(mapper(sub));\n    } else {\n      formErrors.push(mapper(sub));\n    }\n  }\n  return { formErrors, fieldErrors };\n}\nfunction formatError(error, _mapper) {\n  const mapper = _mapper || function(issue2) {\n    return issue2.message;\n  };\n  const fieldErrors = { _errors: [] };\n  const processError = (error2) => {\n    for (const issue2 of error2.issues) {\n      if (issue2.code === \"invalid_union\" && issue2.errors.length) {\n        issue2.errors.map((issues) => processError({ issues }));\n      } else if (issue2.code === \"invalid_key\") {\n        processError({ issues: issue2.issues });\n      } else if (issue2.code === \"invalid_element\") {\n        processError({ issues: issue2.issues });\n      } else if (issue2.path.length === 0) {\n        fieldErrors._errors.push(mapper(issue2));\n      } else {\n        let curr = fieldErrors;\n        let i = 0;\n        while (i < issue2.path.length) {\n          const el = issue2.path[i];\n          const terminal = i === issue2.path.length - 1;\n          if (!terminal) {\n            curr[el] = curr[el] || { _errors: [] };\n          } else {\n            curr[el] = curr[el] || { _errors: [] };\n            curr[el]._errors.push(mapper(issue2));\n          }\n          curr = curr[el];\n          i++;\n        }\n      }\n    }\n  };\n  processError(error);\n  return fieldErrors;\n}\n\n// node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/core/parse.js\nvar _parse = (_Err) => (schema, value, _ctx, _params) => {\n  const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };\n  const result = schema._zod.run({ value, issues: [] }, ctx);\n  if (result instanceof Promise) {\n    throw new $ZodAsyncError();\n  }\n  if (result.issues.length) {\n    const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));\n    captureStackTrace(e, _params?.callee);\n    throw e;\n  }\n  return result.value;\n};\nvar _parseAsync = (_Err) => async (schema, value, _ctx, params) => {\n  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };\n  let result = schema._zod.run({ value, issues: [] }, ctx);\n  if (result instanceof Promise)\n    result = await result;\n  if (result.issues.length) {\n    const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));\n    captureStackTrace(e, params?.callee);\n    throw e;\n  }\n  return result.value;\n};\nvar _safeParse = (_Err) => (schema, value, _ctx) => {\n  const ctx = _ctx ? { ..._ctx, async: false } : { async: false };\n  const result = schema._zod.run({ value, issues: [] }, ctx);\n  if (result instanceof Promise) {\n    throw new $ZodAsyncError();\n  }\n  return result.issues.length ? {\n    success: false,\n    error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))\n  } : { success: true, data: result.value };\n};\nvar safeParse = /* @__PURE__ */ _safeParse($ZodRealError);\nvar _safeParseAsync = (_Err) => async (schema, value, _ctx) => {\n  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };\n  let result = schema._zod.run({ value, issues: [] }, ctx);\n  if (result instanceof Promise)\n    result = await result;\n  return result.issues.length ? {\n    success: false,\n    error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))\n  } : { success: true, data: result.value };\n};\nvar safeParseAsync = /* @__PURE__ */ _safeParseAsync($ZodRealError);\n\n// node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/core/checks.js\nvar $ZodCheck = /* @__PURE__ */ $constructor(\"$ZodCheck\", (inst, def) => {\n  var _a;\n  inst._zod ?? (inst._zod = {});\n  inst._zod.def = def;\n  (_a = inst._zod).onattach ?? (_a.onattach = []);\n});\nvar $ZodCheckMaxLength = /* @__PURE__ */ $constructor(\"$ZodCheckMaxLength\", (inst, def) => {\n  var _a;\n  $ZodCheck.init(inst, def);\n  (_a = inst._zod.def).when ?? (_a.when = (payload) => {\n    const val = payload.value;\n    return !nullish(val) && val.length !== void 0;\n  });\n  inst._zod.onattach.push((inst2) => {\n    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;\n    if (def.maximum < curr)\n      inst2._zod.bag.maximum = def.maximum;\n  });\n  inst._zod.check = (payload) => {\n    const input = payload.value;\n    const length = input.length;\n    if (length <= def.maximum)\n      return;\n    const origin = getLengthableOrigin(input);\n    payload.issues.push({\n      origin,\n      code: \"too_big\",\n      maximum: def.maximum,\n      inclusive: true,\n      input,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCheckMinLength = /* @__PURE__ */ $constructor(\"$ZodCheckMinLength\", (inst, def) => {\n  var _a;\n  $ZodCheck.init(inst, def);\n  (_a = inst._zod.def).when ?? (_a.when = (payload) => {\n    const val = payload.value;\n    return !nullish(val) && val.length !== void 0;\n  });\n  inst._zod.onattach.push((inst2) => {\n    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;\n    if (def.minimum > curr)\n      inst2._zod.bag.minimum = def.minimum;\n  });\n  inst._zod.check = (payload) => {\n    const input = payload.value;\n    const length = input.length;\n    if (length >= def.minimum)\n      return;\n    const origin = getLengthableOrigin(input);\n    payload.issues.push({\n      origin,\n      code: \"too_small\",\n      minimum: def.minimum,\n      inclusive: true,\n      input,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCheckLengthEquals = /* @__PURE__ */ $constructor(\"$ZodCheckLengthEquals\", (inst, def) => {\n  var _a;\n  $ZodCheck.init(inst, def);\n  (_a = inst._zod.def).when ?? (_a.when = (payload) => {\n    const val = payload.value;\n    return !nullish(val) && val.length !== void 0;\n  });\n  inst._zod.onattach.push((inst2) => {\n    const bag = inst2._zod.bag;\n    bag.minimum = def.length;\n    bag.maximum = def.length;\n    bag.length = def.length;\n  });\n  inst._zod.check = (payload) => {\n    const input = payload.value;\n    const length = input.length;\n    if (length === def.length)\n      return;\n    const origin = getLengthableOrigin(input);\n    const tooBig = length > def.length;\n    payload.issues.push({\n      origin,\n      ...tooBig ? { code: \"too_big\", maximum: def.length } : { code: \"too_small\", minimum: def.length },\n      inclusive: true,\n      exact: true,\n      input: payload.value,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCheckOverwrite = /* @__PURE__ */ $constructor(\"$ZodCheckOverwrite\", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  inst._zod.check = (payload) => {\n    payload.value = def.tx(payload.value);\n  };\n});\n\n// node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/core/doc.js\nvar Doc = class {\n  constructor(args = []) {\n    this.content = [];\n    this.indent = 0;\n    if (this)\n      this.args = args;\n  }\n  indented(fn) {\n    this.indent += 1;\n    fn(this);\n    this.indent -= 1;\n  }\n  write(arg) {\n    if (typeof arg === \"function\") {\n      arg(this, { execution: \"sync\" });\n      arg(this, { execution: \"async\" });\n      return;\n    }\n    const content = arg;\n    const lines = content.split(\"\\n\").filter((x) => x);\n    const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));\n    const dedented = lines.map((x) => x.slice(minIndent)).map((x) => \" \".repeat(this.indent * 2) + x);\n    for (const line of dedented) {\n      this.content.push(line);\n    }\n  }\n  compile() {\n    const F = Function;\n    const args = this?.args;\n    const content = this?.content ?? [``];\n    const lines = [...content.map((x) => `  ${x}`)];\n    return new F(...args, lines.join(\"\\n\"));\n  }\n};\n\n// node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/core/versions.js\nvar version = {\n  major: 4,\n  minor: 0,\n  patch: 0\n};\n\n// node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/core/schemas.js\nvar $ZodType = /* @__PURE__ */ $constructor(\"$ZodType\", (inst, def) => {\n  var _a;\n  inst ?? (inst = {});\n  inst._zod.def = def;\n  inst._zod.bag = inst._zod.bag || {};\n  inst._zod.version = version;\n  const checks = [...inst._zod.def.checks ?? []];\n  if (inst._zod.traits.has(\"$ZodCheck\")) {\n    checks.unshift(inst);\n  }\n  for (const ch of checks) {\n    for (const fn of ch._zod.onattach) {\n      fn(inst);\n    }\n  }\n  if (checks.length === 0) {\n    (_a = inst._zod).deferred ?? (_a.deferred = []);\n    inst._zod.deferred?.push(() => {\n      inst._zod.run = inst._zod.parse;\n    });\n  } else {\n    const runChecks = (payload, checks2, ctx) => {\n      let isAborted = aborted(payload);\n      let asyncResult;\n      for (const ch of checks2) {\n        if (ch._zod.def.when) {\n          const shouldRun = ch._zod.def.when(payload);\n          if (!shouldRun)\n            continue;\n        } else if (isAborted) {\n          continue;\n        }\n        const currLen = payload.issues.length;\n        const _ = ch._zod.check(payload);\n        if (_ instanceof Promise && ctx?.async === false) {\n          throw new $ZodAsyncError();\n        }\n        if (asyncResult || _ instanceof Promise) {\n          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {\n            await _;\n            const nextLen = payload.issues.length;\n            if (nextLen === currLen)\n              return;\n            if (!isAborted)\n              isAborted = aborted(payload, currLen);\n          });\n        } else {\n          const nextLen = payload.issues.length;\n          if (nextLen === currLen)\n            continue;\n          if (!isAborted)\n            isAborted = aborted(payload, currLen);\n        }\n      }\n      if (asyncResult) {\n        return asyncResult.then(() => {\n          return payload;\n        });\n      }\n      return payload;\n    };\n    inst._zod.run = (payload, ctx) => {\n      const result = inst._zod.parse(payload, ctx);\n      if (result instanceof Promise) {\n        if (ctx.async === false)\n          throw new $ZodAsyncError();\n        return result.then((result2) => runChecks(result2, checks, ctx));\n      }\n      return runChecks(result, checks, ctx);\n    };\n  }\n  inst[\"~standard\"] = {\n    validate: (value) => {\n      try {\n        const r = safeParse(inst, value);\n        return r.success ? { value: r.data } : { issues: r.error?.issues };\n      } catch (_) {\n        return safeParseAsync(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });\n      }\n    },\n    vendor: \"zod\",\n    version: 1\n  };\n});\nvar $ZodUnknown = /* @__PURE__ */ $constructor(\"$ZodUnknown\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload) => payload;\n});\nvar $ZodNever = /* @__PURE__ */ $constructor(\"$ZodNever\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, _ctx) => {\n    payload.issues.push({\n      expected: \"never\",\n      code: \"invalid_type\",\n      input: payload.value,\n      inst\n    });\n    return payload;\n  };\n});\nfunction handleArrayResult(result, final, index) {\n  if (result.issues.length) {\n    final.issues.push(...prefixIssues(index, result.issues));\n  }\n  final.value[index] = result.value;\n}\nvar $ZodArray = /* @__PURE__ */ $constructor(\"$ZodArray\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, ctx) => {\n    const input = payload.value;\n    if (!Array.isArray(input)) {\n      payload.issues.push({\n        expected: \"array\",\n        code: \"invalid_type\",\n        input,\n        inst\n      });\n      return payload;\n    }\n    payload.value = Array(input.length);\n    const proms = [];\n    for (let i = 0; i < input.length; i++) {\n      const item = input[i];\n      const result = def.element._zod.run({\n        value: item,\n        issues: []\n      }, ctx);\n      if (result instanceof Promise) {\n        proms.push(result.then((result2) => handleArrayResult(result2, payload, i)));\n      } else {\n        handleArrayResult(result, payload, i);\n      }\n    }\n    if (proms.length) {\n      return Promise.all(proms).then(() => payload);\n    }\n    return payload;\n  };\n});\nfunction handleObjectResult(result, final, key) {\n  if (result.issues.length) {\n    final.issues.push(...prefixIssues(key, result.issues));\n  }\n  final.value[key] = result.value;\n}\nfunction handleOptionalObjectResult(result, final, key, input) {\n  if (result.issues.length) {\n    if (input[key] === void 0) {\n      if (key in input) {\n        final.value[key] = void 0;\n      } else {\n        final.value[key] = result.value;\n      }\n    } else {\n      final.issues.push(...prefixIssues(key, result.issues));\n    }\n  } else if (result.value === void 0) {\n    if (key in input)\n      final.value[key] = void 0;\n  } else {\n    final.value[key] = result.value;\n  }\n}\nvar $ZodObject = /* @__PURE__ */ $constructor(\"$ZodObject\", (inst, def) => {\n  $ZodType.init(inst, def);\n  const _normalized = cached(() => {\n    const keys = Object.keys(def.shape);\n    for (const k of keys) {\n      if (!(def.shape[k] instanceof $ZodType)) {\n        throw new Error(`Invalid element at key \"${k}\": expected a Zod schema`);\n      }\n    }\n    const okeys = optionalKeys(def.shape);\n    return {\n      shape: def.shape,\n      keys,\n      keySet: new Set(keys),\n      numKeys: keys.length,\n      optionalKeys: new Set(okeys)\n    };\n  });\n  defineLazy(inst._zod, \"propValues\", () => {\n    const shape = def.shape;\n    const propValues = {};\n    for (const key in shape) {\n      const field = shape[key]._zod;\n      if (field.values) {\n        propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());\n        for (const v of field.values)\n          propValues[key].add(v);\n      }\n    }\n    return propValues;\n  });\n  const generateFastpass = (shape) => {\n    const doc = new Doc([\"shape\", \"payload\", \"ctx\"]);\n    const normalized = _normalized.value;\n    const parseStr = (key) => {\n      const k = esc(key);\n      return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;\n    };\n    doc.write(`const input = payload.value;`);\n    const ids = /* @__PURE__ */ Object.create(null);\n    let counter = 0;\n    for (const key of normalized.keys) {\n      ids[key] = `key_${counter++}`;\n    }\n    doc.write(`const newResult = {}`);\n    for (const key of normalized.keys) {\n      if (normalized.optionalKeys.has(key)) {\n        const id = ids[key];\n        doc.write(`const ${id} = ${parseStr(key)};`);\n        const k = esc(key);\n        doc.write(`\n        if (${id}.issues.length) {\n          if (input[${k}] === undefined) {\n            if (${k} in input) {\n              newResult[${k}] = undefined;\n            }\n          } else {\n            payload.issues = payload.issues.concat(\n              ${id}.issues.map((iss) => ({\n                ...iss,\n                path: iss.path ? [${k}, ...iss.path] : [${k}],\n              }))\n            );\n          }\n        } else if (${id}.value === undefined) {\n          if (${k} in input) newResult[${k}] = undefined;\n        } else {\n          newResult[${k}] = ${id}.value;\n        }\n        `);\n      } else {\n        const id = ids[key];\n        doc.write(`const ${id} = ${parseStr(key)};`);\n        doc.write(`\n          if (${id}.issues.length) payload.issues = payload.issues.concat(${id}.issues.map(iss => ({\n            ...iss,\n            path: iss.path ? [${esc(key)}, ...iss.path] : [${esc(key)}]\n          })));`);\n        doc.write(`newResult[${esc(key)}] = ${id}.value`);\n      }\n    }\n    doc.write(`payload.value = newResult;`);\n    doc.write(`return payload;`);\n    const fn = doc.compile();\n    return (payload, ctx) => fn(shape, payload, ctx);\n  };\n  let fastpass;\n  const isObject2 = isObject;\n  const jit = !globalConfig.jitless;\n  const allowsEval2 = allowsEval;\n  const fastEnabled = jit && allowsEval2.value;\n  const catchall = def.catchall;\n  let value;\n  inst._zod.parse = (payload, ctx) => {\n    value ?? (value = _normalized.value);\n    const input = payload.value;\n    if (!isObject2(input)) {\n      payload.issues.push({\n        expected: \"object\",\n        code: \"invalid_type\",\n        input,\n        inst\n      });\n      return payload;\n    }\n    const proms = [];\n    if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {\n      if (!fastpass)\n        fastpass = generateFastpass(def.shape);\n      payload = fastpass(payload, ctx);\n    } else {\n      payload.value = {};\n      const shape = value.shape;\n      for (const key of value.keys) {\n        const el = shape[key];\n        const r = el._zod.run({ value: input[key], issues: [] }, ctx);\n        const isOptional = el._zod.optin === \"optional\" && el._zod.optout === \"optional\";\n        if (r instanceof Promise) {\n          proms.push(r.then((r2) => isOptional ? handleOptionalObjectResult(r2, payload, key, input) : handleObjectResult(r2, payload, key)));\n        } else if (isOptional) {\n          handleOptionalObjectResult(r, payload, key, input);\n        } else {\n          handleObjectResult(r, payload, key);\n        }\n      }\n    }\n    if (!catchall) {\n      return proms.length ? Promise.all(proms).then(() => payload) : payload;\n    }\n    const unrecognized = [];\n    const keySet = value.keySet;\n    const _catchall = catchall._zod;\n    const t = _catchall.def.type;\n    for (const key of Object.keys(input)) {\n      if (keySet.has(key))\n        continue;\n      if (t === \"never\") {\n        unrecognized.push(key);\n        continue;\n      }\n      const r = _catchall.run({ value: input[key], issues: [] }, ctx);\n      if (r instanceof Promise) {\n        proms.push(r.then((r2) => handleObjectResult(r2, payload, key)));\n      } else {\n        handleObjectResult(r, payload, key);\n      }\n    }\n    if (unrecognized.length) {\n      payload.issues.push({\n        code: \"unrecognized_keys\",\n        keys: unrecognized,\n        input,\n        inst\n      });\n    }\n    if (!proms.length)\n      return payload;\n    return Promise.all(proms).then(() => {\n      return payload;\n    });\n  };\n});\nfunction handleUnionResults(results, final, inst, ctx) {\n  for (const result of results) {\n    if (result.issues.length === 0) {\n      final.value = result.value;\n      return final;\n    }\n  }\n  final.issues.push({\n    code: \"invalid_union\",\n    input: final.value,\n    inst,\n    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))\n  });\n  return final;\n}\nvar $ZodUnion = /* @__PURE__ */ $constructor(\"$ZodUnion\", (inst, def) => {\n  $ZodType.init(inst, def);\n  defineLazy(inst._zod, \"optin\", () => def.options.some((o) => o._zod.optin === \"optional\") ? \"optional\" : void 0);\n  defineLazy(inst._zod, \"optout\", () => def.options.some((o) => o._zod.optout === \"optional\") ? \"optional\" : void 0);\n  defineLazy(inst._zod, \"values\", () => {\n    if (def.options.every((o) => o._zod.values)) {\n      return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));\n    }\n    return void 0;\n  });\n  defineLazy(inst._zod, \"pattern\", () => {\n    if (def.options.every((o) => o._zod.pattern)) {\n      const patterns = def.options.map((o) => o._zod.pattern);\n      return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join(\"|\")})$`);\n    }\n    return void 0;\n  });\n  inst._zod.parse = (payload, ctx) => {\n    let async = false;\n    const results = [];\n    for (const option of def.options) {\n      const result = option._zod.run({\n        value: payload.value,\n        issues: []\n      }, ctx);\n      if (result instanceof Promise) {\n        results.push(result);\n        async = true;\n      } else {\n        if (result.issues.length === 0)\n          return result;\n        results.push(result);\n      }\n    }\n    if (!async)\n      return handleUnionResults(results, payload, inst, ctx);\n    return Promise.all(results).then((results2) => {\n      return handleUnionResults(results2, payload, inst, ctx);\n    });\n  };\n});\nvar $ZodIntersection = /* @__PURE__ */ $constructor(\"$ZodIntersection\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, ctx) => {\n    const input = payload.value;\n    const left = def.left._zod.run({ value: input, issues: [] }, ctx);\n    const right = def.right._zod.run({ value: input, issues: [] }, ctx);\n    const async = left instanceof Promise || right instanceof Promise;\n    if (async) {\n      return Promise.all([left, right]).then(([left2, right2]) => {\n        return handleIntersectionResults(payload, left2, right2);\n      });\n    }\n    return handleIntersectionResults(payload, left, right);\n  };\n});\nfunction mergeValues(a, b) {\n  if (a === b) {\n    return { valid: true, data: a };\n  }\n  if (a instanceof Date && b instanceof Date && +a === +b) {\n    return { valid: true, data: a };\n  }\n  if (isPlainObject(a) && isPlainObject(b)) {\n    const bKeys = Object.keys(b);\n    const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);\n    const newObj = { ...a, ...b };\n    for (const key of sharedKeys) {\n      const sharedValue = mergeValues(a[key], b[key]);\n      if (!sharedValue.valid) {\n        return {\n          valid: false,\n          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]\n        };\n      }\n      newObj[key] = sharedValue.data;\n    }\n    return { valid: true, data: newObj };\n  }\n  if (Array.isArray(a) && Array.isArray(b)) {\n    if (a.length !== b.length) {\n      return { valid: false, mergeErrorPath: [] };\n    }\n    const newArray = [];\n    for (let index = 0; index < a.length; index++) {\n      const itemA = a[index];\n      const itemB = b[index];\n      const sharedValue = mergeValues(itemA, itemB);\n      if (!sharedValue.valid) {\n        return {\n          valid: false,\n          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]\n        };\n      }\n      newArray.push(sharedValue.data);\n    }\n    return { valid: true, data: newArray };\n  }\n  return { valid: false, mergeErrorPath: [] };\n}\nfunction handleIntersectionResults(result, left, right) {\n  if (left.issues.length) {\n    result.issues.push(...left.issues);\n  }\n  if (right.issues.length) {\n    result.issues.push(...right.issues);\n  }\n  if (aborted(result))\n    return result;\n  const merged = mergeValues(left.value, right.value);\n  if (!merged.valid) {\n    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);\n  }\n  result.value = merged.data;\n  return result;\n}\nvar $ZodEnum = /* @__PURE__ */ $constructor(\"$ZodEnum\", (inst, def) => {\n  $ZodType.init(inst, def);\n  const values = getEnumValues(def.entries);\n  inst._zod.values = new Set(values);\n  inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o === \"string\" ? escapeRegex(o) : o.toString()).join(\"|\")})$`);\n  inst._zod.parse = (payload, _ctx) => {\n    const input = payload.value;\n    if (inst._zod.values.has(input)) {\n      return payload;\n    }\n    payload.issues.push({\n      code: \"invalid_value\",\n      values,\n      input,\n      inst\n    });\n    return payload;\n  };\n});\nvar $ZodTransform = /* @__PURE__ */ $constructor(\"$ZodTransform\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, _ctx) => {\n    const _out = def.transform(payload.value, payload);\n    if (_ctx.async) {\n      const output = _out instanceof Promise ? _out : Promise.resolve(_out);\n      return output.then((output2) => {\n        payload.value = output2;\n        return payload;\n      });\n    }\n    if (_out instanceof Promise) {\n      throw new $ZodAsyncError();\n    }\n    payload.value = _out;\n    return payload;\n  };\n});\nvar $ZodOptional = /* @__PURE__ */ $constructor(\"$ZodOptional\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.optin = \"optional\";\n  inst._zod.optout = \"optional\";\n  defineLazy(inst._zod, \"values\", () => {\n    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, void 0]) : void 0;\n  });\n  defineLazy(inst._zod, \"pattern\", () => {\n    const pattern = def.innerType._zod.pattern;\n    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : void 0;\n  });\n  inst._zod.parse = (payload, ctx) => {\n    if (def.innerType._zod.optin === \"optional\") {\n      return def.innerType._zod.run(payload, ctx);\n    }\n    if (payload.value === void 0) {\n      return payload;\n    }\n    return def.innerType._zod.run(payload, ctx);\n  };\n});\nvar $ZodNullable = /* @__PURE__ */ $constructor(\"$ZodNullable\", (inst, def) => {\n  $ZodType.init(inst, def);\n  defineLazy(inst._zod, \"optin\", () => def.innerType._zod.optin);\n  defineLazy(inst._zod, \"optout\", () => def.innerType._zod.optout);\n  defineLazy(inst._zod, \"pattern\", () => {\n    const pattern = def.innerType._zod.pattern;\n    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : void 0;\n  });\n  defineLazy(inst._zod, \"values\", () => {\n    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, null]) : void 0;\n  });\n  inst._zod.parse = (payload, ctx) => {\n    if (payload.value === null)\n      return payload;\n    return def.innerType._zod.run(payload, ctx);\n  };\n});\nvar $ZodDefault = /* @__PURE__ */ $constructor(\"$ZodDefault\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.optin = \"optional\";\n  defineLazy(inst._zod, \"values\", () => def.innerType._zod.values);\n  inst._zod.parse = (payload, ctx) => {\n    if (payload.value === void 0) {\n      payload.value = def.defaultValue;\n      return payload;\n    }\n    const result = def.innerType._zod.run(payload, ctx);\n    if (result instanceof Promise) {\n      return result.then((result2) => handleDefaultResult(result2, def));\n    }\n    return handleDefaultResult(result, def);\n  };\n});\nfunction handleDefaultResult(payload, def) {\n  if (payload.value === void 0) {\n    payload.value = def.defaultValue;\n  }\n  return payload;\n}\nvar $ZodPrefault = /* @__PURE__ */ $constructor(\"$ZodPrefault\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.optin = \"optional\";\n  defineLazy(inst._zod, \"values\", () => def.innerType._zod.values);\n  inst._zod.parse = (payload, ctx) => {\n    if (payload.value === void 0) {\n      payload.value = def.defaultValue;\n    }\n    return def.innerType._zod.run(payload, ctx);\n  };\n});\nvar $ZodNonOptional = /* @__PURE__ */ $constructor(\"$ZodNonOptional\", (inst, def) => {\n  $ZodType.init(inst, def);\n  defineLazy(inst._zod, \"values\", () => {\n    const v = def.innerType._zod.values;\n    return v ? new Set([...v].filter((x) => x !== void 0)) : void 0;\n  });\n  inst._zod.parse = (payload, ctx) => {\n    const result = def.innerType._zod.run(payload, ctx);\n    if (result instanceof Promise) {\n      return result.then((result2) => handleNonOptionalResult(result2, inst));\n    }\n    return handleNonOptionalResult(result, inst);\n  };\n});\nfunction handleNonOptionalResult(payload, inst) {\n  if (!payload.issues.length && payload.value === void 0) {\n    payload.issues.push({\n      code: \"invalid_type\",\n      expected: \"nonoptional\",\n      input: payload.value,\n      inst\n    });\n  }\n  return payload;\n}\nvar $ZodCatch = /* @__PURE__ */ $constructor(\"$ZodCatch\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.optin = \"optional\";\n  defineLazy(inst._zod, \"optout\", () => def.innerType._zod.optout);\n  defineLazy(inst._zod, \"values\", () => def.innerType._zod.values);\n  inst._zod.parse = (payload, ctx) => {\n    const result = def.innerType._zod.run(payload, ctx);\n    if (result instanceof Promise) {\n      return result.then((result2) => {\n        payload.value = result2.value;\n        if (result2.issues.length) {\n          payload.value = def.catchValue({\n            ...payload,\n            error: {\n              issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))\n            },\n            input: payload.value\n          });\n          payload.issues = [];\n        }\n        return payload;\n      });\n    }\n    payload.value = result.value;\n    if (result.issues.length) {\n      payload.value = def.catchValue({\n        ...payload,\n        error: {\n          issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))\n        },\n        input: payload.value\n      });\n      payload.issues = [];\n    }\n    return payload;\n  };\n});\nvar $ZodPipe = /* @__PURE__ */ $constructor(\"$ZodPipe\", (inst, def) => {\n  $ZodType.init(inst, def);\n  defineLazy(inst._zod, \"values\", () => def.in._zod.values);\n  defineLazy(inst._zod, \"optin\", () => def.in._zod.optin);\n  defineLazy(inst._zod, \"optout\", () => def.out._zod.optout);\n  inst._zod.parse = (payload, ctx) => {\n    const left = def.in._zod.run(payload, ctx);\n    if (left instanceof Promise) {\n      return left.then((left2) => handlePipeResult(left2, def, ctx));\n    }\n    return handlePipeResult(left, def, ctx);\n  };\n});\nfunction handlePipeResult(left, def, ctx) {\n  if (aborted(left)) {\n    return left;\n  }\n  return def.out._zod.run({ value: left.value, issues: left.issues }, ctx);\n}\nvar $ZodReadonly = /* @__PURE__ */ $constructor(\"$ZodReadonly\", (inst, def) => {\n  $ZodType.init(inst, def);\n  defineLazy(inst._zod, \"propValues\", () => def.innerType._zod.propValues);\n  defineLazy(inst._zod, \"values\", () => def.innerType._zod.values);\n  defineLazy(inst._zod, \"optin\", () => def.innerType._zod.optin);\n  defineLazy(inst._zod, \"optout\", () => def.innerType._zod.optout);\n  inst._zod.parse = (payload, ctx) => {\n    const result = def.innerType._zod.run(payload, ctx);\n    if (result instanceof Promise) {\n      return result.then(handleReadonlyResult);\n    }\n    return handleReadonlyResult(result);\n  };\n});\nfunction handleReadonlyResult(payload) {\n  payload.value = Object.freeze(payload.value);\n  return payload;\n}\nvar $ZodCustom = /* @__PURE__ */ $constructor(\"$ZodCustom\", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, _) => {\n    return payload;\n  };\n  inst._zod.check = (payload) => {\n    const input = payload.value;\n    const r = def.fn(input);\n    if (r instanceof Promise) {\n      return r.then((r2) => handleRefineResult(r2, payload, input, inst));\n    }\n    handleRefineResult(r, payload, input, inst);\n    return;\n  };\n});\nfunction handleRefineResult(result, payload, input, inst) {\n  if (!result) {\n    const _iss = {\n      code: \"custom\",\n      input,\n      inst,\n      // incorporates params.error into issue reporting\n      path: [...inst._zod.def.path ?? []],\n      // incorporates params.error into issue reporting\n      continue: !inst._zod.def.abort\n      // params: inst._zod.def.params,\n    };\n    if (inst._zod.def.params)\n      _iss.params = inst._zod.def.params;\n    payload.issues.push(issue(_iss));\n  }\n}\n\n// node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/core/registries.js\nvar $output = Symbol(\"ZodOutput\");\nvar $input = Symbol(\"ZodInput\");\nvar $ZodRegistry = class {\n  constructor() {\n    this._map = /* @__PURE__ */ new Map();\n    this._idmap = /* @__PURE__ */ new Map();\n  }\n  add(schema, ..._meta) {\n    const meta = _meta[0];\n    this._map.set(schema, meta);\n    if (meta && typeof meta === \"object\" && \"id\" in meta) {\n      if (this._idmap.has(meta.id)) {\n        throw new Error(`ID ${meta.id} already exists in the registry`);\n      }\n      this._idmap.set(meta.id, schema);\n    }\n    return this;\n  }\n  clear() {\n    this._map = /* @__PURE__ */ new Map();\n    this._idmap = /* @__PURE__ */ new Map();\n    return this;\n  }\n  remove(schema) {\n    const meta = this._map.get(schema);\n    if (meta && typeof meta === \"object\" && \"id\" in meta) {\n      this._idmap.delete(meta.id);\n    }\n    this._map.delete(schema);\n    return this;\n  }\n  get(schema) {\n    const p = schema._zod.parent;\n    if (p) {\n      const pm = { ...this.get(p) ?? {} };\n      delete pm.id;\n      return { ...pm, ...this._map.get(schema) };\n    }\n    return this._map.get(schema);\n  }\n  has(schema) {\n    return this._map.has(schema);\n  }\n};\nfunction registry() {\n  return new $ZodRegistry();\n}\nvar globalRegistry = /* @__PURE__ */ registry();\n\n// node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/core/api.js\nfunction _unknown(Class2) {\n  return new Class2({\n    type: \"unknown\"\n  });\n}\nfunction _never(Class2, params) {\n  return new Class2({\n    type: \"never\",\n    ...normalizeParams(params)\n  });\n}\nfunction _maxLength(maximum, params) {\n  const ch = new $ZodCheckMaxLength({\n    check: \"max_length\",\n    ...normalizeParams(params),\n    maximum\n  });\n  return ch;\n}\nfunction _minLength(minimum, params) {\n  return new $ZodCheckMinLength({\n    check: \"min_length\",\n    ...normalizeParams(params),\n    minimum\n  });\n}\nfunction _length(length, params) {\n  return new $ZodCheckLengthEquals({\n    check: \"length_equals\",\n    ...normalizeParams(params),\n    length\n  });\n}\nfunction _overwrite(tx) {\n  return new $ZodCheckOverwrite({\n    check: \"overwrite\",\n    tx\n  });\n}\nfunction _array(Class2, element, params) {\n  return new Class2({\n    type: \"array\",\n    element,\n    // get element() {\n    //   return element;\n    // },\n    ...normalizeParams(params)\n  });\n}\nfunction _refine(Class2, fn, _params) {\n  const schema = new Class2({\n    type: \"custom\",\n    check: \"custom\",\n    fn,\n    ...normalizeParams(_params)\n  });\n  return schema;\n}\n\n// node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/classic/errors.js\nvar initializer2 = (inst, issues) => {\n  $ZodError.init(inst, issues);\n  inst.name = \"ZodError\";\n  Object.defineProperties(inst, {\n    format: {\n      value: (mapper) => formatError(inst, mapper)\n      // enumerable: false,\n    },\n    flatten: {\n      value: (mapper) => flattenError(inst, mapper)\n      // enumerable: false,\n    },\n    addIssue: {\n      value: (issue2) => inst.issues.push(issue2)\n      // enumerable: false,\n    },\n    addIssues: {\n      value: (issues2) => inst.issues.push(...issues2)\n      // enumerable: false,\n    },\n    isEmpty: {\n      get() {\n        return inst.issues.length === 0;\n      }\n      // enumerable: false,\n    }\n  });\n};\nvar ZodError = $constructor(\"ZodError\", initializer2);\nvar ZodRealError = $constructor(\"ZodError\", initializer2, {\n  Parent: Error\n});\n\n// node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/classic/parse.js\nvar parse = /* @__PURE__ */ _parse(ZodRealError);\nvar parseAsync = /* @__PURE__ */ _parseAsync(ZodRealError);\nvar safeParse2 = /* @__PURE__ */ _safeParse(ZodRealError);\nvar safeParseAsync2 = /* @__PURE__ */ _safeParseAsync(ZodRealError);\n\n// node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/classic/schemas.js\nvar ZodType = /* @__PURE__ */ $constructor(\"ZodType\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst.def = def;\n  Object.defineProperty(inst, \"_def\", { value: def });\n  inst.check = (...checks) => {\n    return inst.clone(\n      {\n        ...def,\n        checks: [\n          ...def.checks ?? [],\n          ...checks.map((ch) => typeof ch === \"function\" ? { _zod: { check: ch, def: { check: \"custom\" }, onattach: [] } } : ch)\n        ]\n      }\n      // { parent: true }\n    );\n  };\n  inst.clone = (def2, params) => clone(inst, def2, params);\n  inst.brand = () => inst;\n  inst.register = (reg, meta) => {\n    reg.add(inst, meta);\n    return inst;\n  };\n  inst.parse = (data, params) => parse(inst, data, params, { callee: inst.parse });\n  inst.safeParse = (data, params) => safeParse2(inst, data, params);\n  inst.parseAsync = async (data, params) => parseAsync(inst, data, params, { callee: inst.parseAsync });\n  inst.safeParseAsync = async (data, params) => safeParseAsync2(inst, data, params);\n  inst.spa = inst.safeParseAsync;\n  inst.refine = (check2, params) => inst.check(refine(check2, params));\n  inst.superRefine = (refinement) => inst.check(superRefine(refinement));\n  inst.overwrite = (fn) => inst.check(_overwrite(fn));\n  inst.optional = () => optional(inst);\n  inst.nullable = () => nullable(inst);\n  inst.nullish = () => optional(nullable(inst));\n  inst.nonoptional = (params) => nonoptional(inst, params);\n  inst.array = () => array(inst);\n  inst.or = (arg) => union([inst, arg]);\n  inst.and = (arg) => intersection(inst, arg);\n  inst.transform = (tx) => pipe(inst, transform(tx));\n  inst.default = (def2) => _default(inst, def2);\n  inst.prefault = (def2) => prefault(inst, def2);\n  inst.catch = (params) => _catch(inst, params);\n  inst.pipe = (target) => pipe(inst, target);\n  inst.readonly = () => readonly(inst);\n  inst.describe = (description) => {\n    const cl = inst.clone();\n    globalRegistry.add(cl, { description });\n    return cl;\n  };\n  Object.defineProperty(inst, \"description\", {\n    get() {\n      return globalRegistry.get(inst)?.description;\n    },\n    configurable: true\n  });\n  inst.meta = (...args) => {\n    if (args.length === 0) {\n      return globalRegistry.get(inst);\n    }\n    const cl = inst.clone();\n    globalRegistry.add(cl, args[0]);\n    return cl;\n  };\n  inst.isOptional = () => inst.safeParse(void 0).success;\n  inst.isNullable = () => inst.safeParse(null).success;\n  return inst;\n});\nvar ZodUnknown = /* @__PURE__ */ $constructor(\"ZodUnknown\", (inst, def) => {\n  $ZodUnknown.init(inst, def);\n  ZodType.init(inst, def);\n});\nfunction unknown() {\n  return _unknown(ZodUnknown);\n}\nvar ZodNever = /* @__PURE__ */ $constructor(\"ZodNever\", (inst, def) => {\n  $ZodNever.init(inst, def);\n  ZodType.init(inst, def);\n});\nfunction never(params) {\n  return _never(ZodNever, params);\n}\nvar ZodArray = /* @__PURE__ */ $constructor(\"ZodArray\", (inst, def) => {\n  $ZodArray.init(inst, def);\n  ZodType.init(inst, def);\n  inst.element = def.element;\n  inst.min = (minLength, params) => inst.check(_minLength(minLength, params));\n  inst.nonempty = (params) => inst.check(_minLength(1, params));\n  inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));\n  inst.length = (len, params) => inst.check(_length(len, params));\n  inst.unwrap = () => inst.element;\n});\nfunction array(element, params) {\n  return _array(ZodArray, element, params);\n}\nvar ZodObject = /* @__PURE__ */ $constructor(\"ZodObject\", (inst, def) => {\n  $ZodObject.init(inst, def);\n  ZodType.init(inst, def);\n  util_exports.defineLazy(inst, \"shape\", () => def.shape);\n  inst.keyof = () => _enum(Object.keys(inst._zod.def.shape));\n  inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });\n  inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });\n  inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });\n  inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });\n  inst.strip = () => inst.clone({ ...inst._zod.def, catchall: void 0 });\n  inst.extend = (incoming) => {\n    return util_exports.extend(inst, incoming);\n  };\n  inst.merge = (other) => util_exports.merge(inst, other);\n  inst.pick = (mask) => util_exports.pick(inst, mask);\n  inst.omit = (mask) => util_exports.omit(inst, mask);\n  inst.partial = (...args) => util_exports.partial(ZodOptional, inst, args[0]);\n  inst.required = (...args) => util_exports.required(ZodNonOptional, inst, args[0]);\n});\nvar ZodUnion = /* @__PURE__ */ $constructor(\"ZodUnion\", (inst, def) => {\n  $ZodUnion.init(inst, def);\n  ZodType.init(inst, def);\n  inst.options = def.options;\n});\nfunction union(options, params) {\n  return new ZodUnion({\n    type: \"union\",\n    options,\n    ...util_exports.normalizeParams(params)\n  });\n}\nvar ZodIntersection = /* @__PURE__ */ $constructor(\"ZodIntersection\", (inst, def) => {\n  $ZodIntersection.init(inst, def);\n  ZodType.init(inst, def);\n});\nfunction intersection(left, right) {\n  return new ZodIntersection({\n    type: \"intersection\",\n    left,\n    right\n  });\n}\nvar ZodEnum = /* @__PURE__ */ $constructor(\"ZodEnum\", (inst, def) => {\n  $ZodEnum.init(inst, def);\n  ZodType.init(inst, def);\n  inst.enum = def.entries;\n  inst.options = Object.values(def.entries);\n  const keys = new Set(Object.keys(def.entries));\n  inst.extract = (values, params) => {\n    const newEntries = {};\n    for (const value of values) {\n      if (keys.has(value)) {\n        newEntries[value] = def.entries[value];\n      } else\n        throw new Error(`Key ${value} not found in enum`);\n    }\n    return new ZodEnum({\n      ...def,\n      checks: [],\n      ...util_exports.normalizeParams(params),\n      entries: newEntries\n    });\n  };\n  inst.exclude = (values, params) => {\n    const newEntries = { ...def.entries };\n    for (const value of values) {\n      if (keys.has(value)) {\n        delete newEntries[value];\n      } else\n        throw new Error(`Key ${value} not found in enum`);\n    }\n    return new ZodEnum({\n      ...def,\n      checks: [],\n      ...util_exports.normalizeParams(params),\n      entries: newEntries\n    });\n  };\n});\nfunction _enum(values, params) {\n  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;\n  return new ZodEnum({\n    type: \"enum\",\n    entries,\n    ...util_exports.normalizeParams(params)\n  });\n}\nvar ZodTransform = /* @__PURE__ */ $constructor(\"ZodTransform\", (inst, def) => {\n  $ZodTransform.init(inst, def);\n  ZodType.init(inst, def);\n  inst._zod.parse = (payload, _ctx) => {\n    payload.addIssue = (issue2) => {\n      if (typeof issue2 === \"string\") {\n        payload.issues.push(util_exports.issue(issue2, payload.value, def));\n      } else {\n        const _issue = issue2;\n        if (_issue.fatal)\n          _issue.continue = false;\n        _issue.code ?? (_issue.code = \"custom\");\n        _issue.input ?? (_issue.input = payload.value);\n        _issue.inst ?? (_issue.inst = inst);\n        _issue.continue ?? (_issue.continue = true);\n        payload.issues.push(util_exports.issue(_issue));\n      }\n    };\n    const output = def.transform(payload.value, payload);\n    if (output instanceof Promise) {\n      return output.then((output2) => {\n        payload.value = output2;\n        return payload;\n      });\n    }\n    payload.value = output;\n    return payload;\n  };\n});\nfunction transform(fn) {\n  return new ZodTransform({\n    type: \"transform\",\n    transform: fn\n  });\n}\nvar ZodOptional = /* @__PURE__ */ $constructor(\"ZodOptional\", (inst, def) => {\n  $ZodOptional.init(inst, def);\n  ZodType.init(inst, def);\n  inst.unwrap = () => inst._zod.def.innerType;\n});\nfunction optional(innerType) {\n  return new ZodOptional({\n    type: \"optional\",\n    innerType\n  });\n}\nvar ZodNullable = /* @__PURE__ */ $constructor(\"ZodNullable\", (inst, def) => {\n  $ZodNullable.init(inst, def);\n  ZodType.init(inst, def);\n  inst.unwrap = () => inst._zod.def.innerType;\n});\nfunction nullable(innerType) {\n  return new ZodNullable({\n    type: \"nullable\",\n    innerType\n  });\n}\nvar ZodDefault = /* @__PURE__ */ $constructor(\"ZodDefault\", (inst, def) => {\n  $ZodDefault.init(inst, def);\n  ZodType.init(inst, def);\n  inst.unwrap = () => inst._zod.def.innerType;\n  inst.removeDefault = inst.unwrap;\n});\nfunction _default(innerType, defaultValue) {\n  return new ZodDefault({\n    type: \"default\",\n    innerType,\n    get defaultValue() {\n      return typeof defaultValue === \"function\" ? defaultValue() : defaultValue;\n    }\n  });\n}\nvar ZodPrefault = /* @__PURE__ */ $constructor(\"ZodPrefault\", (inst, def) => {\n  $ZodPrefault.init(inst, def);\n  ZodType.init(inst, def);\n  inst.unwrap = () => inst._zod.def.innerType;\n});\nfunction prefault(innerType, defaultValue) {\n  return new ZodPrefault({\n    type: \"prefault\",\n    innerType,\n    get defaultValue() {\n      return typeof defaultValue === \"function\" ? defaultValue() : defaultValue;\n    }\n  });\n}\nvar ZodNonOptional = /* @__PURE__ */ $constructor(\"ZodNonOptional\", (inst, def) => {\n  $ZodNonOptional.init(inst, def);\n  ZodType.init(inst, def);\n  inst.unwrap = () => inst._zod.def.innerType;\n});\nfunction nonoptional(innerType, params) {\n  return new ZodNonOptional({\n    type: \"nonoptional\",\n    innerType,\n    ...util_exports.normalizeParams(params)\n  });\n}\nvar ZodCatch = /* @__PURE__ */ $constructor(\"ZodCatch\", (inst, def) => {\n  $ZodCatch.init(inst, def);\n  ZodType.init(inst, def);\n  inst.unwrap = () => inst._zod.def.innerType;\n  inst.removeCatch = inst.unwrap;\n});\nfunction _catch(innerType, catchValue) {\n  return new ZodCatch({\n    type: \"catch\",\n    innerType,\n    catchValue: typeof catchValue === \"function\" ? catchValue : () => catchValue\n  });\n}\nvar ZodPipe = /* @__PURE__ */ $constructor(\"ZodPipe\", (inst, def) => {\n  $ZodPipe.init(inst, def);\n  ZodType.init(inst, def);\n  inst.in = def.in;\n  inst.out = def.out;\n});\nfunction pipe(in_, out) {\n  return new ZodPipe({\n    type: \"pipe\",\n    in: in_,\n    out\n    // ...util.normalizeParams(params),\n  });\n}\nvar ZodReadonly = /* @__PURE__ */ $constructor(\"ZodReadonly\", (inst, def) => {\n  $ZodReadonly.init(inst, def);\n  ZodType.init(inst, def);\n});\nfunction readonly(innerType) {\n  return new ZodReadonly({\n    type: \"readonly\",\n    innerType\n  });\n}\nvar ZodCustom = /* @__PURE__ */ $constructor(\"ZodCustom\", (inst, def) => {\n  $ZodCustom.init(inst, def);\n  ZodType.init(inst, def);\n});\nfunction check(fn) {\n  const ch = new $ZodCheck({\n    check: \"custom\"\n    // ...util.normalizeParams(params),\n  });\n  ch._zod.check = fn;\n  return ch;\n}\nfunction refine(fn, _params = {}) {\n  return _refine(ZodCustom, fn, _params);\n}\nfunction superRefine(fn) {\n  const ch = check((payload) => {\n    payload.addIssue = (issue2) => {\n      if (typeof issue2 === \"string\") {\n        payload.issues.push(util_exports.issue(issue2, payload.value, ch._zod.def));\n      } else {\n        const _issue = issue2;\n        if (_issue.fatal)\n          _issue.continue = false;\n        _issue.code ?? (_issue.code = \"custom\");\n        _issue.input ?? (_issue.input = payload.value);\n        _issue.inst ?? (_issue.inst = ch);\n        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);\n        payload.issues.push(util_exports.issue(_issue));\n      }\n    };\n    return fn(payload.value, payload);\n  });\n  return ch;\n}\n\n// src/openapi.ts\nvar paths = {};\nfunction getTypeFromZodType(zodType) {\n  switch (zodType.constructor.name) {\n    case \"ZodString\":\n      return \"string\";\n    case \"ZodNumber\":\n      return \"number\";\n    case \"ZodBoolean\":\n      return \"boolean\";\n    case \"ZodObject\":\n      return \"object\";\n    case \"ZodArray\":\n      return \"array\";\n    default:\n      return \"string\";\n  }\n}\nfunction getParameters(options) {\n  const parameters = [];\n  if (options.metadata?.openapi?.parameters) {\n    parameters.push(...options.metadata.openapi.parameters);\n    return parameters;\n  }\n  if (options.query instanceof ZodObject) {\n    Object.entries(options.query.shape).forEach(([key, value]) => {\n      if (value instanceof ZodObject) {\n        parameters.push({\n          name: key,\n          in: \"query\",\n          schema: {\n            type: getTypeFromZodType(value),\n            ...\"minLength\" in value && value.minLength ? {\n              minLength: value.minLength\n            } : {},\n            description: value.description\n          }\n        });\n      }\n    });\n  }\n  return parameters;\n}\nfunction getRequestBody(options) {\n  if (options.metadata?.openapi?.requestBody) {\n    return options.metadata.openapi.requestBody;\n  }\n  if (!options.body) return void 0;\n  if (options.body instanceof ZodObject || options.body instanceof ZodOptional) {\n    const shape = options.body.shape;\n    if (!shape) return void 0;\n    const properties = {};\n    const required2 = [];\n    Object.entries(shape).forEach(([key, value]) => {\n      if (value instanceof ZodObject) {\n        properties[key] = {\n          type: getTypeFromZodType(value),\n          description: value.description\n        };\n        if (!(value instanceof ZodOptional)) {\n          required2.push(key);\n        }\n      }\n    });\n    return {\n      required: options.body instanceof ZodOptional ? false : options.body ? true : false,\n      content: {\n        \"application/json\": {\n          schema: {\n            type: \"object\",\n            properties,\n            required: required2\n          }\n        }\n      }\n    };\n  }\n  return void 0;\n}\nfunction getResponse(responses) {\n  return {\n    \"400\": {\n      content: {\n        \"application/json\": {\n          schema: {\n            type: \"object\",\n            properties: {\n              message: {\n                type: \"string\"\n              }\n            },\n            required: [\"message\"]\n          }\n        }\n      },\n      description: \"Bad Request. Usually due to missing parameters, or invalid parameters.\"\n    },\n    \"401\": {\n      content: {\n        \"application/json\": {\n          schema: {\n            type: \"object\",\n            properties: {\n              message: {\n                type: \"string\"\n              }\n            },\n            required: [\"message\"]\n          }\n        }\n      },\n      description: \"Unauthorized. Due to missing or invalid authentication.\"\n    },\n    \"403\": {\n      content: {\n        \"application/json\": {\n          schema: {\n            type: \"object\",\n            properties: {\n              message: {\n                type: \"string\"\n              }\n            }\n          }\n        }\n      },\n      description: \"Forbidden. You do not have permission to access this resource or to perform this action.\"\n    },\n    \"404\": {\n      content: {\n        \"application/json\": {\n          schema: {\n            type: \"object\",\n            properties: {\n              message: {\n                type: \"string\"\n              }\n            }\n          }\n        }\n      },\n      description: \"Not Found. The requested resource was not found.\"\n    },\n    \"429\": {\n      content: {\n        \"application/json\": {\n          schema: {\n            type: \"object\",\n            properties: {\n              message: {\n                type: \"string\"\n              }\n            }\n          }\n        }\n      },\n      description: \"Too Many Requests. You have exceeded the rate limit. Try again later.\"\n    },\n    \"500\": {\n      content: {\n        \"application/json\": {\n          schema: {\n            type: \"object\",\n            properties: {\n              message: {\n                type: \"string\"\n              }\n            }\n          }\n        }\n      },\n      description: \"Internal Server Error. This is a problem with the server that you cannot fix.\"\n    },\n    ...responses\n  };\n}\nasync function generator(endpoints, config2) {\n  const components = {\n    schemas: {}\n  };\n  Object.entries(endpoints).forEach(([_, value]) => {\n    const options = value.options;\n    if (options.metadata?.SERVER_ONLY) return;\n    if (options.method === \"GET\") {\n      paths[value.path] = {\n        get: {\n          tags: [\"Default\", ...options.metadata?.openapi?.tags || []],\n          description: options.metadata?.openapi?.description,\n          operationId: options.metadata?.openapi?.operationId,\n          security: [\n            {\n              bearerAuth: []\n            }\n          ],\n          parameters: getParameters(options),\n          responses: getResponse(options.metadata?.openapi?.responses)\n        }\n      };\n    }\n    if (options.method === \"POST\") {\n      const body = getRequestBody(options);\n      paths[value.path] = {\n        post: {\n          tags: [\"Default\", ...options.metadata?.openapi?.tags || []],\n          description: options.metadata?.openapi?.description,\n          operationId: options.metadata?.openapi?.operationId,\n          security: [\n            {\n              bearerAuth: []\n            }\n          ],\n          parameters: getParameters(options),\n          ...body ? { requestBody: body } : {\n            requestBody: {\n              //set body none\n              content: {\n                \"application/json\": {\n                  schema: {\n                    type: \"object\",\n                    properties: {}\n                  }\n                }\n              }\n            }\n          },\n          responses: getResponse(options.metadata?.openapi?.responses)\n        }\n      };\n    }\n  });\n  const res = {\n    openapi: \"3.1.1\",\n    info: {\n      title: \"Better Auth\",\n      description: \"API Reference for your Better Auth Instance\",\n      version: \"1.1.0\"\n    },\n    components,\n    security: [\n      {\n        apiKeyCookie: []\n      }\n    ],\n    servers: [\n      {\n        url: config2?.url\n      }\n    ],\n    tags: [\n      {\n        name: \"Default\",\n        description: \"Default endpoints that are included with Better Auth by default. These endpoints are not part of any plugin.\"\n      }\n    ],\n    paths\n  };\n  return res;\n}\nvar getHTML = (apiReference, config2) => `<!doctype html>\n<html>\n  <head>\n    <title>Scalar API Reference</title>\n    <meta charset=\"utf-8\" />\n    <meta\n      name=\"viewport\"\n      content=\"width=device-width, initial-scale=1\" />\n  </head>\n  <body>\n    <script\n      id=\"api-reference\"\n      type=\"application/json\">\n    ${JSON.stringify(apiReference)}\n    </script>\n\t <script>\n      var configuration = {\n\t  \tfavicon: ${config2?.logo ? `data:image/svg+xml;utf8,${encodeURIComponent(config2.logo)}` : void 0} ,\n\t   \ttheme: ${config2?.theme || \"saturn\"},\n        metaData: {\n\t\t\ttitle: ${config2?.title || \"Open API Reference\"},\n\t\t\tdescription: ${config2?.description || \"Better Call Open API\"},\n\t\t}\n      }\n      document.getElementById('api-reference').dataset.configuration =\n        JSON.stringify(configuration)\n    </script>\n\t  <script src=\"https://cdn.jsdelivr.net/npm/@scalar/api-reference\"></script>\n  </body>\n</html>`;\n\n// src/router.ts\nvar createRouter = (endpoints, config2) => {\n  if (!config2?.openapi?.disabled) {\n    const openapi = {\n      path: \"/api/reference\",\n      ...config2?.openapi\n    };\n    endpoints[\"openapi\"] = createEndpoint2(\n      openapi.path,\n      {\n        method: \"GET\"\n      },\n      async (c) => {\n        const schema = await generator(endpoints);\n        return new Response(getHTML(schema, openapi.scalar), {\n          headers: {\n            \"Content-Type\": \"text/html\"\n          }\n        });\n      }\n    );\n  }\n  const router = (0,rou3__WEBPACK_IMPORTED_MODULE_1__.createRouter)();\n  const middlewareRouter = (0,rou3__WEBPACK_IMPORTED_MODULE_1__.createRouter)();\n  for (const endpoint of Object.values(endpoints)) {\n    if (!endpoint.options) {\n      continue;\n    }\n    if (endpoint.options?.metadata?.SERVER_ONLY) continue;\n    const methods = Array.isArray(endpoint.options?.method) ? endpoint.options.method : [endpoint.options?.method];\n    for (const method of methods) {\n      (0,rou3__WEBPACK_IMPORTED_MODULE_1__.addRoute)(router, method, endpoint.path, endpoint);\n    }\n  }\n  if (config2?.routerMiddleware?.length) {\n    for (const { path, middleware } of config2.routerMiddleware) {\n      (0,rou3__WEBPACK_IMPORTED_MODULE_1__.addRoute)(middlewareRouter, \"*\", path, middleware);\n    }\n  }\n  const processRequest = async (request) => {\n    const url = new URL(request.url);\n    const path = config2?.basePath ? url.pathname.split(config2.basePath).reduce((acc, curr, index) => {\n      if (index !== 0) {\n        if (index > 1) {\n          acc.push(`${config2.basePath}${curr}`);\n        } else {\n          acc.push(curr);\n        }\n      }\n      return acc;\n    }, []).join(\"\") : url.pathname;\n    if (!path?.length) {\n      return new Response(null, { status: 404, statusText: \"Not Found\" });\n    }\n    const route = (0,rou3__WEBPACK_IMPORTED_MODULE_1__.findRoute)(router, request.method, path);\n    if (!route?.data) {\n      return new Response(null, { status: 404, statusText: \"Not Found\" });\n    }\n    const query = {};\n    url.searchParams.forEach((value, key) => {\n      if (key in query) {\n        if (Array.isArray(query[key])) {\n          query[key].push(value);\n        } else {\n          query[key] = [query[key], value];\n        }\n      } else {\n        query[key] = value;\n      }\n    });\n    const handler = route.data;\n    const context = {\n      path,\n      method: request.method,\n      headers: request.headers,\n      params: route.params ? JSON.parse(JSON.stringify(route.params)) : {},\n      request,\n      body: handler.options.disableBody ? void 0 : await getBody(handler.options.cloneRequest ? request.clone() : request),\n      query,\n      _flag: \"router\",\n      asResponse: true,\n      context: config2?.routerContext\n    };\n    try {\n      const middlewareRoutes = (0,rou3__WEBPACK_IMPORTED_MODULE_1__.findAllRoutes)(middlewareRouter, \"*\", path);\n      if (middlewareRoutes?.length) {\n        for (const { data: middleware, params } of middlewareRoutes) {\n          const res = await middleware({\n            ...context,\n            params,\n            asResponse: false\n          });\n          if (res instanceof Response) return res;\n        }\n      }\n      const response = await handler(context);\n      return response;\n    } catch (error) {\n      if (isAPIError(error)) {\n        return toResponse(error);\n      }\n      console.error(`# SERVER_ERROR: `, error);\n      return new Response(null, {\n        status: 500,\n        statusText: \"Internal Server Error\"\n      });\n    }\n  };\n  return {\n    handler: async (request) => {\n      const onReq = await config2?.onRequest?.(request);\n      if (onReq instanceof Response) {\n        return onReq;\n      }\n      const req = onReq instanceof Request ? onReq : request;\n      const res = await processRequest(req);\n      const onRes = await config2?.onResponse?.(res);\n      if (onRes instanceof Response) {\n        return onRes;\n      }\n      return res;\n    },\n    endpoints\n  };\n};\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2JldHRlci1jYWxsL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLFVBQVUsY0FBYztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHdDQUF3QztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsU0FBUztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFlBQVk7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELFFBQVEsa0JBQWtCLGlCQUFpQixtQkFBbUI7QUFDM0g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELG9CQUFvQjtBQUNqRjtBQUNBLDZFQUE2RSx5QkFBeUI7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixhQUFhO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLDRCQUE0QjtBQUN6RSx3Q0FBd0MsdUNBQXVDO0FBQy9FLGtDQUFrQyx1Q0FBdUM7QUFDekUsbUNBQW1DLHFDQUFxQztBQUN4RSxrQ0FBa0Msb0NBQW9DO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUiwrQkFBK0IsT0FBTztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsK0JBQStCLE9BQU87QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsSUFBSTtBQUNsQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQyxPQUFPLGlDQUFpQyxZQUFZO0FBQ3ZHLGNBQWMsMkJBQTJCO0FBQ3pDO0FBQ0EsWUFBWSx1Q0FBdUM7QUFDbkQsa0JBQWtCLCtDQUErQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrREFBZ0I7QUFDakMsMkJBQTJCLGtEQUFnQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sOENBQVE7QUFDZDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDLE1BQU0sOENBQVE7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUIsRUFBRSxLQUFLO0FBQzlDLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGtDQUFrQyxzQ0FBc0M7QUFDeEU7QUFDQSxrQkFBa0IsK0NBQVM7QUFDM0I7QUFDQSxrQ0FBa0Msc0NBQXNDO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG1EQUFhO0FBQzVDO0FBQ0EscUJBQXFCLDJCQUEyQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFlRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvbWlsYW4vRGVza3RvcC9BcHBzL2JldHRlci1hdXRoL25vZGVfbW9kdWxlcy9iZXR0ZXItY2FsbC9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG5cbi8vIHNyYy9lcnJvci50c1xudmFyIF9zdGF0dXNDb2RlID0ge1xuICBPSzogMjAwLFxuICBDUkVBVEVEOiAyMDEsXG4gIEFDQ0VQVEVEOiAyMDIsXG4gIE5PX0NPTlRFTlQ6IDIwNCxcbiAgTVVMVElQTEVfQ0hPSUNFUzogMzAwLFxuICBNT1ZFRF9QRVJNQU5FTlRMWTogMzAxLFxuICBGT1VORDogMzAyLFxuICBTRUVfT1RIRVI6IDMwMyxcbiAgTk9UX01PRElGSUVEOiAzMDQsXG4gIFRFTVBPUkFSWV9SRURJUkVDVDogMzA3LFxuICBCQURfUkVRVUVTVDogNDAwLFxuICBVTkFVVEhPUklaRUQ6IDQwMSxcbiAgUEFZTUVOVF9SRVFVSVJFRDogNDAyLFxuICBGT1JCSURERU46IDQwMyxcbiAgTk9UX0ZPVU5EOiA0MDQsXG4gIE1FVEhPRF9OT1RfQUxMT1dFRDogNDA1LFxuICBOT1RfQUNDRVBUQUJMRTogNDA2LFxuICBQUk9YWV9BVVRIRU5USUNBVElPTl9SRVFVSVJFRDogNDA3LFxuICBSRVFVRVNUX1RJTUVPVVQ6IDQwOCxcbiAgQ09ORkxJQ1Q6IDQwOSxcbiAgR09ORTogNDEwLFxuICBMRU5HVEhfUkVRVUlSRUQ6IDQxMSxcbiAgUFJFQ09ORElUSU9OX0ZBSUxFRDogNDEyLFxuICBQQVlMT0FEX1RPT19MQVJHRTogNDEzLFxuICBVUklfVE9PX0xPTkc6IDQxNCxcbiAgVU5TVVBQT1JURURfTUVESUFfVFlQRTogNDE1LFxuICBSQU5HRV9OT1RfU0FUSVNGSUFCTEU6IDQxNixcbiAgRVhQRUNUQVRJT05fRkFJTEVEOiA0MTcsXG4gIFwiSSdNX0FfVEVBUE9UXCI6IDQxOCxcbiAgTUlTRElSRUNURURfUkVRVUVTVDogNDIxLFxuICBVTlBST0NFU1NBQkxFX0VOVElUWTogNDIyLFxuICBMT0NLRUQ6IDQyMyxcbiAgRkFJTEVEX0RFUEVOREVOQ1k6IDQyNCxcbiAgVE9PX0VBUkxZOiA0MjUsXG4gIFVQR1JBREVfUkVRVUlSRUQ6IDQyNixcbiAgUFJFQ09ORElUSU9OX1JFUVVJUkVEOiA0MjgsXG4gIFRPT19NQU5ZX1JFUVVFU1RTOiA0MjksXG4gIFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0U6IDQzMSxcbiAgVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlM6IDQ1MSxcbiAgSU5URVJOQUxfU0VSVkVSX0VSUk9SOiA1MDAsXG4gIE5PVF9JTVBMRU1FTlRFRDogNTAxLFxuICBCQURfR0FURVdBWTogNTAyLFxuICBTRVJWSUNFX1VOQVZBSUxBQkxFOiA1MDMsXG4gIEdBVEVXQVlfVElNRU9VVDogNTA0LFxuICBIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRDogNTA1LFxuICBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUzogNTA2LFxuICBJTlNVRkZJQ0lFTlRfU1RPUkFHRTogNTA3LFxuICBMT09QX0RFVEVDVEVEOiA1MDgsXG4gIE5PVF9FWFRFTkRFRDogNTEwLFxuICBORVRXT1JLX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEOiA1MTFcbn07XG52YXIgQVBJRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3Ioc3RhdHVzID0gXCJJTlRFUk5BTF9TRVJWRVJfRVJST1JcIiwgYm9keSA9IHZvaWQgMCwgaGVhZGVycyA9IHt9LCBzdGF0dXNDb2RlID0gdHlwZW9mIHN0YXR1cyA9PT0gXCJudW1iZXJcIiA/IHN0YXR1cyA6IF9zdGF0dXNDb2RlW3N0YXR1c10pIHtcbiAgICBzdXBlcihib2R5Py5tZXNzYWdlKTtcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgdGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcbiAgICB0aGlzLm5hbWUgPSBcIkFQSUVycm9yXCI7XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgdGhpcy5oZWFkZXJzID0gaGVhZGVycztcbiAgICB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuICAgIHRoaXMuYm9keSA9IGJvZHkgPyB7XG4gICAgICBjb2RlOiBib2R5Py5tZXNzYWdlPy50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoLyAvZywgXCJfXCIpLnJlcGxhY2UoL1teQS1aMC05X10vZywgXCJcIiksXG4gICAgICAuLi5ib2R5XG4gICAgfSA6IHZvaWQgMDtcbiAgICB0aGlzLnN0YWNrID0gXCJcIjtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzLnRzXG5hc3luYyBmdW5jdGlvbiBnZXRCb2R5KHJlcXVlc3QpIHtcbiAgY29uc3QgY29udGVudFR5cGUgPSByZXF1ZXN0LmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpIHx8IFwiXCI7XG4gIGlmICghcmVxdWVzdC5ib2R5KSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBpZiAoY29udGVudFR5cGUuaW5jbHVkZXMoXCJhcHBsaWNhdGlvbi9qc29uXCIpKSB7XG4gICAgcmV0dXJuIGF3YWl0IHJlcXVlc3QuanNvbigpO1xuICB9XG4gIGlmIChjb250ZW50VHlwZS5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiKSkge1xuICAgIGNvbnN0IGZvcm1EYXRhID0gYXdhaXQgcmVxdWVzdC5mb3JtRGF0YSgpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvcm1EYXRhLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGlmIChjb250ZW50VHlwZS5pbmNsdWRlcyhcIm11bHRpcGFydC9mb3JtLWRhdGFcIikpIHtcbiAgICBjb25zdCBmb3JtRGF0YSA9IGF3YWl0IHJlcXVlc3QuZm9ybURhdGEoKTtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3JtRGF0YS5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKGNvbnRlbnRUeXBlLmluY2x1ZGVzKFwidGV4dC9wbGFpblwiKSkge1xuICAgIHJldHVybiBhd2FpdCByZXF1ZXN0LnRleHQoKTtcbiAgfVxuICBpZiAoY29udGVudFR5cGUuaW5jbHVkZXMoXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIikpIHtcbiAgICByZXR1cm4gYXdhaXQgcmVxdWVzdC5hcnJheUJ1ZmZlcigpO1xuICB9XG4gIGlmIChjb250ZW50VHlwZS5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL3BkZlwiKSB8fCBjb250ZW50VHlwZS5pbmNsdWRlcyhcImltYWdlL1wiKSB8fCBjb250ZW50VHlwZS5pbmNsdWRlcyhcInZpZGVvL1wiKSkge1xuICAgIGNvbnN0IGJsb2IgPSBhd2FpdCByZXF1ZXN0LmJsb2IoKTtcbiAgICByZXR1cm4gYmxvYjtcbiAgfVxuICBpZiAoY29udGVudFR5cGUuaW5jbHVkZXMoXCJhcHBsaWNhdGlvbi9zdHJlYW1cIikgfHwgcmVxdWVzdC5ib2R5IGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW0pIHtcbiAgICByZXR1cm4gcmVxdWVzdC5ib2R5O1xuICB9XG4gIHJldHVybiBhd2FpdCByZXF1ZXN0LnRleHQoKTtcbn1cbmZ1bmN0aW9uIGlzQVBJRXJyb3IoZXJyb3IpIHtcbiAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgQVBJRXJyb3IgfHwgZXJyb3I/Lm5hbWUgPT09IFwiQVBJRXJyb3JcIjtcbn1cbmZ1bmN0aW9uIHRyeURlY29kZShzdHIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gc3RyLmluY2x1ZGVzKFwiJVwiKSA/IGRlY29kZVVSSUNvbXBvbmVudChzdHIpIDogc3RyO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cbi8vIHNyYy90by1yZXNwb25zZS50c1xuZnVuY3Rpb24gaXNKU09OU2VyaWFsaXphYmxlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHQgPSB0eXBlb2YgdmFsdWU7XG4gIGlmICh0ID09PSBcInN0cmluZ1wiIHx8IHQgPT09IFwibnVtYmVyXCIgfHwgdCA9PT0gXCJib29sZWFuXCIgfHwgdCA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh0ICE9PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh2YWx1ZS5idWZmZXIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiT2JqZWN0XCIgfHwgdHlwZW9mIHZhbHVlLnRvSlNPTiA9PT0gXCJmdW5jdGlvblwiO1xufVxuZnVuY3Rpb24gc2FmZVN0cmluZ2lmeShvYmosIHJlcGxhY2VyLCBzcGFjZSkge1xuICBsZXQgaWQgPSAwO1xuICBjb25zdCBzZWVuID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gIGNvbnN0IHNhZmVSZXBsYWNlciA9IChrZXksIHZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgIGlmIChzZWVuLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGBbQ2lyY3VsYXIgcmVmLSR7c2Vlbi5nZXQodmFsdWUpfV1gO1xuICAgICAgfVxuICAgICAgc2Vlbi5zZXQodmFsdWUsIGlkKyspO1xuICAgIH1cbiAgICBpZiAocmVwbGFjZXIpIHtcbiAgICAgIHJldHVybiByZXBsYWNlcihrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqLCBzYWZlUmVwbGFjZXIsIHNwYWNlKTtcbn1cbmZ1bmN0aW9uIGlzSlNPTlJlc3BvbnNlKHZhbHVlKSB7XG4gIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBcIl9mbGFnXCIgaW4gdmFsdWUgJiYgdmFsdWUuX2ZsYWcgPT09IFwianNvblwiO1xufVxuZnVuY3Rpb24gdG9SZXNwb25zZShkYXRhLCBpbml0KSB7XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgUmVzcG9uc2UpIHtcbiAgICBpZiAoaW5pdD8uaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMpIHtcbiAgICAgIGluaXQuaGVhZGVycy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIGRhdGEuaGVhZGVycy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgY29uc3QgaXNKU09OID0gaXNKU09OUmVzcG9uc2UoZGF0YSk7XG4gIGlmIChpc0pTT04pIHtcbiAgICBjb25zdCBib2R5MiA9IGRhdGEuYm9keTtcbiAgICBjb25zdCByb3V0ZXJSZXNwb25zZSA9IGRhdGEucm91dGVyUmVzcG9uc2U7XG4gICAgaWYgKHJvdXRlclJlc3BvbnNlIGluc3RhbmNlb2YgUmVzcG9uc2UpIHtcbiAgICAgIHJldHVybiByb3V0ZXJSZXNwb25zZTtcbiAgICB9XG4gICAgY29uc3QgaGVhZGVyczIgPSBuZXcgSGVhZGVycyh7XG4gICAgICAuLi5yb3V0ZXJSZXNwb25zZT8uaGVhZGVycyxcbiAgICAgIC4uLmRhdGEuaGVhZGVycyxcbiAgICAgIC4uLmluaXQ/LmhlYWRlcnMsXG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgIH0pO1xuICAgIHJldHVybiBuZXcgUmVzcG9uc2UoSlNPTi5zdHJpbmdpZnkoYm9keTIpLCB7XG4gICAgICAuLi5yb3V0ZXJSZXNwb25zZSxcbiAgICAgIGhlYWRlcnM6IGhlYWRlcnMyLFxuICAgICAgc3RhdHVzOiBkYXRhLnN0YXR1cyA/PyBpbml0Py5zdGF0dXMgPz8gcm91dGVyUmVzcG9uc2U/LnN0YXR1cyxcbiAgICAgIHN0YXR1c1RleHQ6IGluaXQ/LnN0YXR1c1RleHQgPz8gcm91dGVyUmVzcG9uc2U/LnN0YXR1c1RleHRcbiAgICB9KTtcbiAgfVxuICBpZiAoaXNBUElFcnJvcihkYXRhKSkge1xuICAgIHJldHVybiB0b1Jlc3BvbnNlKGRhdGEuYm9keSwge1xuICAgICAgc3RhdHVzOiBpbml0Py5zdGF0dXMgPz8gZGF0YS5zdGF0dXNDb2RlLFxuICAgICAgc3RhdHVzVGV4dDogZGF0YS5zdGF0dXMudG9TdHJpbmcoKSxcbiAgICAgIGhlYWRlcnM6IGluaXQ/LmhlYWRlcnMgfHwgZGF0YS5oZWFkZXJzXG4gICAgfSk7XG4gIH1cbiAgbGV0IGJvZHkgPSBkYXRhO1xuICBsZXQgaGVhZGVycyA9IG5ldyBIZWFkZXJzKGluaXQ/LmhlYWRlcnMpO1xuICBpZiAoIWRhdGEpIHtcbiAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xuICAgICAgYm9keSA9IEpTT04uc3RyaW5naWZ5KG51bGwpO1xuICAgIH1cbiAgICBoZWFkZXJzLnNldChcImNvbnRlbnQtdHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb25cIik7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICBib2R5ID0gZGF0YTtcbiAgICBoZWFkZXJzLnNldChcIkNvbnRlbnQtVHlwZVwiLCBcInRleHQvcGxhaW5cIik7XG4gIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IEFycmF5QnVmZmVyLmlzVmlldyhkYXRhKSkge1xuICAgIGJvZHkgPSBkYXRhO1xuICAgIGhlYWRlcnMuc2V0KFwiQ29udGVudC1UeXBlXCIsIFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCIpO1xuICB9IGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgYm9keSA9IGRhdGE7XG4gICAgaGVhZGVycy5zZXQoXCJDb250ZW50LVR5cGVcIiwgZGF0YS50eXBlIHx8IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCIpO1xuICB9IGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBGb3JtRGF0YSkge1xuICAgIGJvZHkgPSBkYXRhO1xuICB9IGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMpIHtcbiAgICBib2R5ID0gZGF0YTtcbiAgICBoZWFkZXJzLnNldChcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiKTtcbiAgfSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW0pIHtcbiAgICBib2R5ID0gZGF0YTtcbiAgICBoZWFkZXJzLnNldChcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiKTtcbiAgfSBlbHNlIGlmIChpc0pTT05TZXJpYWxpemFibGUoZGF0YSkpIHtcbiAgICBib2R5ID0gc2FmZVN0cmluZ2lmeShkYXRhKTtcbiAgICBoZWFkZXJzLnNldChcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb25cIik7XG4gIH1cbiAgcmV0dXJuIG5ldyBSZXNwb25zZShib2R5LCB7XG4gICAgLi4uaW5pdCxcbiAgICBoZWFkZXJzXG4gIH0pO1xufVxuXG4vLyBzcmMvdmFsaWRhdG9yLnRzXG5hc3luYyBmdW5jdGlvbiBydW5WYWxpZGF0aW9uKG9wdGlvbnMsIGNvbnRleHQgPSB7fSkge1xuICBsZXQgcmVxdWVzdCA9IHtcbiAgICBib2R5OiBjb250ZXh0LmJvZHksXG4gICAgcXVlcnk6IGNvbnRleHQucXVlcnlcbiAgfTtcbiAgaWYgKG9wdGlvbnMuYm9keSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG9wdGlvbnMuYm9keVtcIn5zdGFuZGFyZFwiXS52YWxpZGF0ZShjb250ZXh0LmJvZHkpO1xuICAgIGlmIChyZXN1bHQuaXNzdWVzKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICBlcnJvcjogZnJvbUVycm9yKHJlc3VsdC5pc3N1ZXMsIFwiYm9keVwiKVxuICAgICAgfTtcbiAgICB9XG4gICAgcmVxdWVzdC5ib2R5ID0gcmVzdWx0LnZhbHVlO1xuICB9XG4gIGlmIChvcHRpb25zLnF1ZXJ5KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgb3B0aW9ucy5xdWVyeVtcIn5zdGFuZGFyZFwiXS52YWxpZGF0ZShjb250ZXh0LnF1ZXJ5KTtcbiAgICBpZiAocmVzdWx0Lmlzc3Vlcykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgZXJyb3I6IGZyb21FcnJvcihyZXN1bHQuaXNzdWVzLCBcInF1ZXJ5XCIpXG4gICAgICB9O1xuICAgIH1cbiAgICByZXF1ZXN0LnF1ZXJ5ID0gcmVzdWx0LnZhbHVlO1xuICB9XG4gIGlmIChvcHRpb25zLnJlcXVpcmVIZWFkZXJzICYmICFjb250ZXh0LmhlYWRlcnMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGF0YTogbnVsbCxcbiAgICAgIGVycm9yOiB7IG1lc3NhZ2U6IFwiSGVhZGVycyBpcyByZXF1aXJlZFwiIH1cbiAgICB9O1xuICB9XG4gIGlmIChvcHRpb25zLnJlcXVpcmVSZXF1ZXN0ICYmICFjb250ZXh0LnJlcXVlc3QpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGF0YTogbnVsbCxcbiAgICAgIGVycm9yOiB7IG1lc3NhZ2U6IFwiUmVxdWVzdCBpcyByZXF1aXJlZFwiIH1cbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgZGF0YTogcmVxdWVzdCxcbiAgICBlcnJvcjogbnVsbFxuICB9O1xufVxuZnVuY3Rpb24gZnJvbUVycm9yKGVycm9yLCB2YWxpZGF0aW5nKSB7XG4gIGNvbnN0IGVycm9yTWVzc2FnZXMgPSBbXTtcbiAgZm9yIChjb25zdCBpc3N1ZTIgb2YgZXJyb3IpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gaXNzdWUyLm1lc3NhZ2U7XG4gICAgZXJyb3JNZXNzYWdlcy5wdXNoKG1lc3NhZ2UpO1xuICB9XG4gIHJldHVybiB7XG4gICAgbWVzc2FnZTogYEludmFsaWQgJHt2YWxpZGF0aW5nfSBwYXJhbWV0ZXJzYFxuICB9O1xufVxuXG4vLyBzcmMvY3J5cHRvLnRzXG5pbXBvcnQgeyBzdWJ0bGUgfSBmcm9tIFwidW5jcnlwdG9cIjtcbnZhciBhbGdvcml0aG0gPSB7IG5hbWU6IFwiSE1BQ1wiLCBoYXNoOiBcIlNIQS0yNTZcIiB9O1xudmFyIGdldENyeXB0b0tleSA9IGFzeW5jIChzZWNyZXQpID0+IHtcbiAgY29uc3Qgc2VjcmV0QnVmID0gdHlwZW9mIHNlY3JldCA9PT0gXCJzdHJpbmdcIiA/IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzZWNyZXQpIDogc2VjcmV0O1xuICByZXR1cm4gYXdhaXQgc3VidGxlLmltcG9ydEtleShcInJhd1wiLCBzZWNyZXRCdWYsIGFsZ29yaXRobSwgZmFsc2UsIFtcInNpZ25cIiwgXCJ2ZXJpZnlcIl0pO1xufTtcbnZhciB2ZXJpZnlTaWduYXR1cmUgPSBhc3luYyAoYmFzZTY0U2lnbmF0dXJlLCB2YWx1ZSwgc2VjcmV0KSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3Qgc2lnbmF0dXJlQmluU3RyID0gYXRvYihiYXNlNjRTaWduYXR1cmUpO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IG5ldyBVaW50OEFycmF5KHNpZ25hdHVyZUJpblN0ci5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBzaWduYXR1cmVCaW5TdHIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHNpZ25hdHVyZVtpXSA9IHNpZ25hdHVyZUJpblN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgc3VidGxlLnZlcmlmeShhbGdvcml0aG0sIHNlY3JldCwgc2lnbmF0dXJlLCBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUodmFsdWUpKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcbnZhciBtYWtlU2lnbmF0dXJlID0gYXN5bmMgKHZhbHVlLCBzZWNyZXQpID0+IHtcbiAgY29uc3Qga2V5ID0gYXdhaXQgZ2V0Q3J5cHRvS2V5KHNlY3JldCk7XG4gIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHN1YnRsZS5zaWduKGFsZ29yaXRobS5uYW1lLCBrZXksIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh2YWx1ZSkpO1xuICByZXR1cm4gYnRvYShTdHJpbmcuZnJvbUNoYXJDb2RlKC4uLm5ldyBVaW50OEFycmF5KHNpZ25hdHVyZSkpKTtcbn07XG52YXIgc2lnbkNvb2tpZVZhbHVlID0gYXN5bmMgKHZhbHVlLCBzZWNyZXQpID0+IHtcbiAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgbWFrZVNpZ25hdHVyZSh2YWx1ZSwgc2VjcmV0KTtcbiAgdmFsdWUgPSBgJHt2YWx1ZX0uJHtzaWduYXR1cmV9YDtcbiAgdmFsdWUgPSBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuXG4vLyBzcmMvY29va2llcy50c1xudmFyIGdldENvb2tpZUtleSA9IChrZXksIHByZWZpeCkgPT4ge1xuICBsZXQgZmluYWxLZXkgPSBrZXk7XG4gIGlmIChwcmVmaXgpIHtcbiAgICBpZiAocHJlZml4ID09PSBcInNlY3VyZVwiKSB7XG4gICAgICBmaW5hbEtleSA9IFwiX19TZWN1cmUtXCIgKyBrZXk7XG4gICAgfSBlbHNlIGlmIChwcmVmaXggPT09IFwiaG9zdFwiKSB7XG4gICAgICBmaW5hbEtleSA9IFwiX19Ib3N0LVwiICsga2V5O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmluYWxLZXk7XG59O1xuZnVuY3Rpb24gcGFyc2VDb29raWVzKHN0cikge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJhcmd1bWVudCBzdHIgbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgfVxuICBjb25zdCBjb29raWVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgbGV0IGluZGV4ID0gMDtcbiAgd2hpbGUgKGluZGV4IDwgc3RyLmxlbmd0aCkge1xuICAgIGNvbnN0IGVxSWR4ID0gc3RyLmluZGV4T2YoXCI9XCIsIGluZGV4KTtcbiAgICBpZiAoZXFJZHggPT09IC0xKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgbGV0IGVuZElkeCA9IHN0ci5pbmRleE9mKFwiO1wiLCBpbmRleCk7XG4gICAgaWYgKGVuZElkeCA9PT0gLTEpIHtcbiAgICAgIGVuZElkeCA9IHN0ci5sZW5ndGg7XG4gICAgfSBlbHNlIGlmIChlbmRJZHggPCBlcUlkeCkge1xuICAgICAgaW5kZXggPSBzdHIubGFzdEluZGV4T2YoXCI7XCIsIGVxSWR4IC0gMSkgKyAxO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGtleSA9IHN0ci5zbGljZShpbmRleCwgZXFJZHgpLnRyaW0oKTtcbiAgICBpZiAoIWNvb2tpZXMuaGFzKGtleSkpIHtcbiAgICAgIGxldCB2YWwgPSBzdHIuc2xpY2UoZXFJZHggKyAxLCBlbmRJZHgpLnRyaW0oKTtcbiAgICAgIGlmICh2YWwuY29kZVBvaW50QXQoMCkgPT09IDM0KSB7XG4gICAgICAgIHZhbCA9IHZhbC5zbGljZSgxLCAtMSk7XG4gICAgICB9XG4gICAgICBjb29raWVzLnNldChrZXksIHRyeURlY29kZSh2YWwpKTtcbiAgICB9XG4gICAgaW5kZXggPSBlbmRJZHggKyAxO1xuICB9XG4gIHJldHVybiBjb29raWVzO1xufVxudmFyIF9zZXJpYWxpemUgPSAoa2V5LCB2YWx1ZSwgb3B0ID0ge30pID0+IHtcbiAgbGV0IGNvb2tpZTtcbiAgaWYgKG9wdD8ucHJlZml4ID09PSBcInNlY3VyZVwiKSB7XG4gICAgY29va2llID0gYCR7YF9fU2VjdXJlLSR7a2V5fWB9PSR7dmFsdWV9YDtcbiAgfSBlbHNlIGlmIChvcHQ/LnByZWZpeCA9PT0gXCJob3N0XCIpIHtcbiAgICBjb29raWUgPSBgJHtgX19Ib3N0LSR7a2V5fWB9PSR7dmFsdWV9YDtcbiAgfSBlbHNlIHtcbiAgICBjb29raWUgPSBgJHtrZXl9PSR7dmFsdWV9YDtcbiAgfVxuICBpZiAoa2V5LnN0YXJ0c1dpdGgoXCJfX1NlY3VyZS1cIikgJiYgIW9wdC5zZWN1cmUpIHtcbiAgICBvcHQuc2VjdXJlID0gdHJ1ZTtcbiAgfVxuICBpZiAoa2V5LnN0YXJ0c1dpdGgoXCJfX0hvc3QtXCIpKSB7XG4gICAgaWYgKCFvcHQuc2VjdXJlKSB7XG4gICAgICBvcHQuc2VjdXJlID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG9wdC5wYXRoICE9PSBcIi9cIikge1xuICAgICAgb3B0LnBhdGggPSBcIi9cIjtcbiAgICB9XG4gICAgaWYgKG9wdC5kb21haW4pIHtcbiAgICAgIG9wdC5kb21haW4gPSB2b2lkIDA7XG4gICAgfVxuICB9XG4gIGlmIChvcHQgJiYgdHlwZW9mIG9wdC5tYXhBZ2UgPT09IFwibnVtYmVyXCIgJiYgb3B0Lm1heEFnZSA+PSAwKSB7XG4gICAgaWYgKG9wdC5tYXhBZ2UgPiAzNDU2ZTQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJDb29raWVzIE1heC1BZ2UgU0hPVUxEIE5PVCBiZSBncmVhdGVyIHRoYW4gNDAwIGRheXMgKDM0NTYwMDAwIHNlY29uZHMpIGluIGR1cmF0aW9uLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBjb29raWUgKz0gYDsgTWF4LUFnZT0ke01hdGguZmxvb3Iob3B0Lm1heEFnZSl9YDtcbiAgfVxuICBpZiAob3B0LmRvbWFpbiAmJiBvcHQucHJlZml4ICE9PSBcImhvc3RcIikge1xuICAgIGNvb2tpZSArPSBgOyBEb21haW49JHtvcHQuZG9tYWlufWA7XG4gIH1cbiAgaWYgKG9wdC5wYXRoKSB7XG4gICAgY29va2llICs9IGA7IFBhdGg9JHtvcHQucGF0aH1gO1xuICB9XG4gIGlmIChvcHQuZXhwaXJlcykge1xuICAgIGlmIChvcHQuZXhwaXJlcy5nZXRUaW1lKCkgLSBEYXRlLm5vdygpID4gMzQ1NmU3KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiQ29va2llcyBFeHBpcmVzIFNIT1VMRCBOT1QgYmUgZ3JlYXRlciB0aGFuIDQwMCBkYXlzICgzNDU2MDAwMCBzZWNvbmRzKSBpbiB0aGUgZnV0dXJlLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBjb29raWUgKz0gYDsgRXhwaXJlcz0ke29wdC5leHBpcmVzLnRvVVRDU3RyaW5nKCl9YDtcbiAgfVxuICBpZiAob3B0Lmh0dHBPbmx5KSB7XG4gICAgY29va2llICs9IFwiOyBIdHRwT25seVwiO1xuICB9XG4gIGlmIChvcHQuc2VjdXJlKSB7XG4gICAgY29va2llICs9IFwiOyBTZWN1cmVcIjtcbiAgfVxuICBpZiAob3B0LnNhbWVTaXRlKSB7XG4gICAgY29va2llICs9IGA7IFNhbWVTaXRlPSR7b3B0LnNhbWVTaXRlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgb3B0LnNhbWVTaXRlLnNsaWNlKDEpfWA7XG4gIH1cbiAgaWYgKG9wdC5wYXJ0aXRpb25lZCkge1xuICAgIGlmICghb3B0LnNlY3VyZSkge1xuICAgICAgb3B0LnNlY3VyZSA9IHRydWU7XG4gICAgfVxuICAgIGNvb2tpZSArPSBcIjsgUGFydGl0aW9uZWRcIjtcbiAgfVxuICByZXR1cm4gY29va2llO1xufTtcbnZhciBzZXJpYWxpemVDb29raWUgPSAoa2V5LCB2YWx1ZSwgb3B0KSA9PiB7XG4gIHZhbHVlID0gZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcbiAgcmV0dXJuIF9zZXJpYWxpemUoa2V5LCB2YWx1ZSwgb3B0KTtcbn07XG52YXIgc2VyaWFsaXplU2lnbmVkQ29va2llID0gYXN5bmMgKGtleSwgdmFsdWUsIHNlY3JldCwgb3B0KSA9PiB7XG4gIHZhbHVlID0gYXdhaXQgc2lnbkNvb2tpZVZhbHVlKHZhbHVlLCBzZWNyZXQpO1xuICByZXR1cm4gX3NlcmlhbGl6ZShrZXksIHZhbHVlLCBvcHQpO1xufTtcblxuLy8gc3JjL2NvbnRleHQudHNcbnZhciBjcmVhdGVJbnRlcm5hbENvbnRleHQgPSBhc3luYyAoY29udGV4dCwge1xuICBvcHRpb25zLFxuICBwYXRoXG59KSA9PiB7XG4gIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBydW5WYWxpZGF0aW9uKG9wdGlvbnMsIGNvbnRleHQpO1xuICBpZiAoZXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgQVBJRXJyb3IoNDAwLCB7XG4gICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgY29kZTogXCJWQUxJREFUSU9OX0VSUk9SXCJcbiAgICB9KTtcbiAgfVxuICBjb25zdCByZXF1ZXN0SGVhZGVycyA9IFwiaGVhZGVyc1wiIGluIGNvbnRleHQgPyBjb250ZXh0LmhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzID8gY29udGV4dC5oZWFkZXJzIDogbmV3IEhlYWRlcnMoY29udGV4dC5oZWFkZXJzKSA6IFwicmVxdWVzdFwiIGluIGNvbnRleHQgJiYgY29udGV4dC5yZXF1ZXN0IGluc3RhbmNlb2YgUmVxdWVzdCA/IGNvbnRleHQucmVxdWVzdC5oZWFkZXJzIDogbnVsbDtcbiAgY29uc3QgcmVxdWVzdENvb2tpZXMgPSByZXF1ZXN0SGVhZGVycz8uZ2V0KFwiY29va2llXCIpO1xuICBjb25zdCBwYXJzZWRDb29raWVzID0gcmVxdWVzdENvb2tpZXMgPyBwYXJzZUNvb2tpZXMocmVxdWVzdENvb2tpZXMpIDogdm9pZCAwO1xuICBjb25zdCBpbnRlcm5hbENvbnRleHQgPSB7XG4gICAgLi4uY29udGV4dCxcbiAgICBib2R5OiBkYXRhLmJvZHksXG4gICAgcXVlcnk6IGRhdGEucXVlcnksXG4gICAgcGF0aDogY29udGV4dC5wYXRoIHx8IHBhdGgsXG4gICAgY29udGV4dDogXCJjb250ZXh0XCIgaW4gY29udGV4dCAmJiBjb250ZXh0LmNvbnRleHQgPyBjb250ZXh0LmNvbnRleHQgOiB7fSxcbiAgICByZXR1cm5lZDogdm9pZCAwLFxuICAgIGhlYWRlcnM6IGNvbnRleHQ/LmhlYWRlcnMsXG4gICAgcmVxdWVzdDogY29udGV4dD8ucmVxdWVzdCxcbiAgICBwYXJhbXM6IFwicGFyYW1zXCIgaW4gY29udGV4dCA/IGNvbnRleHQucGFyYW1zIDogdm9pZCAwLFxuICAgIG1ldGhvZDogY29udGV4dC5tZXRob2QsXG4gICAgc2V0SGVhZGVyOiAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgaGVhZGVycy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfSxcbiAgICBnZXRIZWFkZXI6IChrZXkpID0+IHtcbiAgICAgIGlmICghcmVxdWVzdEhlYWRlcnMpIHJldHVybiBudWxsO1xuICAgICAgcmV0dXJuIHJlcXVlc3RIZWFkZXJzLmdldChrZXkpO1xuICAgIH0sXG4gICAgZ2V0Q29va2llOiAoa2V5LCBwcmVmaXgpID0+IHtcbiAgICAgIGNvbnN0IGZpbmFsS2V5ID0gZ2V0Q29va2llS2V5KGtleSwgcHJlZml4KTtcbiAgICAgIGlmICghZmluYWxLZXkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyc2VkQ29va2llcz8uZ2V0KGZpbmFsS2V5KSB8fCBudWxsO1xuICAgIH0sXG4gICAgZ2V0U2lnbmVkQ29va2llOiBhc3luYyAoa2V5LCBzZWNyZXQsIHByZWZpeCkgPT4ge1xuICAgICAgY29uc3QgZmluYWxLZXkgPSBnZXRDb29raWVLZXkoa2V5LCBwcmVmaXgpO1xuICAgICAgaWYgKCFmaW5hbEtleSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbHVlID0gcGFyc2VkQ29va2llcz8uZ2V0KGZpbmFsS2V5KTtcbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBjb25zdCBzaWduYXR1cmVTdGFydFBvcyA9IHZhbHVlLmxhc3RJbmRleE9mKFwiLlwiKTtcbiAgICAgIGlmIChzaWduYXR1cmVTdGFydFBvcyA8IDEpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBjb25zdCBzaWduZWRWYWx1ZSA9IHZhbHVlLnN1YnN0cmluZygwLCBzaWduYXR1cmVTdGFydFBvcyk7XG4gICAgICBjb25zdCBzaWduYXR1cmUgPSB2YWx1ZS5zdWJzdHJpbmcoc2lnbmF0dXJlU3RhcnRQb3MgKyAxKTtcbiAgICAgIGlmIChzaWduYXR1cmUubGVuZ3RoICE9PSA0NCB8fCAhc2lnbmF0dXJlLmVuZHNXaXRoKFwiPVwiKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNlY3JldEtleSA9IGF3YWl0IGdldENyeXB0b0tleShzZWNyZXQpO1xuICAgICAgY29uc3QgaXNWZXJpZmllZCA9IGF3YWl0IHZlcmlmeVNpZ25hdHVyZShzaWduYXR1cmUsIHNpZ25lZFZhbHVlLCBzZWNyZXRLZXkpO1xuICAgICAgcmV0dXJuIGlzVmVyaWZpZWQgPyBzaWduZWRWYWx1ZSA6IGZhbHNlO1xuICAgIH0sXG4gICAgc2V0Q29va2llOiAoa2V5LCB2YWx1ZSwgb3B0aW9uczIpID0+IHtcbiAgICAgIGNvbnN0IGNvb2tpZSA9IHNlcmlhbGl6ZUNvb2tpZShrZXksIHZhbHVlLCBvcHRpb25zMik7XG4gICAgICBoZWFkZXJzLmFwcGVuZChcInNldC1jb29raWVcIiwgY29va2llKTtcbiAgICAgIHJldHVybiBjb29raWU7XG4gICAgfSxcbiAgICBzZXRTaWduZWRDb29raWU6IGFzeW5jIChrZXksIHZhbHVlLCBzZWNyZXQsIG9wdGlvbnMyKSA9PiB7XG4gICAgICBjb25zdCBjb29raWUgPSBhd2FpdCBzZXJpYWxpemVTaWduZWRDb29raWUoa2V5LCB2YWx1ZSwgc2VjcmV0LCBvcHRpb25zMik7XG4gICAgICBoZWFkZXJzLmFwcGVuZChcInNldC1jb29raWVcIiwgY29va2llKTtcbiAgICAgIHJldHVybiBjb29raWU7XG4gICAgfSxcbiAgICByZWRpcmVjdDogKHVybCkgPT4ge1xuICAgICAgaGVhZGVycy5zZXQoXCJsb2NhdGlvblwiLCB1cmwpO1xuICAgICAgcmV0dXJuIG5ldyBBUElFcnJvcihcIkZPVU5EXCIsIHZvaWQgMCwgaGVhZGVycyk7XG4gICAgfSxcbiAgICBlcnJvcjogKHN0YXR1cywgYm9keSwgaGVhZGVyczIpID0+IHtcbiAgICAgIHJldHVybiBuZXcgQVBJRXJyb3Ioc3RhdHVzLCBib2R5LCBoZWFkZXJzMik7XG4gICAgfSxcbiAgICBqc29uOiAoanNvbiwgcm91dGVyUmVzcG9uc2UpID0+IHtcbiAgICAgIGlmICghY29udGV4dC5hc1Jlc3BvbnNlKSB7XG4gICAgICAgIHJldHVybiBqc29uO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYm9keTogcm91dGVyUmVzcG9uc2U/LmJvZHkgfHwganNvbixcbiAgICAgICAgcm91dGVyUmVzcG9uc2UsXG4gICAgICAgIF9mbGFnOiBcImpzb25cIlxuICAgICAgfTtcbiAgICB9LFxuICAgIHJlc3BvbnNlSGVhZGVyczogaGVhZGVyc1xuICB9O1xuICBmb3IgKGNvbnN0IG1pZGRsZXdhcmUgb2Ygb3B0aW9ucy51c2UgfHwgW10pIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IG1pZGRsZXdhcmUoe1xuICAgICAgLi4uaW50ZXJuYWxDb250ZXh0LFxuICAgICAgcmV0dXJuSGVhZGVyczogdHJ1ZSxcbiAgICAgIGFzUmVzcG9uc2U6IGZhbHNlXG4gICAgfSk7XG4gICAgaWYgKHJlc3BvbnNlLnJlc3BvbnNlKSB7XG4gICAgICBPYmplY3QuYXNzaWduKGludGVybmFsQ29udGV4dC5jb250ZXh0LCByZXNwb25zZS5yZXNwb25zZSk7XG4gICAgfVxuICAgIGlmIChyZXNwb25zZS5oZWFkZXJzKSB7XG4gICAgICByZXNwb25zZS5oZWFkZXJzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgaW50ZXJuYWxDb250ZXh0LnJlc3BvbnNlSGVhZGVycy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGludGVybmFsQ29udGV4dDtcbn07XG5cbi8vIHNyYy9taWRkbGV3YXJlLnRzXG5mdW5jdGlvbiBjcmVhdGVNaWRkbGV3YXJlKG9wdGlvbnNPckhhbmRsZXIsIGhhbmRsZXIpIHtcbiAgY29uc3QgaW50ZXJuYWxIYW5kbGVyID0gYXN5bmMgKGlucHV0Q3R4KSA9PiB7XG4gICAgY29uc3QgY29udGV4dCA9IGlucHV0Q3R4O1xuICAgIGNvbnN0IF9oYW5kbGVyID0gdHlwZW9mIG9wdGlvbnNPckhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIiA/IG9wdGlvbnNPckhhbmRsZXIgOiBoYW5kbGVyO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9uc09ySGFuZGxlciA9PT0gXCJmdW5jdGlvblwiID8ge30gOiBvcHRpb25zT3JIYW5kbGVyO1xuICAgIGNvbnN0IGludGVybmFsQ29udGV4dCA9IGF3YWl0IGNyZWF0ZUludGVybmFsQ29udGV4dChjb250ZXh0LCB7XG4gICAgICBvcHRpb25zLFxuICAgICAgcGF0aDogXCIvXCJcbiAgICB9KTtcbiAgICBpZiAoIV9oYW5kbGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJoYW5kbGVyIG11c3QgYmUgZGVmaW5lZFwiKTtcbiAgICB9XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBfaGFuZGxlcihpbnRlcm5hbENvbnRleHQpO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBpbnRlcm5hbENvbnRleHQucmVzcG9uc2VIZWFkZXJzO1xuICAgIHJldHVybiBjb250ZXh0LnJldHVybkhlYWRlcnMgPyB7XG4gICAgICBoZWFkZXJzLFxuICAgICAgcmVzcG9uc2VcbiAgICB9IDogcmVzcG9uc2U7XG4gIH07XG4gIGludGVybmFsSGFuZGxlci5vcHRpb25zID0gdHlwZW9mIG9wdGlvbnNPckhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIiA/IHt9IDogb3B0aW9uc09ySGFuZGxlcjtcbiAgcmV0dXJuIGludGVybmFsSGFuZGxlcjtcbn1cbmNyZWF0ZU1pZGRsZXdhcmUuY3JlYXRlID0gKG9wdHMpID0+IHtcbiAgZnVuY3Rpb24gZm4ob3B0aW9uc09ySGFuZGxlciwgaGFuZGxlcikge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9uc09ySGFuZGxlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gY3JlYXRlTWlkZGxld2FyZShcbiAgICAgICAge1xuICAgICAgICAgIHVzZTogb3B0cz8udXNlXG4gICAgICAgIH0sXG4gICAgICAgIG9wdGlvbnNPckhhbmRsZXJcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghaGFuZGxlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlkZGxld2FyZSBoYW5kbGVyIGlzIHJlcXVpcmVkXCIpO1xuICAgIH1cbiAgICBjb25zdCBtaWRkbGV3YXJlID0gY3JlYXRlTWlkZGxld2FyZShcbiAgICAgIHtcbiAgICAgICAgLi4ub3B0aW9uc09ySGFuZGxlcixcbiAgICAgICAgbWV0aG9kOiBcIipcIixcbiAgICAgICAgdXNlOiBbLi4ub3B0cz8udXNlIHx8IFtdLCAuLi5vcHRpb25zT3JIYW5kbGVyLnVzZSB8fCBbXV1cbiAgICAgIH0sXG4gICAgICBoYW5kbGVyXG4gICAgKTtcbiAgICByZXR1cm4gbWlkZGxld2FyZTtcbiAgfVxuICByZXR1cm4gZm47XG59O1xuXG4vLyBzcmMvZW5kcG9pbnQudHNcbnZhciBjcmVhdGVFbmRwb2ludDIgPSAocGF0aCwgb3B0aW9ucywgaGFuZGxlcikgPT4ge1xuICBjb25zdCBpbnRlcm5hbEhhbmRsZXIgPSBhc3luYyAoLi4uaW5wdXRDdHgpID0+IHtcbiAgICBjb25zdCBjb250ZXh0ID0gaW5wdXRDdHhbMF0gfHwge307XG4gICAgY29uc3QgaW50ZXJuYWxDb250ZXh0ID0gYXdhaXQgY3JlYXRlSW50ZXJuYWxDb250ZXh0KGNvbnRleHQsIHtcbiAgICAgIG9wdGlvbnMsXG4gICAgICBwYXRoXG4gICAgfSk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBoYW5kbGVyKGludGVybmFsQ29udGV4dCkuY2F0Y2goYXN5bmMgKGUpID0+IHtcbiAgICAgIGlmIChpc0FQSUVycm9yKGUpKSB7XG4gICAgICAgIGNvbnN0IG9uQVBJRXJyb3IgPSBvcHRpb25zLm9uQVBJRXJyb3I7XG4gICAgICAgIGlmIChvbkFQSUVycm9yKSB7XG4gICAgICAgICAgYXdhaXQgb25BUElFcnJvcihlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGV4dC5hc1Jlc3BvbnNlKSB7XG4gICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRocm93IGU7XG4gICAgfSk7XG4gICAgY29uc3QgaGVhZGVycyA9IGludGVybmFsQ29udGV4dC5yZXNwb25zZUhlYWRlcnM7XG4gICAgcmV0dXJuIGNvbnRleHQuYXNSZXNwb25zZSA/IHRvUmVzcG9uc2UocmVzcG9uc2UsIHtcbiAgICAgIGhlYWRlcnNcbiAgICB9KSA6IGNvbnRleHQucmV0dXJuSGVhZGVycyA/IHtcbiAgICAgIGhlYWRlcnMsXG4gICAgICByZXNwb25zZVxuICAgIH0gOiByZXNwb25zZTtcbiAgfTtcbiAgaW50ZXJuYWxIYW5kbGVyLm9wdGlvbnMgPSBvcHRpb25zO1xuICBpbnRlcm5hbEhhbmRsZXIucGF0aCA9IHBhdGg7XG4gIHJldHVybiBpbnRlcm5hbEhhbmRsZXI7XG59O1xuY3JlYXRlRW5kcG9pbnQyLmNyZWF0ZSA9IChvcHRzKSA9PiB7XG4gIHJldHVybiAocGF0aCwgb3B0aW9ucywgaGFuZGxlcikgPT4ge1xuICAgIHJldHVybiBjcmVhdGVFbmRwb2ludDIoXG4gICAgICBwYXRoLFxuICAgICAge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB1c2U6IFsuLi5vcHRpb25zPy51c2UgfHwgW10sIC4uLm9wdHM/LnVzZSB8fCBbXV1cbiAgICAgIH0sXG4gICAgICBoYW5kbGVyXG4gICAgKTtcbiAgfTtcbn07XG5cbi8vIHNyYy9yb3V0ZXIudHNcbmltcG9ydCB7IGNyZWF0ZVJvdXRlciBhcyBjcmVhdGVSb3UzUm91dGVyLCBhZGRSb3V0ZSwgZmluZFJvdXRlLCBmaW5kQWxsUm91dGVzIH0gZnJvbSBcInJvdTNcIjtcblxuLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3pvZEA0LjAuMS9ub2RlX21vZHVsZXMvem9kL3Y0L2NvcmUvY29yZS5qc1xudmFyIE5FVkVSID0gT2JqZWN0LmZyZWV6ZSh7XG4gIHN0YXR1czogXCJhYm9ydGVkXCJcbn0pO1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uICRjb25zdHJ1Y3RvcihuYW1lLCBpbml0aWFsaXplcjMsIHBhcmFtcykge1xuICBmdW5jdGlvbiBpbml0KGluc3QsIGRlZikge1xuICAgIHZhciBfYTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaW5zdCwgXCJfem9kXCIsIHtcbiAgICAgIHZhbHVlOiBpbnN0Ll96b2QgPz8ge30sXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgIH0pO1xuICAgIChfYSA9IGluc3QuX3pvZCkudHJhaXRzID8/IChfYS50cmFpdHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcbiAgICBpbnN0Ll96b2QudHJhaXRzLmFkZChuYW1lKTtcbiAgICBpbml0aWFsaXplcjMoaW5zdCwgZGVmKTtcbiAgICBmb3IgKGNvbnN0IGsgaW4gXy5wcm90b3R5cGUpIHtcbiAgICAgIGlmICghKGsgaW4gaW5zdCkpXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbnN0LCBrLCB7IHZhbHVlOiBfLnByb3RvdHlwZVtrXS5iaW5kKGluc3QpIH0pO1xuICAgIH1cbiAgICBpbnN0Ll96b2QuY29uc3RyID0gXztcbiAgICBpbnN0Ll96b2QuZGVmID0gZGVmO1xuICB9XG4gIGNvbnN0IFBhcmVudCA9IHBhcmFtcz8uUGFyZW50ID8/IE9iamVjdDtcbiAgY2xhc3MgRGVmaW5pdGlvbiBleHRlbmRzIFBhcmVudCB7XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlZmluaXRpb24sIFwibmFtZVwiLCB7IHZhbHVlOiBuYW1lIH0pO1xuICBmdW5jdGlvbiBfKGRlZikge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBpbnN0ID0gcGFyYW1zPy5QYXJlbnQgPyBuZXcgRGVmaW5pdGlvbigpIDogdGhpcztcbiAgICBpbml0KGluc3QsIGRlZik7XG4gICAgKF9hID0gaW5zdC5fem9kKS5kZWZlcnJlZCA/PyAoX2EuZGVmZXJyZWQgPSBbXSk7XG4gICAgZm9yIChjb25zdCBmbiBvZiBpbnN0Ll96b2QuZGVmZXJyZWQpIHtcbiAgICAgIGZuKCk7XG4gICAgfVxuICAgIHJldHVybiBpbnN0O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfLCBcImluaXRcIiwgeyB2YWx1ZTogaW5pdCB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF8sIFN5bWJvbC5oYXNJbnN0YW5jZSwge1xuICAgIHZhbHVlOiAoaW5zdCkgPT4ge1xuICAgICAgaWYgKHBhcmFtcz8uUGFyZW50ICYmIGluc3QgaW5zdGFuY2VvZiBwYXJhbXMuUGFyZW50KVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIHJldHVybiBpbnN0Py5fem9kPy50cmFpdHM/LmhhcyhuYW1lKTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXywgXCJuYW1lXCIsIHsgdmFsdWU6IG5hbWUgfSk7XG4gIHJldHVybiBfO1xufVxudmFyICRicmFuZCA9IFN5bWJvbChcInpvZF9icmFuZFwiKTtcbnZhciAkWm9kQXN5bmNFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihgRW5jb3VudGVyZWQgUHJvbWlzZSBkdXJpbmcgc3luY2hyb25vdXMgcGFyc2UuIFVzZSAucGFyc2VBc3luYygpIGluc3RlYWQuYCk7XG4gIH1cbn07XG52YXIgZ2xvYmFsQ29uZmlnID0ge307XG5mdW5jdGlvbiBjb25maWcobmV3Q29uZmlnKSB7XG4gIGlmIChuZXdDb25maWcpXG4gICAgT2JqZWN0LmFzc2lnbihnbG9iYWxDb25maWcsIG5ld0NvbmZpZyk7XG4gIHJldHVybiBnbG9iYWxDb25maWc7XG59XG5cbi8vIG5vZGVfbW9kdWxlcy8ucG5wbS96b2RANC4wLjEvbm9kZV9tb2R1bGVzL3pvZC92NC9jb3JlL3V0aWwuanNcbnZhciB1dGlsX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHV0aWxfZXhwb3J0cywge1xuICBCSUdJTlRfRk9STUFUX1JBTkdFUzogKCkgPT4gQklHSU5UX0ZPUk1BVF9SQU5HRVMsXG4gIENsYXNzOiAoKSA9PiBDbGFzcyxcbiAgTlVNQkVSX0ZPUk1BVF9SQU5HRVM6ICgpID0+IE5VTUJFUl9GT1JNQVRfUkFOR0VTLFxuICBhYm9ydGVkOiAoKSA9PiBhYm9ydGVkLFxuICBhbGxvd3NFdmFsOiAoKSA9PiBhbGxvd3NFdmFsLFxuICBhc3NlcnQ6ICgpID0+IGFzc2VydCxcbiAgYXNzZXJ0RXF1YWw6ICgpID0+IGFzc2VydEVxdWFsLFxuICBhc3NlcnRJczogKCkgPT4gYXNzZXJ0SXMsXG4gIGFzc2VydE5ldmVyOiAoKSA9PiBhc3NlcnROZXZlcixcbiAgYXNzZXJ0Tm90RXF1YWw6ICgpID0+IGFzc2VydE5vdEVxdWFsLFxuICBhc3NpZ25Qcm9wOiAoKSA9PiBhc3NpZ25Qcm9wLFxuICBjYWNoZWQ6ICgpID0+IGNhY2hlZCxcbiAgY2FwdHVyZVN0YWNrVHJhY2U6ICgpID0+IGNhcHR1cmVTdGFja1RyYWNlLFxuICBjbGVhbkVudW06ICgpID0+IGNsZWFuRW51bSxcbiAgY2xlYW5SZWdleDogKCkgPT4gY2xlYW5SZWdleCxcbiAgY2xvbmU6ICgpID0+IGNsb25lLFxuICBjcmVhdGVUcmFuc3BhcmVudFByb3h5OiAoKSA9PiBjcmVhdGVUcmFuc3BhcmVudFByb3h5LFxuICBkZWZpbmVMYXp5OiAoKSA9PiBkZWZpbmVMYXp5LFxuICBlc2M6ICgpID0+IGVzYyxcbiAgZXNjYXBlUmVnZXg6ICgpID0+IGVzY2FwZVJlZ2V4LFxuICBleHRlbmQ6ICgpID0+IGV4dGVuZCxcbiAgZmluYWxpemVJc3N1ZTogKCkgPT4gZmluYWxpemVJc3N1ZSxcbiAgZmxvYXRTYWZlUmVtYWluZGVyOiAoKSA9PiBmbG9hdFNhZmVSZW1haW5kZXIsXG4gIGdldEVsZW1lbnRBdFBhdGg6ICgpID0+IGdldEVsZW1lbnRBdFBhdGgsXG4gIGdldEVudW1WYWx1ZXM6ICgpID0+IGdldEVudW1WYWx1ZXMsXG4gIGdldExlbmd0aGFibGVPcmlnaW46ICgpID0+IGdldExlbmd0aGFibGVPcmlnaW4sXG4gIGdldFBhcnNlZFR5cGU6ICgpID0+IGdldFBhcnNlZFR5cGUsXG4gIGdldFNpemFibGVPcmlnaW46ICgpID0+IGdldFNpemFibGVPcmlnaW4sXG4gIGlzT2JqZWN0OiAoKSA9PiBpc09iamVjdCxcbiAgaXNQbGFpbk9iamVjdDogKCkgPT4gaXNQbGFpbk9iamVjdCxcbiAgaXNzdWU6ICgpID0+IGlzc3VlLFxuICBqb2luVmFsdWVzOiAoKSA9PiBqb2luVmFsdWVzLFxuICBqc29uU3RyaW5naWZ5UmVwbGFjZXI6ICgpID0+IGpzb25TdHJpbmdpZnlSZXBsYWNlcixcbiAgbWVyZ2U6ICgpID0+IG1lcmdlLFxuICBub3JtYWxpemVQYXJhbXM6ICgpID0+IG5vcm1hbGl6ZVBhcmFtcyxcbiAgbnVsbGlzaDogKCkgPT4gbnVsbGlzaCxcbiAgbnVtS2V5czogKCkgPT4gbnVtS2V5cyxcbiAgb21pdDogKCkgPT4gb21pdCxcbiAgb3B0aW9uYWxLZXlzOiAoKSA9PiBvcHRpb25hbEtleXMsXG4gIHBhcnRpYWw6ICgpID0+IHBhcnRpYWwsXG4gIHBpY2s6ICgpID0+IHBpY2ssXG4gIHByZWZpeElzc3VlczogKCkgPT4gcHJlZml4SXNzdWVzLFxuICBwcmltaXRpdmVUeXBlczogKCkgPT4gcHJpbWl0aXZlVHlwZXMsXG4gIHByb21pc2VBbGxPYmplY3Q6ICgpID0+IHByb21pc2VBbGxPYmplY3QsXG4gIHByb3BlcnR5S2V5VHlwZXM6ICgpID0+IHByb3BlcnR5S2V5VHlwZXMsXG4gIHJhbmRvbVN0cmluZzogKCkgPT4gcmFuZG9tU3RyaW5nLFxuICByZXF1aXJlZDogKCkgPT4gcmVxdWlyZWQsXG4gIHN0cmluZ2lmeVByaW1pdGl2ZTogKCkgPT4gc3RyaW5naWZ5UHJpbWl0aXZlLFxuICB1bndyYXBNZXNzYWdlOiAoKSA9PiB1bndyYXBNZXNzYWdlXG59KTtcbmZ1bmN0aW9uIGFzc2VydEVxdWFsKHZhbCkge1xuICByZXR1cm4gdmFsO1xufVxuZnVuY3Rpb24gYXNzZXJ0Tm90RXF1YWwodmFsKSB7XG4gIHJldHVybiB2YWw7XG59XG5mdW5jdGlvbiBhc3NlcnRJcyhfYXJnKSB7XG59XG5mdW5jdGlvbiBhc3NlcnROZXZlcihfeCkge1xuICB0aHJvdyBuZXcgRXJyb3IoKTtcbn1cbmZ1bmN0aW9uIGFzc2VydChfKSB7XG59XG5mdW5jdGlvbiBnZXRFbnVtVmFsdWVzKGVudHJpZXMpIHtcbiAgY29uc3QgbnVtZXJpY1ZhbHVlcyA9IE9iamVjdC52YWx1ZXMoZW50cmllcykuZmlsdGVyKCh2KSA9PiB0eXBlb2YgdiA9PT0gXCJudW1iZXJcIik7XG4gIGNvbnN0IHZhbHVlcyA9IE9iamVjdC5lbnRyaWVzKGVudHJpZXMpLmZpbHRlcigoW2ssIF9dKSA9PiBudW1lcmljVmFsdWVzLmluZGV4T2YoK2spID09PSAtMSkubWFwKChbXywgdl0pID0+IHYpO1xuICByZXR1cm4gdmFsdWVzO1xufVxuZnVuY3Rpb24gam9pblZhbHVlcyhhcnJheTIsIHNlcGFyYXRvciA9IFwifFwiKSB7XG4gIHJldHVybiBhcnJheTIubWFwKCh2YWwpID0+IHN0cmluZ2lmeVByaW1pdGl2ZSh2YWwpKS5qb2luKHNlcGFyYXRvcik7XG59XG5mdW5jdGlvbiBqc29uU3RyaW5naWZ5UmVwbGFjZXIoXywgdmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIilcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gY2FjaGVkKGdldHRlcikge1xuICBjb25zdCBzZXQgPSBmYWxzZTtcbiAgcmV0dXJuIHtcbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICBpZiAoIXNldCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGdldHRlcigpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2YWx1ZVwiLCB7IHZhbHVlIH0pO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYWNoZWQgdmFsdWUgYWxyZWFkeSBzZXRcIik7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gbnVsbGlzaChpbnB1dCkge1xuICByZXR1cm4gaW5wdXQgPT09IG51bGwgfHwgaW5wdXQgPT09IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGNsZWFuUmVnZXgoc291cmNlKSB7XG4gIGNvbnN0IHN0YXJ0ID0gc291cmNlLnN0YXJ0c1dpdGgoXCJeXCIpID8gMSA6IDA7XG4gIGNvbnN0IGVuZCA9IHNvdXJjZS5lbmRzV2l0aChcIiRcIikgPyBzb3VyY2UubGVuZ3RoIC0gMSA6IHNvdXJjZS5sZW5ndGg7XG4gIHJldHVybiBzb3VyY2Uuc2xpY2Uoc3RhcnQsIGVuZCk7XG59XG5mdW5jdGlvbiBmbG9hdFNhZmVSZW1haW5kZXIodmFsLCBzdGVwKSB7XG4gIGNvbnN0IHZhbERlY0NvdW50ID0gKHZhbC50b1N0cmluZygpLnNwbGl0KFwiLlwiKVsxXSB8fCBcIlwiKS5sZW5ndGg7XG4gIGNvbnN0IHN0ZXBEZWNDb3VudCA9IChzdGVwLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpWzFdIHx8IFwiXCIpLmxlbmd0aDtcbiAgY29uc3QgZGVjQ291bnQgPSB2YWxEZWNDb3VudCA+IHN0ZXBEZWNDb3VudCA/IHZhbERlY0NvdW50IDogc3RlcERlY0NvdW50O1xuICBjb25zdCB2YWxJbnQgPSBOdW1iZXIucGFyc2VJbnQodmFsLnRvRml4ZWQoZGVjQ291bnQpLnJlcGxhY2UoXCIuXCIsIFwiXCIpKTtcbiAgY29uc3Qgc3RlcEludCA9IE51bWJlci5wYXJzZUludChzdGVwLnRvRml4ZWQoZGVjQ291bnQpLnJlcGxhY2UoXCIuXCIsIFwiXCIpKTtcbiAgcmV0dXJuIHZhbEludCAlIHN0ZXBJbnQgLyAxMCAqKiBkZWNDb3VudDtcbn1cbmZ1bmN0aW9uIGRlZmluZUxhenkob2JqZWN0LCBrZXksIGdldHRlcikge1xuICBjb25zdCBzZXQgPSBmYWxzZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwga2V5LCB7XG4gICAgZ2V0KCkge1xuICAgICAgaWYgKCFzZXQpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBnZXR0ZXIoKTtcbiAgICAgICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2FjaGVkIHZhbHVlIGFscmVhZHkgc2V0XCIpO1xuICAgIH0sXG4gICAgc2V0KHYpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge1xuICAgICAgICB2YWx1ZTogdlxuICAgICAgICAvLyBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB9KTtcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cbmZ1bmN0aW9uIGFzc2lnblByb3AodGFyZ2V0LCBwcm9wLCB2YWx1ZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wLCB7XG4gICAgdmFsdWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRFbGVtZW50QXRQYXRoKG9iaiwgcGF0aCkge1xuICBpZiAoIXBhdGgpXG4gICAgcmV0dXJuIG9iajtcbiAgcmV0dXJuIHBhdGgucmVkdWNlKChhY2MsIGtleSkgPT4gYWNjPy5ba2V5XSwgb2JqKTtcbn1cbmZ1bmN0aW9uIHByb21pc2VBbGxPYmplY3QocHJvbWlzZXNPYmopIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHByb21pc2VzT2JqKTtcbiAgY29uc3QgcHJvbWlzZXMgPSBrZXlzLm1hcCgoa2V5KSA9PiBwcm9taXNlc09ialtrZXldKTtcbiAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKChyZXN1bHRzKSA9PiB7XG4gICAgY29uc3QgcmVzb2x2ZWRPYmogPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc29sdmVkT2JqW2tleXNbaV1dID0gcmVzdWx0c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc29sdmVkT2JqO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHJhbmRvbVN0cmluZyhsZW5ndGggPSAxMCkge1xuICBjb25zdCBjaGFycyA9IFwiYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIjtcbiAgbGV0IHN0ciA9IFwiXCI7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBzdHIgKz0gY2hhcnNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY2hhcnMubGVuZ3RoKV07XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn1cbmZ1bmN0aW9uIGVzYyhzdHIpIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHN0cik7XG59XG52YXIgY2FwdHVyZVN0YWNrVHJhY2UgPSBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSA/IEVycm9yLmNhcHR1cmVTdGFja1RyYWNlIDogKC4uLl9hcmdzKSA9PiB7XG59O1xuZnVuY3Rpb24gaXNPYmplY3QoZGF0YSkge1xuICByZXR1cm4gdHlwZW9mIGRhdGEgPT09IFwib2JqZWN0XCIgJiYgZGF0YSAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheShkYXRhKTtcbn1cbnZhciBhbGxvd3NFdmFsID0gY2FjaGVkKCgpID0+IHtcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiYgbmF2aWdhdG9yPy51c2VyQWdlbnQ/LmluY2x1ZGVzKFwiQ2xvdWRmbGFyZVwiKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IEYgPSBGdW5jdGlvbjtcbiAgICBuZXcgRihcIlwiKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufSk7XG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KG8pIHtcbiAgaWYgKGlzT2JqZWN0KG8pID09PSBmYWxzZSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IGN0b3IgPSBvLmNvbnN0cnVjdG9yO1xuICBpZiAoY3RvciA9PT0gdm9pZCAwKVxuICAgIHJldHVybiB0cnVlO1xuICBjb25zdCBwcm90ID0gY3Rvci5wcm90b3R5cGU7XG4gIGlmIChpc09iamVjdChwcm90KSA9PT0gZmFsc2UpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3QsIFwiaXNQcm90b3R5cGVPZlwiKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBudW1LZXlzKGRhdGEpIHtcbiAgbGV0IGtleUNvdW50ID0gMDtcbiAgZm9yIChjb25zdCBrZXkgaW4gZGF0YSkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSkge1xuICAgICAga2V5Q291bnQrKztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGtleUNvdW50O1xufVxudmFyIGdldFBhcnNlZFR5cGUgPSAoZGF0YSkgPT4ge1xuICBjb25zdCB0ID0gdHlwZW9mIGRhdGE7XG4gIHN3aXRjaCAodCkge1xuICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgIHJldHVybiBcInVuZGVmaW5lZFwiO1xuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgIHJldHVybiBOdW1iZXIuaXNOYU4oZGF0YSkgPyBcIm5hblwiIDogXCJudW1iZXJcIjtcbiAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgcmV0dXJuIFwiYm9vbGVhblwiO1xuICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgcmV0dXJuIFwiZnVuY3Rpb25cIjtcbiAgICBjYXNlIFwiYmlnaW50XCI6XG4gICAgICByZXR1cm4gXCJiaWdpbnRcIjtcbiAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgICByZXR1cm4gXCJzeW1ib2xcIjtcbiAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICByZXR1cm4gXCJhcnJheVwiO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEudGhlbiAmJiB0eXBlb2YgZGF0YS50aGVuID09PSBcImZ1bmN0aW9uXCIgJiYgZGF0YS5jYXRjaCAmJiB0eXBlb2YgZGF0YS5jYXRjaCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBcInByb21pc2VcIjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgTWFwICE9PSBcInVuZGVmaW5lZFwiICYmIGRhdGEgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgcmV0dXJuIFwibWFwXCI7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIFNldCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkYXRhIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgIHJldHVybiBcInNldFwiO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBEYXRlICE9PSBcInVuZGVmaW5lZFwiICYmIGRhdGEgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiBcImRhdGVcIjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgRmlsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkYXRhIGluc3RhbmNlb2YgRmlsZSkge1xuICAgICAgICByZXR1cm4gXCJmaWxlXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gXCJvYmplY3RcIjtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGRhdGEgdHlwZTogJHt0fWApO1xuICB9XG59O1xudmFyIHByb3BlcnR5S2V5VHlwZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJzdHJpbmdcIiwgXCJudW1iZXJcIiwgXCJzeW1ib2xcIl0pO1xudmFyIHByaW1pdGl2ZVR5cGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wic3RyaW5nXCIsIFwibnVtYmVyXCIsIFwiYmlnaW50XCIsIFwiYm9vbGVhblwiLCBcInN5bWJvbFwiLCBcInVuZGVmaW5lZFwiXSk7XG5mdW5jdGlvbiBlc2NhcGVSZWdleChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgXCJcXFxcJCZcIik7XG59XG5mdW5jdGlvbiBjbG9uZShpbnN0LCBkZWYsIHBhcmFtcykge1xuICBjb25zdCBjbCA9IG5ldyBpbnN0Ll96b2QuY29uc3RyKGRlZiA/PyBpbnN0Ll96b2QuZGVmKTtcbiAgaWYgKCFkZWYgfHwgcGFyYW1zPy5wYXJlbnQpXG4gICAgY2wuX3pvZC5wYXJlbnQgPSBpbnN0O1xuICByZXR1cm4gY2w7XG59XG5mdW5jdGlvbiBub3JtYWxpemVQYXJhbXMoX3BhcmFtcykge1xuICBjb25zdCBwYXJhbXMgPSBfcGFyYW1zO1xuICBpZiAoIXBhcmFtcylcbiAgICByZXR1cm4ge307XG4gIGlmICh0eXBlb2YgcGFyYW1zID09PSBcInN0cmluZ1wiKVxuICAgIHJldHVybiB7IGVycm9yOiAoKSA9PiBwYXJhbXMgfTtcbiAgaWYgKHBhcmFtcz8ubWVzc2FnZSAhPT0gdm9pZCAwKSB7XG4gICAgaWYgKHBhcmFtcz8uZXJyb3IgIT09IHZvaWQgMClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzcGVjaWZ5IGJvdGggYG1lc3NhZ2VgIGFuZCBgZXJyb3JgIHBhcmFtc1wiKTtcbiAgICBwYXJhbXMuZXJyb3IgPSBwYXJhbXMubWVzc2FnZTtcbiAgfVxuICBkZWxldGUgcGFyYW1zLm1lc3NhZ2U7XG4gIGlmICh0eXBlb2YgcGFyYW1zLmVycm9yID09PSBcInN0cmluZ1wiKVxuICAgIHJldHVybiB7IC4uLnBhcmFtcywgZXJyb3I6ICgpID0+IHBhcmFtcy5lcnJvciB9O1xuICByZXR1cm4gcGFyYW1zO1xufVxuZnVuY3Rpb24gY3JlYXRlVHJhbnNwYXJlbnRQcm94eShnZXR0ZXIpIHtcbiAgbGV0IHRhcmdldDtcbiAgcmV0dXJuIG5ldyBQcm94eSh7fSwge1xuICAgIGdldChfLCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgdGFyZ2V0ID8/ICh0YXJnZXQgPSBnZXR0ZXIoKSk7XG4gICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgfSxcbiAgICBzZXQoXywgcHJvcCwgdmFsdWUsIHJlY2VpdmVyKSB7XG4gICAgICB0YXJnZXQgPz8gKHRhcmdldCA9IGdldHRlcigpKTtcbiAgICAgIHJldHVybiBSZWZsZWN0LnNldCh0YXJnZXQsIHByb3AsIHZhbHVlLCByZWNlaXZlcik7XG4gICAgfSxcbiAgICBoYXMoXywgcHJvcCkge1xuICAgICAgdGFyZ2V0ID8/ICh0YXJnZXQgPSBnZXR0ZXIoKSk7XG4gICAgICByZXR1cm4gUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wKTtcbiAgICB9LFxuICAgIGRlbGV0ZVByb3BlcnR5KF8sIHByb3ApIHtcbiAgICAgIHRhcmdldCA/PyAodGFyZ2V0ID0gZ2V0dGVyKCkpO1xuICAgICAgcmV0dXJuIFJlZmxlY3QuZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wKTtcbiAgICB9LFxuICAgIG93bktleXMoXykge1xuICAgICAgdGFyZ2V0ID8/ICh0YXJnZXQgPSBnZXR0ZXIoKSk7XG4gICAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKHRhcmdldCk7XG4gICAgfSxcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoXywgcHJvcCkge1xuICAgICAgdGFyZ2V0ID8/ICh0YXJnZXQgPSBnZXR0ZXIoKSk7XG4gICAgICByZXR1cm4gUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wKTtcbiAgICB9LFxuICAgIGRlZmluZVByb3BlcnR5KF8sIHByb3AsIGRlc2NyaXB0b3IpIHtcbiAgICAgIHRhcmdldCA/PyAodGFyZ2V0ID0gZ2V0dGVyKCkpO1xuICAgICAgcmV0dXJuIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wLCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5UHJpbWl0aXZlKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYmlnaW50XCIpXG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCkgKyBcIm5cIjtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4gYFwiJHt2YWx1ZX1cImA7XG4gIHJldHVybiBgJHt2YWx1ZX1gO1xufVxuZnVuY3Rpb24gb3B0aW9uYWxLZXlzKHNoYXBlKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhzaGFwZSkuZmlsdGVyKChrKSA9PiB7XG4gICAgcmV0dXJuIHNoYXBlW2tdLl96b2Qub3B0aW4gPT09IFwib3B0aW9uYWxcIiAmJiBzaGFwZVtrXS5fem9kLm9wdG91dCA9PT0gXCJvcHRpb25hbFwiO1xuICB9KTtcbn1cbnZhciBOVU1CRVJfRk9STUFUX1JBTkdFUyA9IHtcbiAgc2FmZWludDogW051bWJlci5NSU5fU0FGRV9JTlRFR0VSLCBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUl0sXG4gIGludDMyOiBbLTIxNDc0ODM2NDgsIDIxNDc0ODM2NDddLFxuICB1aW50MzI6IFswLCA0Mjk0OTY3Mjk1XSxcbiAgZmxvYXQzMjogWy0zNDAyODIzNDY2Mzg1Mjg4NmUyMiwgMzQwMjgyMzQ2NjM4NTI4ODZlMjJdLFxuICBmbG9hdDY0OiBbLU51bWJlci5NQVhfVkFMVUUsIE51bWJlci5NQVhfVkFMVUVdXG59O1xudmFyIEJJR0lOVF9GT1JNQVRfUkFOR0VTID0ge1xuICBpbnQ2NDogWy8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoXCItOTIyMzM3MjAzNjg1NDc3NTgwOFwiKSwgLyogQF9fUFVSRV9fICovIEJpZ0ludChcIjkyMjMzNzIwMzY4NTQ3NzU4MDdcIildLFxuICB1aW50NjQ6IFsvKiBAX19QVVJFX18gKi8gQmlnSW50KDApLCAvKiBAX19QVVJFX18gKi8gQmlnSW50KFwiMTg0NDY3NDQwNzM3MDk1NTE2MTVcIildXG59O1xuZnVuY3Rpb24gcGljayhzY2hlbWEsIG1hc2spIHtcbiAgY29uc3QgbmV3U2hhcGUgPSB7fTtcbiAgY29uc3QgY3VyckRlZiA9IHNjaGVtYS5fem9kLmRlZjtcbiAgZm9yIChjb25zdCBrZXkgaW4gbWFzaykge1xuICAgIGlmICghKGtleSBpbiBjdXJyRGVmLnNoYXBlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQga2V5OiBcIiR7a2V5fVwiYCk7XG4gICAgfVxuICAgIGlmICghbWFza1trZXldKVxuICAgICAgY29udGludWU7XG4gICAgbmV3U2hhcGVba2V5XSA9IGN1cnJEZWYuc2hhcGVba2V5XTtcbiAgfVxuICByZXR1cm4gY2xvbmUoc2NoZW1hLCB7XG4gICAgLi4uc2NoZW1hLl96b2QuZGVmLFxuICAgIHNoYXBlOiBuZXdTaGFwZSxcbiAgICBjaGVja3M6IFtdXG4gIH0pO1xufVxuZnVuY3Rpb24gb21pdChzY2hlbWEsIG1hc2spIHtcbiAgY29uc3QgbmV3U2hhcGUgPSB7IC4uLnNjaGVtYS5fem9kLmRlZi5zaGFwZSB9O1xuICBjb25zdCBjdXJyRGVmID0gc2NoZW1hLl96b2QuZGVmO1xuICBmb3IgKGNvbnN0IGtleSBpbiBtYXNrKSB7XG4gICAgaWYgKCEoa2V5IGluIGN1cnJEZWYuc2hhcGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBrZXk6IFwiJHtrZXl9XCJgKTtcbiAgICB9XG4gICAgaWYgKCFtYXNrW2tleV0pXG4gICAgICBjb250aW51ZTtcbiAgICBkZWxldGUgbmV3U2hhcGVba2V5XTtcbiAgfVxuICByZXR1cm4gY2xvbmUoc2NoZW1hLCB7XG4gICAgLi4uc2NoZW1hLl96b2QuZGVmLFxuICAgIHNoYXBlOiBuZXdTaGFwZSxcbiAgICBjaGVja3M6IFtdXG4gIH0pO1xufVxuZnVuY3Rpb24gZXh0ZW5kKHNjaGVtYSwgc2hhcGUpIHtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KHNoYXBlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdG8gZXh0ZW5kOiBleHBlY3RlZCBhIHBsYWluIG9iamVjdFwiKTtcbiAgfVxuICBjb25zdCBkZWYgPSB7XG4gICAgLi4uc2NoZW1hLl96b2QuZGVmLFxuICAgIGdldCBzaGFwZSgpIHtcbiAgICAgIGNvbnN0IF9zaGFwZSA9IHsgLi4uc2NoZW1hLl96b2QuZGVmLnNoYXBlLCAuLi5zaGFwZSB9O1xuICAgICAgYXNzaWduUHJvcCh0aGlzLCBcInNoYXBlXCIsIF9zaGFwZSk7XG4gICAgICByZXR1cm4gX3NoYXBlO1xuICAgIH0sXG4gICAgY2hlY2tzOiBbXVxuICAgIC8vIGRlbGV0ZSBleGlzdGluZyBjaGVja3NcbiAgfTtcbiAgcmV0dXJuIGNsb25lKHNjaGVtYSwgZGVmKTtcbn1cbmZ1bmN0aW9uIG1lcmdlKGEsIGIpIHtcbiAgcmV0dXJuIGNsb25lKGEsIHtcbiAgICAuLi5hLl96b2QuZGVmLFxuICAgIGdldCBzaGFwZSgpIHtcbiAgICAgIGNvbnN0IF9zaGFwZSA9IHsgLi4uYS5fem9kLmRlZi5zaGFwZSwgLi4uYi5fem9kLmRlZi5zaGFwZSB9O1xuICAgICAgYXNzaWduUHJvcCh0aGlzLCBcInNoYXBlXCIsIF9zaGFwZSk7XG4gICAgICByZXR1cm4gX3NoYXBlO1xuICAgIH0sXG4gICAgY2F0Y2hhbGw6IGIuX3pvZC5kZWYuY2F0Y2hhbGwsXG4gICAgY2hlY2tzOiBbXVxuICAgIC8vIGRlbGV0ZSBleGlzdGluZyBjaGVja3NcbiAgfSk7XG59XG5mdW5jdGlvbiBwYXJ0aWFsKENsYXNzMiwgc2NoZW1hLCBtYXNrKSB7XG4gIGNvbnN0IG9sZFNoYXBlID0gc2NoZW1hLl96b2QuZGVmLnNoYXBlO1xuICBjb25zdCBzaGFwZSA9IHsgLi4ub2xkU2hhcGUgfTtcbiAgaWYgKG1hc2spIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBtYXNrKSB7XG4gICAgICBpZiAoIShrZXkgaW4gb2xkU2hhcGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIGtleTogXCIke2tleX1cImApO1xuICAgICAgfVxuICAgICAgaWYgKCFtYXNrW2tleV0pXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgc2hhcGVba2V5XSA9IENsYXNzMiA/IG5ldyBDbGFzczIoe1xuICAgICAgICB0eXBlOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgIGlubmVyVHlwZTogb2xkU2hhcGVba2V5XVxuICAgICAgfSkgOiBvbGRTaGFwZVtrZXldO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvbGRTaGFwZSkge1xuICAgICAgc2hhcGVba2V5XSA9IENsYXNzMiA/IG5ldyBDbGFzczIoe1xuICAgICAgICB0eXBlOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgIGlubmVyVHlwZTogb2xkU2hhcGVba2V5XVxuICAgICAgfSkgOiBvbGRTaGFwZVtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2xvbmUoc2NoZW1hLCB7XG4gICAgLi4uc2NoZW1hLl96b2QuZGVmLFxuICAgIHNoYXBlLFxuICAgIGNoZWNrczogW11cbiAgfSk7XG59XG5mdW5jdGlvbiByZXF1aXJlZChDbGFzczIsIHNjaGVtYSwgbWFzaykge1xuICBjb25zdCBvbGRTaGFwZSA9IHNjaGVtYS5fem9kLmRlZi5zaGFwZTtcbiAgY29uc3Qgc2hhcGUgPSB7IC4uLm9sZFNoYXBlIH07XG4gIGlmIChtYXNrKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gbWFzaykge1xuICAgICAgaWYgKCEoa2V5IGluIHNoYXBlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBrZXk6IFwiJHtrZXl9XCJgKTtcbiAgICAgIH1cbiAgICAgIGlmICghbWFza1trZXldKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHNoYXBlW2tleV0gPSBuZXcgQ2xhc3MyKHtcbiAgICAgICAgdHlwZTogXCJub25vcHRpb25hbFwiLFxuICAgICAgICBpbm5lclR5cGU6IG9sZFNoYXBlW2tleV1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvbGRTaGFwZSkge1xuICAgICAgc2hhcGVba2V5XSA9IG5ldyBDbGFzczIoe1xuICAgICAgICB0eXBlOiBcIm5vbm9wdGlvbmFsXCIsXG4gICAgICAgIGlubmVyVHlwZTogb2xkU2hhcGVba2V5XVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjbG9uZShzY2hlbWEsIHtcbiAgICAuLi5zY2hlbWEuX3pvZC5kZWYsXG4gICAgc2hhcGUsXG4gICAgLy8gb3B0aW9uYWw6IFtdLFxuICAgIGNoZWNrczogW11cbiAgfSk7XG59XG5mdW5jdGlvbiBhYm9ydGVkKHgsIHN0YXJ0SW5kZXggPSAwKSB7XG4gIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpIDwgeC5pc3N1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoeC5pc3N1ZXNbaV0/LmNvbnRpbnVlICE9PSB0cnVlKVxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gcHJlZml4SXNzdWVzKHBhdGgsIGlzc3Vlcykge1xuICByZXR1cm4gaXNzdWVzLm1hcCgoaXNzKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIChfYSA9IGlzcykucGF0aCA/PyAoX2EucGF0aCA9IFtdKTtcbiAgICBpc3MucGF0aC51bnNoaWZ0KHBhdGgpO1xuICAgIHJldHVybiBpc3M7XG4gIH0pO1xufVxuZnVuY3Rpb24gdW53cmFwTWVzc2FnZShtZXNzYWdlKSB7XG4gIHJldHVybiB0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIiA/IG1lc3NhZ2UgOiBtZXNzYWdlPy5tZXNzYWdlO1xufVxuZnVuY3Rpb24gZmluYWxpemVJc3N1ZShpc3MsIGN0eCwgY29uZmlnMikge1xuICBjb25zdCBmdWxsID0geyAuLi5pc3MsIHBhdGg6IGlzcy5wYXRoID8/IFtdIH07XG4gIGlmICghaXNzLm1lc3NhZ2UpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gdW53cmFwTWVzc2FnZShpc3MuaW5zdD8uX3pvZC5kZWY/LmVycm9yPy4oaXNzKSkgPz8gdW53cmFwTWVzc2FnZShjdHg/LmVycm9yPy4oaXNzKSkgPz8gdW53cmFwTWVzc2FnZShjb25maWcyLmN1c3RvbUVycm9yPy4oaXNzKSkgPz8gdW53cmFwTWVzc2FnZShjb25maWcyLmxvY2FsZUVycm9yPy4oaXNzKSkgPz8gXCJJbnZhbGlkIGlucHV0XCI7XG4gICAgZnVsbC5tZXNzYWdlID0gbWVzc2FnZTtcbiAgfVxuICBkZWxldGUgZnVsbC5pbnN0O1xuICBkZWxldGUgZnVsbC5jb250aW51ZTtcbiAgaWYgKCFjdHg/LnJlcG9ydElucHV0KSB7XG4gICAgZGVsZXRlIGZ1bGwuaW5wdXQ7XG4gIH1cbiAgcmV0dXJuIGZ1bGw7XG59XG5mdW5jdGlvbiBnZXRTaXphYmxlT3JpZ2luKGlucHV0KSB7XG4gIGlmIChpbnB1dCBpbnN0YW5jZW9mIFNldClcbiAgICByZXR1cm4gXCJzZXRcIjtcbiAgaWYgKGlucHV0IGluc3RhbmNlb2YgTWFwKVxuICAgIHJldHVybiBcIm1hcFwiO1xuICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBGaWxlKVxuICAgIHJldHVybiBcImZpbGVcIjtcbiAgcmV0dXJuIFwidW5rbm93blwiO1xufVxuZnVuY3Rpb24gZ2V0TGVuZ3RoYWJsZU9yaWdpbihpbnB1dCkge1xuICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpXG4gICAgcmV0dXJuIFwiYXJyYXlcIjtcbiAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgcmV0dXJuIFwidW5rbm93blwiO1xufVxuZnVuY3Rpb24gaXNzdWUoLi4uYXJncykge1xuICBjb25zdCBbaXNzLCBpbnB1dCwgaW5zdF0gPSBhcmdzO1xuICBpZiAodHlwZW9mIGlzcyA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiB7XG4gICAgICBtZXNzYWdlOiBpc3MsXG4gICAgICBjb2RlOiBcImN1c3RvbVwiLFxuICAgICAgaW5wdXQsXG4gICAgICBpbnN0XG4gICAgfTtcbiAgfVxuICByZXR1cm4geyAuLi5pc3MgfTtcbn1cbmZ1bmN0aW9uIGNsZWFuRW51bShvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKG9iaikuZmlsdGVyKChbaywgX10pID0+IHtcbiAgICByZXR1cm4gTnVtYmVyLmlzTmFOKE51bWJlci5wYXJzZUludChrLCAxMCkpO1xuICB9KS5tYXAoKGVsKSA9PiBlbFsxXSk7XG59XG52YXIgQ2xhc3MgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKC4uLl9hcmdzKSB7XG4gIH1cbn07XG5cbi8vIG5vZGVfbW9kdWxlcy8ucG5wbS96b2RANC4wLjEvbm9kZV9tb2R1bGVzL3pvZC92NC9jb3JlL2Vycm9ycy5qc1xudmFyIGluaXRpYWxpemVyID0gKGluc3QsIGRlZikgPT4ge1xuICBpbnN0Lm5hbWUgPSBcIiRab2RFcnJvclwiO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaW5zdCwgXCJfem9kXCIsIHtcbiAgICB2YWx1ZTogaW5zdC5fem9kLFxuICAgIGVudW1lcmFibGU6IGZhbHNlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaW5zdCwgXCJpc3N1ZXNcIiwge1xuICAgIHZhbHVlOiBkZWYsXG4gICAgZW51bWVyYWJsZTogZmFsc2VcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbnN0LCBcIm1lc3NhZ2VcIiwge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkZWYsIGpzb25TdHJpbmdpZnlSZXBsYWNlciwgMik7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgLy8gY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbnN0LCBcInRvU3RyaW5nXCIsIHtcbiAgICB2YWx1ZTogKCkgPT4gaW5zdC5tZXNzYWdlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlXG4gIH0pO1xufTtcbnZhciAkWm9kRXJyb3IgPSAkY29uc3RydWN0b3IoXCIkWm9kRXJyb3JcIiwgaW5pdGlhbGl6ZXIpO1xudmFyICRab2RSZWFsRXJyb3IgPSAkY29uc3RydWN0b3IoXCIkWm9kRXJyb3JcIiwgaW5pdGlhbGl6ZXIsIHsgUGFyZW50OiBFcnJvciB9KTtcbmZ1bmN0aW9uIGZsYXR0ZW5FcnJvcihlcnJvciwgbWFwcGVyID0gKGlzc3VlMikgPT4gaXNzdWUyLm1lc3NhZ2UpIHtcbiAgY29uc3QgZmllbGRFcnJvcnMgPSB7fTtcbiAgY29uc3QgZm9ybUVycm9ycyA9IFtdO1xuICBmb3IgKGNvbnN0IHN1YiBvZiBlcnJvci5pc3N1ZXMpIHtcbiAgICBpZiAoc3ViLnBhdGgubGVuZ3RoID4gMCkge1xuICAgICAgZmllbGRFcnJvcnNbc3ViLnBhdGhbMF1dID0gZmllbGRFcnJvcnNbc3ViLnBhdGhbMF1dIHx8IFtdO1xuICAgICAgZmllbGRFcnJvcnNbc3ViLnBhdGhbMF1dLnB1c2gobWFwcGVyKHN1YikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3JtRXJyb3JzLnB1c2gobWFwcGVyKHN1YikpO1xuICAgIH1cbiAgfVxuICByZXR1cm4geyBmb3JtRXJyb3JzLCBmaWVsZEVycm9ycyB9O1xufVxuZnVuY3Rpb24gZm9ybWF0RXJyb3IoZXJyb3IsIF9tYXBwZXIpIHtcbiAgY29uc3QgbWFwcGVyID0gX21hcHBlciB8fCBmdW5jdGlvbihpc3N1ZTIpIHtcbiAgICByZXR1cm4gaXNzdWUyLm1lc3NhZ2U7XG4gIH07XG4gIGNvbnN0IGZpZWxkRXJyb3JzID0geyBfZXJyb3JzOiBbXSB9O1xuICBjb25zdCBwcm9jZXNzRXJyb3IgPSAoZXJyb3IyKSA9PiB7XG4gICAgZm9yIChjb25zdCBpc3N1ZTIgb2YgZXJyb3IyLmlzc3Vlcykge1xuICAgICAgaWYgKGlzc3VlMi5jb2RlID09PSBcImludmFsaWRfdW5pb25cIiAmJiBpc3N1ZTIuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICBpc3N1ZTIuZXJyb3JzLm1hcCgoaXNzdWVzKSA9PiBwcm9jZXNzRXJyb3IoeyBpc3N1ZXMgfSkpO1xuICAgICAgfSBlbHNlIGlmIChpc3N1ZTIuY29kZSA9PT0gXCJpbnZhbGlkX2tleVwiKSB7XG4gICAgICAgIHByb2Nlc3NFcnJvcih7IGlzc3VlczogaXNzdWUyLmlzc3VlcyB9KTtcbiAgICAgIH0gZWxzZSBpZiAoaXNzdWUyLmNvZGUgPT09IFwiaW52YWxpZF9lbGVtZW50XCIpIHtcbiAgICAgICAgcHJvY2Vzc0Vycm9yKHsgaXNzdWVzOiBpc3N1ZTIuaXNzdWVzIH0pO1xuICAgICAgfSBlbHNlIGlmIChpc3N1ZTIucGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZmllbGRFcnJvcnMuX2Vycm9ycy5wdXNoKG1hcHBlcihpc3N1ZTIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBjdXJyID0gZmllbGRFcnJvcnM7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBpc3N1ZTIucGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCBlbCA9IGlzc3VlMi5wYXRoW2ldO1xuICAgICAgICAgIGNvbnN0IHRlcm1pbmFsID0gaSA9PT0gaXNzdWUyLnBhdGgubGVuZ3RoIC0gMTtcbiAgICAgICAgICBpZiAoIXRlcm1pbmFsKSB7XG4gICAgICAgICAgICBjdXJyW2VsXSA9IGN1cnJbZWxdIHx8IHsgX2Vycm9yczogW10gfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3VycltlbF0gPSBjdXJyW2VsXSB8fCB7IF9lcnJvcnM6IFtdIH07XG4gICAgICAgICAgICBjdXJyW2VsXS5fZXJyb3JzLnB1c2gobWFwcGVyKGlzc3VlMikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdXJyID0gY3VycltlbF07XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBwcm9jZXNzRXJyb3IoZXJyb3IpO1xuICByZXR1cm4gZmllbGRFcnJvcnM7XG59XG5cbi8vIG5vZGVfbW9kdWxlcy8ucG5wbS96b2RANC4wLjEvbm9kZV9tb2R1bGVzL3pvZC92NC9jb3JlL3BhcnNlLmpzXG52YXIgX3BhcnNlID0gKF9FcnIpID0+IChzY2hlbWEsIHZhbHVlLCBfY3R4LCBfcGFyYW1zKSA9PiB7XG4gIGNvbnN0IGN0eCA9IF9jdHggPyBPYmplY3QuYXNzaWduKF9jdHgsIHsgYXN5bmM6IGZhbHNlIH0pIDogeyBhc3luYzogZmFsc2UgfTtcbiAgY29uc3QgcmVzdWx0ID0gc2NoZW1hLl96b2QucnVuKHsgdmFsdWUsIGlzc3VlczogW10gfSwgY3R4KTtcbiAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICB0aHJvdyBuZXcgJFpvZEFzeW5jRXJyb3IoKTtcbiAgfVxuICBpZiAocmVzdWx0Lmlzc3Vlcy5sZW5ndGgpIHtcbiAgICBjb25zdCBlID0gbmV3IChfcGFyYW1zPy5FcnIgPz8gX0VycikocmVzdWx0Lmlzc3Vlcy5tYXAoKGlzcykgPT4gZmluYWxpemVJc3N1ZShpc3MsIGN0eCwgY29uZmlnKCkpKSk7XG4gICAgY2FwdHVyZVN0YWNrVHJhY2UoZSwgX3BhcmFtcz8uY2FsbGVlKTtcbiAgICB0aHJvdyBlO1xuICB9XG4gIHJldHVybiByZXN1bHQudmFsdWU7XG59O1xudmFyIF9wYXJzZUFzeW5jID0gKF9FcnIpID0+IGFzeW5jIChzY2hlbWEsIHZhbHVlLCBfY3R4LCBwYXJhbXMpID0+IHtcbiAgY29uc3QgY3R4ID0gX2N0eCA/IE9iamVjdC5hc3NpZ24oX2N0eCwgeyBhc3luYzogdHJ1ZSB9KSA6IHsgYXN5bmM6IHRydWUgfTtcbiAgbGV0IHJlc3VsdCA9IHNjaGVtYS5fem9kLnJ1bih7IHZhbHVlLCBpc3N1ZXM6IFtdIH0sIGN0eCk7XG4gIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKVxuICAgIHJlc3VsdCA9IGF3YWl0IHJlc3VsdDtcbiAgaWYgKHJlc3VsdC5pc3N1ZXMubGVuZ3RoKSB7XG4gICAgY29uc3QgZSA9IG5ldyAocGFyYW1zPy5FcnIgPz8gX0VycikocmVzdWx0Lmlzc3Vlcy5tYXAoKGlzcykgPT4gZmluYWxpemVJc3N1ZShpc3MsIGN0eCwgY29uZmlnKCkpKSk7XG4gICAgY2FwdHVyZVN0YWNrVHJhY2UoZSwgcGFyYW1zPy5jYWxsZWUpO1xuICAgIHRocm93IGU7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbn07XG52YXIgX3NhZmVQYXJzZSA9IChfRXJyKSA9PiAoc2NoZW1hLCB2YWx1ZSwgX2N0eCkgPT4ge1xuICBjb25zdCBjdHggPSBfY3R4ID8geyAuLi5fY3R4LCBhc3luYzogZmFsc2UgfSA6IHsgYXN5bmM6IGZhbHNlIH07XG4gIGNvbnN0IHJlc3VsdCA9IHNjaGVtYS5fem9kLnJ1bih7IHZhbHVlLCBpc3N1ZXM6IFtdIH0sIGN0eCk7XG4gIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgdGhyb3cgbmV3ICRab2RBc3luY0Vycm9yKCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdC5pc3N1ZXMubGVuZ3RoID8ge1xuICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgIGVycm9yOiBuZXcgKF9FcnIgPz8gJFpvZEVycm9yKShyZXN1bHQuaXNzdWVzLm1hcCgoaXNzKSA9PiBmaW5hbGl6ZUlzc3VlKGlzcywgY3R4LCBjb25maWcoKSkpKVxuICB9IDogeyBzdWNjZXNzOiB0cnVlLCBkYXRhOiByZXN1bHQudmFsdWUgfTtcbn07XG52YXIgc2FmZVBhcnNlID0gLyogQF9fUFVSRV9fICovIF9zYWZlUGFyc2UoJFpvZFJlYWxFcnJvcik7XG52YXIgX3NhZmVQYXJzZUFzeW5jID0gKF9FcnIpID0+IGFzeW5jIChzY2hlbWEsIHZhbHVlLCBfY3R4KSA9PiB7XG4gIGNvbnN0IGN0eCA9IF9jdHggPyBPYmplY3QuYXNzaWduKF9jdHgsIHsgYXN5bmM6IHRydWUgfSkgOiB7IGFzeW5jOiB0cnVlIH07XG4gIGxldCByZXN1bHQgPSBzY2hlbWEuX3pvZC5ydW4oeyB2YWx1ZSwgaXNzdWVzOiBbXSB9LCBjdHgpO1xuICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSlcbiAgICByZXN1bHQgPSBhd2FpdCByZXN1bHQ7XG4gIHJldHVybiByZXN1bHQuaXNzdWVzLmxlbmd0aCA/IHtcbiAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICBlcnJvcjogbmV3IF9FcnIocmVzdWx0Lmlzc3Vlcy5tYXAoKGlzcykgPT4gZmluYWxpemVJc3N1ZShpc3MsIGN0eCwgY29uZmlnKCkpKSlcbiAgfSA6IHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogcmVzdWx0LnZhbHVlIH07XG59O1xudmFyIHNhZmVQYXJzZUFzeW5jID0gLyogQF9fUFVSRV9fICovIF9zYWZlUGFyc2VBc3luYygkWm9kUmVhbEVycm9yKTtcblxuLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3pvZEA0LjAuMS9ub2RlX21vZHVsZXMvem9kL3Y0L2NvcmUvY2hlY2tzLmpzXG52YXIgJFpvZENoZWNrID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIiRab2RDaGVja1wiLCAoaW5zdCwgZGVmKSA9PiB7XG4gIHZhciBfYTtcbiAgaW5zdC5fem9kID8/IChpbnN0Ll96b2QgPSB7fSk7XG4gIGluc3QuX3pvZC5kZWYgPSBkZWY7XG4gIChfYSA9IGluc3QuX3pvZCkub25hdHRhY2ggPz8gKF9hLm9uYXR0YWNoID0gW10pO1xufSk7XG52YXIgJFpvZENoZWNrTWF4TGVuZ3RoID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIiRab2RDaGVja01heExlbmd0aFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gIHZhciBfYTtcbiAgJFpvZENoZWNrLmluaXQoaW5zdCwgZGVmKTtcbiAgKF9hID0gaW5zdC5fem9kLmRlZikud2hlbiA/PyAoX2Eud2hlbiA9IChwYXlsb2FkKSA9PiB7XG4gICAgY29uc3QgdmFsID0gcGF5bG9hZC52YWx1ZTtcbiAgICByZXR1cm4gIW51bGxpc2godmFsKSAmJiB2YWwubGVuZ3RoICE9PSB2b2lkIDA7XG4gIH0pO1xuICBpbnN0Ll96b2Qub25hdHRhY2gucHVzaCgoaW5zdDIpID0+IHtcbiAgICBjb25zdCBjdXJyID0gaW5zdDIuX3pvZC5iYWcubWF4aW11bSA/PyBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgaWYgKGRlZi5tYXhpbXVtIDwgY3VycilcbiAgICAgIGluc3QyLl96b2QuYmFnLm1heGltdW0gPSBkZWYubWF4aW11bTtcbiAgfSk7XG4gIGluc3QuX3pvZC5jaGVjayA9IChwYXlsb2FkKSA9PiB7XG4gICAgY29uc3QgaW5wdXQgPSBwYXlsb2FkLnZhbHVlO1xuICAgIGNvbnN0IGxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoIDw9IGRlZi5tYXhpbXVtKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG9yaWdpbiA9IGdldExlbmd0aGFibGVPcmlnaW4oaW5wdXQpO1xuICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgb3JpZ2luLFxuICAgICAgY29kZTogXCJ0b29fYmlnXCIsXG4gICAgICBtYXhpbXVtOiBkZWYubWF4aW11bSxcbiAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgIGlucHV0LFxuICAgICAgaW5zdCxcbiAgICAgIGNvbnRpbnVlOiAhZGVmLmFib3J0XG4gICAgfSk7XG4gIH07XG59KTtcbnZhciAkWm9kQ2hlY2tNaW5MZW5ndGggPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiJFpvZENoZWNrTWluTGVuZ3RoXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgdmFyIF9hO1xuICAkWm9kQ2hlY2suaW5pdChpbnN0LCBkZWYpO1xuICAoX2EgPSBpbnN0Ll96b2QuZGVmKS53aGVuID8/IChfYS53aGVuID0gKHBheWxvYWQpID0+IHtcbiAgICBjb25zdCB2YWwgPSBwYXlsb2FkLnZhbHVlO1xuICAgIHJldHVybiAhbnVsbGlzaCh2YWwpICYmIHZhbC5sZW5ndGggIT09IHZvaWQgMDtcbiAgfSk7XG4gIGluc3QuX3pvZC5vbmF0dGFjaC5wdXNoKChpbnN0MikgPT4ge1xuICAgIGNvbnN0IGN1cnIgPSBpbnN0Mi5fem9kLmJhZy5taW5pbXVtID8/IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICBpZiAoZGVmLm1pbmltdW0gPiBjdXJyKVxuICAgICAgaW5zdDIuX3pvZC5iYWcubWluaW11bSA9IGRlZi5taW5pbXVtO1xuICB9KTtcbiAgaW5zdC5fem9kLmNoZWNrID0gKHBheWxvYWQpID0+IHtcbiAgICBjb25zdCBpbnB1dCA9IHBheWxvYWQudmFsdWU7XG4gICAgY29uc3QgbGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPj0gZGVmLm1pbmltdW0pXG4gICAgICByZXR1cm47XG4gICAgY29uc3Qgb3JpZ2luID0gZ2V0TGVuZ3RoYWJsZU9yaWdpbihpbnB1dCk7XG4gICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICBvcmlnaW4sXG4gICAgICBjb2RlOiBcInRvb19zbWFsbFwiLFxuICAgICAgbWluaW11bTogZGVmLm1pbmltdW0sXG4gICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICBpbnB1dCxcbiAgICAgIGluc3QsXG4gICAgICBjb250aW51ZTogIWRlZi5hYm9ydFxuICAgIH0pO1xuICB9O1xufSk7XG52YXIgJFpvZENoZWNrTGVuZ3RoRXF1YWxzID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIiRab2RDaGVja0xlbmd0aEVxdWFsc1wiLCAoaW5zdCwgZGVmKSA9PiB7XG4gIHZhciBfYTtcbiAgJFpvZENoZWNrLmluaXQoaW5zdCwgZGVmKTtcbiAgKF9hID0gaW5zdC5fem9kLmRlZikud2hlbiA/PyAoX2Eud2hlbiA9IChwYXlsb2FkKSA9PiB7XG4gICAgY29uc3QgdmFsID0gcGF5bG9hZC52YWx1ZTtcbiAgICByZXR1cm4gIW51bGxpc2godmFsKSAmJiB2YWwubGVuZ3RoICE9PSB2b2lkIDA7XG4gIH0pO1xuICBpbnN0Ll96b2Qub25hdHRhY2gucHVzaCgoaW5zdDIpID0+IHtcbiAgICBjb25zdCBiYWcgPSBpbnN0Mi5fem9kLmJhZztcbiAgICBiYWcubWluaW11bSA9IGRlZi5sZW5ndGg7XG4gICAgYmFnLm1heGltdW0gPSBkZWYubGVuZ3RoO1xuICAgIGJhZy5sZW5ndGggPSBkZWYubGVuZ3RoO1xuICB9KTtcbiAgaW5zdC5fem9kLmNoZWNrID0gKHBheWxvYWQpID0+IHtcbiAgICBjb25zdCBpbnB1dCA9IHBheWxvYWQudmFsdWU7XG4gICAgY29uc3QgbGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPT09IGRlZi5sZW5ndGgpXG4gICAgICByZXR1cm47XG4gICAgY29uc3Qgb3JpZ2luID0gZ2V0TGVuZ3RoYWJsZU9yaWdpbihpbnB1dCk7XG4gICAgY29uc3QgdG9vQmlnID0gbGVuZ3RoID4gZGVmLmxlbmd0aDtcbiAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgIG9yaWdpbixcbiAgICAgIC4uLnRvb0JpZyA/IHsgY29kZTogXCJ0b29fYmlnXCIsIG1heGltdW06IGRlZi5sZW5ndGggfSA6IHsgY29kZTogXCJ0b29fc21hbGxcIiwgbWluaW11bTogZGVmLmxlbmd0aCB9LFxuICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgZXhhY3Q6IHRydWUsXG4gICAgICBpbnB1dDogcGF5bG9hZC52YWx1ZSxcbiAgICAgIGluc3QsXG4gICAgICBjb250aW51ZTogIWRlZi5hYm9ydFxuICAgIH0pO1xuICB9O1xufSk7XG52YXIgJFpvZENoZWNrT3ZlcndyaXRlID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIiRab2RDaGVja092ZXJ3cml0ZVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICRab2RDaGVjay5pbml0KGluc3QsIGRlZik7XG4gIGluc3QuX3pvZC5jaGVjayA9IChwYXlsb2FkKSA9PiB7XG4gICAgcGF5bG9hZC52YWx1ZSA9IGRlZi50eChwYXlsb2FkLnZhbHVlKTtcbiAgfTtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvLnBucG0vem9kQDQuMC4xL25vZGVfbW9kdWxlcy96b2QvdjQvY29yZS9kb2MuanNcbnZhciBEb2MgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGFyZ3MgPSBbXSkge1xuICAgIHRoaXMuY29udGVudCA9IFtdO1xuICAgIHRoaXMuaW5kZW50ID0gMDtcbiAgICBpZiAodGhpcylcbiAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gIH1cbiAgaW5kZW50ZWQoZm4pIHtcbiAgICB0aGlzLmluZGVudCArPSAxO1xuICAgIGZuKHRoaXMpO1xuICAgIHRoaXMuaW5kZW50IC09IDE7XG4gIH1cbiAgd3JpdGUoYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgYXJnKHRoaXMsIHsgZXhlY3V0aW9uOiBcInN5bmNcIiB9KTtcbiAgICAgIGFyZyh0aGlzLCB7IGV4ZWN1dGlvbjogXCJhc3luY1wiIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjb250ZW50ID0gYXJnO1xuICAgIGNvbnN0IGxpbmVzID0gY29udGVudC5zcGxpdChcIlxcblwiKS5maWx0ZXIoKHgpID0+IHgpO1xuICAgIGNvbnN0IG1pbkluZGVudCA9IE1hdGgubWluKC4uLmxpbmVzLm1hcCgoeCkgPT4geC5sZW5ndGggLSB4LnRyaW1TdGFydCgpLmxlbmd0aCkpO1xuICAgIGNvbnN0IGRlZGVudGVkID0gbGluZXMubWFwKCh4KSA9PiB4LnNsaWNlKG1pbkluZGVudCkpLm1hcCgoeCkgPT4gXCIgXCIucmVwZWF0KHRoaXMuaW5kZW50ICogMikgKyB4KTtcbiAgICBmb3IgKGNvbnN0IGxpbmUgb2YgZGVkZW50ZWQpIHtcbiAgICAgIHRoaXMuY29udGVudC5wdXNoKGxpbmUpO1xuICAgIH1cbiAgfVxuICBjb21waWxlKCkge1xuICAgIGNvbnN0IEYgPSBGdW5jdGlvbjtcbiAgICBjb25zdCBhcmdzID0gdGhpcz8uYXJncztcbiAgICBjb25zdCBjb250ZW50ID0gdGhpcz8uY29udGVudCA/PyBbYGBdO1xuICAgIGNvbnN0IGxpbmVzID0gWy4uLmNvbnRlbnQubWFwKCh4KSA9PiBgICAke3h9YCldO1xuICAgIHJldHVybiBuZXcgRiguLi5hcmdzLCBsaW5lcy5qb2luKFwiXFxuXCIpKTtcbiAgfVxufTtcblxuLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3pvZEA0LjAuMS9ub2RlX21vZHVsZXMvem9kL3Y0L2NvcmUvdmVyc2lvbnMuanNcbnZhciB2ZXJzaW9uID0ge1xuICBtYWpvcjogNCxcbiAgbWlub3I6IDAsXG4gIHBhdGNoOiAwXG59O1xuXG4vLyBub2RlX21vZHVsZXMvLnBucG0vem9kQDQuMC4xL25vZGVfbW9kdWxlcy96b2QvdjQvY29yZS9zY2hlbWFzLmpzXG52YXIgJFpvZFR5cGUgPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiJFpvZFR5cGVcIiwgKGluc3QsIGRlZikgPT4ge1xuICB2YXIgX2E7XG4gIGluc3QgPz8gKGluc3QgPSB7fSk7XG4gIGluc3QuX3pvZC5kZWYgPSBkZWY7XG4gIGluc3QuX3pvZC5iYWcgPSBpbnN0Ll96b2QuYmFnIHx8IHt9O1xuICBpbnN0Ll96b2QudmVyc2lvbiA9IHZlcnNpb247XG4gIGNvbnN0IGNoZWNrcyA9IFsuLi5pbnN0Ll96b2QuZGVmLmNoZWNrcyA/PyBbXV07XG4gIGlmIChpbnN0Ll96b2QudHJhaXRzLmhhcyhcIiRab2RDaGVja1wiKSkge1xuICAgIGNoZWNrcy51bnNoaWZ0KGluc3QpO1xuICB9XG4gIGZvciAoY29uc3QgY2ggb2YgY2hlY2tzKSB7XG4gICAgZm9yIChjb25zdCBmbiBvZiBjaC5fem9kLm9uYXR0YWNoKSB7XG4gICAgICBmbihpbnN0KTtcbiAgICB9XG4gIH1cbiAgaWYgKGNoZWNrcy5sZW5ndGggPT09IDApIHtcbiAgICAoX2EgPSBpbnN0Ll96b2QpLmRlZmVycmVkID8/IChfYS5kZWZlcnJlZCA9IFtdKTtcbiAgICBpbnN0Ll96b2QuZGVmZXJyZWQ/LnB1c2goKCkgPT4ge1xuICAgICAgaW5zdC5fem9kLnJ1biA9IGluc3QuX3pvZC5wYXJzZTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBydW5DaGVja3MgPSAocGF5bG9hZCwgY2hlY2tzMiwgY3R4KSA9PiB7XG4gICAgICBsZXQgaXNBYm9ydGVkID0gYWJvcnRlZChwYXlsb2FkKTtcbiAgICAgIGxldCBhc3luY1Jlc3VsdDtcbiAgICAgIGZvciAoY29uc3QgY2ggb2YgY2hlY2tzMikge1xuICAgICAgICBpZiAoY2guX3pvZC5kZWYud2hlbikge1xuICAgICAgICAgIGNvbnN0IHNob3VsZFJ1biA9IGNoLl96b2QuZGVmLndoZW4ocGF5bG9hZCk7XG4gICAgICAgICAgaWYgKCFzaG91bGRSdW4pXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0Fib3J0ZWQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyTGVuID0gcGF5bG9hZC5pc3N1ZXMubGVuZ3RoO1xuICAgICAgICBjb25zdCBfID0gY2guX3pvZC5jaGVjayhwYXlsb2FkKTtcbiAgICAgICAgaWYgKF8gaW5zdGFuY2VvZiBQcm9taXNlICYmIGN0eD8uYXN5bmMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3ICRab2RBc3luY0Vycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFzeW5jUmVzdWx0IHx8IF8gaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgYXN5bmNSZXN1bHQgPSAoYXN5bmNSZXN1bHQgPz8gUHJvbWlzZS5yZXNvbHZlKCkpLnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgXztcbiAgICAgICAgICAgIGNvbnN0IG5leHRMZW4gPSBwYXlsb2FkLmlzc3Vlcy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobmV4dExlbiA9PT0gY3VyckxlbilcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKCFpc0Fib3J0ZWQpXG4gICAgICAgICAgICAgIGlzQWJvcnRlZCA9IGFib3J0ZWQocGF5bG9hZCwgY3Vyckxlbik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgbmV4dExlbiA9IHBheWxvYWQuaXNzdWVzLmxlbmd0aDtcbiAgICAgICAgICBpZiAobmV4dExlbiA9PT0gY3VyckxlbilcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGlmICghaXNBYm9ydGVkKVxuICAgICAgICAgICAgaXNBYm9ydGVkID0gYWJvcnRlZChwYXlsb2FkLCBjdXJyTGVuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGFzeW5jUmVzdWx0KSB7XG4gICAgICAgIHJldHVybiBhc3luY1Jlc3VsdC50aGVuKCgpID0+IHtcbiAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICB9O1xuICAgIGluc3QuX3pvZC5ydW4gPSAocGF5bG9hZCwgY3R4KSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBpbnN0Ll96b2QucGFyc2UocGF5bG9hZCwgY3R4KTtcbiAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIGlmIChjdHguYXN5bmMgPT09IGZhbHNlKVxuICAgICAgICAgIHRocm93IG5ldyAkWm9kQXN5bmNFcnJvcigpO1xuICAgICAgICByZXR1cm4gcmVzdWx0LnRoZW4oKHJlc3VsdDIpID0+IHJ1bkNoZWNrcyhyZXN1bHQyLCBjaGVja3MsIGN0eCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJ1bkNoZWNrcyhyZXN1bHQsIGNoZWNrcywgY3R4KTtcbiAgICB9O1xuICB9XG4gIGluc3RbXCJ+c3RhbmRhcmRcIl0gPSB7XG4gICAgdmFsaWRhdGU6ICh2YWx1ZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgciA9IHNhZmVQYXJzZShpbnN0LCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiByLnN1Y2Nlc3MgPyB7IHZhbHVlOiByLmRhdGEgfSA6IHsgaXNzdWVzOiByLmVycm9yPy5pc3N1ZXMgfTtcbiAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgcmV0dXJuIHNhZmVQYXJzZUFzeW5jKGluc3QsIHZhbHVlKS50aGVuKChyKSA9PiByLnN1Y2Nlc3MgPyB7IHZhbHVlOiByLmRhdGEgfSA6IHsgaXNzdWVzOiByLmVycm9yPy5pc3N1ZXMgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB2ZW5kb3I6IFwiem9kXCIsXG4gICAgdmVyc2lvbjogMVxuICB9O1xufSk7XG52YXIgJFpvZFVua25vd24gPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiJFpvZFVua25vd25cIiwgKGluc3QsIGRlZikgPT4ge1xuICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkKSA9PiBwYXlsb2FkO1xufSk7XG52YXIgJFpvZE5ldmVyID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIiRab2ROZXZlclwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIF9jdHgpID0+IHtcbiAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgIGV4cGVjdGVkOiBcIm5ldmVyXCIsXG4gICAgICBjb2RlOiBcImludmFsaWRfdHlwZVwiLFxuICAgICAgaW5wdXQ6IHBheWxvYWQudmFsdWUsXG4gICAgICBpbnN0XG4gICAgfSk7XG4gICAgcmV0dXJuIHBheWxvYWQ7XG4gIH07XG59KTtcbmZ1bmN0aW9uIGhhbmRsZUFycmF5UmVzdWx0KHJlc3VsdCwgZmluYWwsIGluZGV4KSB7XG4gIGlmIChyZXN1bHQuaXNzdWVzLmxlbmd0aCkge1xuICAgIGZpbmFsLmlzc3Vlcy5wdXNoKC4uLnByZWZpeElzc3VlcyhpbmRleCwgcmVzdWx0Lmlzc3VlcykpO1xuICB9XG4gIGZpbmFsLnZhbHVlW2luZGV4XSA9IHJlc3VsdC52YWx1ZTtcbn1cbnZhciAkWm9kQXJyYXkgPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiJFpvZEFycmF5XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgY3R4KSA9PiB7XG4gICAgY29uc3QgaW5wdXQgPSBwYXlsb2FkLnZhbHVlO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICBleHBlY3RlZDogXCJhcnJheVwiLFxuICAgICAgICBjb2RlOiBcImludmFsaWRfdHlwZVwiLFxuICAgICAgICBpbnB1dCxcbiAgICAgICAgaW5zdFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICB9XG4gICAgcGF5bG9hZC52YWx1ZSA9IEFycmF5KGlucHV0Lmxlbmd0aCk7XG4gICAgY29uc3QgcHJvbXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBpdGVtID0gaW5wdXRbaV07XG4gICAgICBjb25zdCByZXN1bHQgPSBkZWYuZWxlbWVudC5fem9kLnJ1bih7XG4gICAgICAgIHZhbHVlOiBpdGVtLFxuICAgICAgICBpc3N1ZXM6IFtdXG4gICAgICB9LCBjdHgpO1xuICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgcHJvbXMucHVzaChyZXN1bHQudGhlbigocmVzdWx0MikgPT4gaGFuZGxlQXJyYXlSZXN1bHQocmVzdWx0MiwgcGF5bG9hZCwgaSkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhbmRsZUFycmF5UmVzdWx0KHJlc3VsdCwgcGF5bG9hZCwgaSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9tcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9tcykudGhlbigoKSA9PiBwYXlsb2FkKTtcbiAgICB9XG4gICAgcmV0dXJuIHBheWxvYWQ7XG4gIH07XG59KTtcbmZ1bmN0aW9uIGhhbmRsZU9iamVjdFJlc3VsdChyZXN1bHQsIGZpbmFsLCBrZXkpIHtcbiAgaWYgKHJlc3VsdC5pc3N1ZXMubGVuZ3RoKSB7XG4gICAgZmluYWwuaXNzdWVzLnB1c2goLi4ucHJlZml4SXNzdWVzKGtleSwgcmVzdWx0Lmlzc3VlcykpO1xuICB9XG4gIGZpbmFsLnZhbHVlW2tleV0gPSByZXN1bHQudmFsdWU7XG59XG5mdW5jdGlvbiBoYW5kbGVPcHRpb25hbE9iamVjdFJlc3VsdChyZXN1bHQsIGZpbmFsLCBrZXksIGlucHV0KSB7XG4gIGlmIChyZXN1bHQuaXNzdWVzLmxlbmd0aCkge1xuICAgIGlmIChpbnB1dFtrZXldID09PSB2b2lkIDApIHtcbiAgICAgIGlmIChrZXkgaW4gaW5wdXQpIHtcbiAgICAgICAgZmluYWwudmFsdWVba2V5XSA9IHZvaWQgMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpbmFsLnZhbHVlW2tleV0gPSByZXN1bHQudmFsdWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpbmFsLmlzc3Vlcy5wdXNoKC4uLnByZWZpeElzc3VlcyhrZXksIHJlc3VsdC5pc3N1ZXMpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocmVzdWx0LnZhbHVlID09PSB2b2lkIDApIHtcbiAgICBpZiAoa2V5IGluIGlucHV0KVxuICAgICAgZmluYWwudmFsdWVba2V5XSA9IHZvaWQgMDtcbiAgfSBlbHNlIHtcbiAgICBmaW5hbC52YWx1ZVtrZXldID0gcmVzdWx0LnZhbHVlO1xuICB9XG59XG52YXIgJFpvZE9iamVjdCA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCIkWm9kT2JqZWN0XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICBjb25zdCBfbm9ybWFsaXplZCA9IGNhY2hlZCgoKSA9PiB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGRlZi5zaGFwZSk7XG4gICAgZm9yIChjb25zdCBrIG9mIGtleXMpIHtcbiAgICAgIGlmICghKGRlZi5zaGFwZVtrXSBpbnN0YW5jZW9mICRab2RUeXBlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZWxlbWVudCBhdCBrZXkgXCIke2t9XCI6IGV4cGVjdGVkIGEgWm9kIHNjaGVtYWApO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBva2V5cyA9IG9wdGlvbmFsS2V5cyhkZWYuc2hhcGUpO1xuICAgIHJldHVybiB7XG4gICAgICBzaGFwZTogZGVmLnNoYXBlLFxuICAgICAga2V5cyxcbiAgICAgIGtleVNldDogbmV3IFNldChrZXlzKSxcbiAgICAgIG51bUtleXM6IGtleXMubGVuZ3RoLFxuICAgICAgb3B0aW9uYWxLZXlzOiBuZXcgU2V0KG9rZXlzKVxuICAgIH07XG4gIH0pO1xuICBkZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJwcm9wVmFsdWVzXCIsICgpID0+IHtcbiAgICBjb25zdCBzaGFwZSA9IGRlZi5zaGFwZTtcbiAgICBjb25zdCBwcm9wVmFsdWVzID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2hhcGUpIHtcbiAgICAgIGNvbnN0IGZpZWxkID0gc2hhcGVba2V5XS5fem9kO1xuICAgICAgaWYgKGZpZWxkLnZhbHVlcykge1xuICAgICAgICBwcm9wVmFsdWVzW2tleV0gPz8gKHByb3BWYWx1ZXNba2V5XSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpO1xuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgZmllbGQudmFsdWVzKVxuICAgICAgICAgIHByb3BWYWx1ZXNba2V5XS5hZGQodik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcm9wVmFsdWVzO1xuICB9KTtcbiAgY29uc3QgZ2VuZXJhdGVGYXN0cGFzcyA9IChzaGFwZSkgPT4ge1xuICAgIGNvbnN0IGRvYyA9IG5ldyBEb2MoW1wic2hhcGVcIiwgXCJwYXlsb2FkXCIsIFwiY3R4XCJdKTtcbiAgICBjb25zdCBub3JtYWxpemVkID0gX25vcm1hbGl6ZWQudmFsdWU7XG4gICAgY29uc3QgcGFyc2VTdHIgPSAoa2V5KSA9PiB7XG4gICAgICBjb25zdCBrID0gZXNjKGtleSk7XG4gICAgICByZXR1cm4gYHNoYXBlWyR7a31dLl96b2QucnVuKHsgdmFsdWU6IGlucHV0WyR7a31dLCBpc3N1ZXM6IFtdIH0sIGN0eClgO1xuICAgIH07XG4gICAgZG9jLndyaXRlKGBjb25zdCBpbnB1dCA9IHBheWxvYWQudmFsdWU7YCk7XG4gICAgY29uc3QgaWRzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgbGV0IGNvdW50ZXIgPSAwO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIG5vcm1hbGl6ZWQua2V5cykge1xuICAgICAgaWRzW2tleV0gPSBga2V5XyR7Y291bnRlcisrfWA7XG4gICAgfVxuICAgIGRvYy53cml0ZShgY29uc3QgbmV3UmVzdWx0ID0ge31gKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBub3JtYWxpemVkLmtleXMpIHtcbiAgICAgIGlmIChub3JtYWxpemVkLm9wdGlvbmFsS2V5cy5oYXMoa2V5KSkge1xuICAgICAgICBjb25zdCBpZCA9IGlkc1trZXldO1xuICAgICAgICBkb2Mud3JpdGUoYGNvbnN0ICR7aWR9ID0gJHtwYXJzZVN0cihrZXkpfTtgKTtcbiAgICAgICAgY29uc3QgayA9IGVzYyhrZXkpO1xuICAgICAgICBkb2Mud3JpdGUoYFxuICAgICAgICBpZiAoJHtpZH0uaXNzdWVzLmxlbmd0aCkge1xuICAgICAgICAgIGlmIChpbnB1dFske2t9XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoJHtrfSBpbiBpbnB1dCkge1xuICAgICAgICAgICAgICBuZXdSZXN1bHRbJHtrfV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBheWxvYWQuaXNzdWVzID0gcGF5bG9hZC5pc3N1ZXMuY29uY2F0KFxuICAgICAgICAgICAgICAke2lkfS5pc3N1ZXMubWFwKChpc3MpID0+ICh7XG4gICAgICAgICAgICAgICAgLi4uaXNzLFxuICAgICAgICAgICAgICAgIHBhdGg6IGlzcy5wYXRoID8gWyR7a30sIC4uLmlzcy5wYXRoXSA6IFske2t9XSxcbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICgke2lkfS52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKCR7a30gaW4gaW5wdXQpIG5ld1Jlc3VsdFske2t9XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdSZXN1bHRbJHtrfV0gPSAke2lkfS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGlkID0gaWRzW2tleV07XG4gICAgICAgIGRvYy53cml0ZShgY29uc3QgJHtpZH0gPSAke3BhcnNlU3RyKGtleSl9O2ApO1xuICAgICAgICBkb2Mud3JpdGUoYFxuICAgICAgICAgIGlmICgke2lkfS5pc3N1ZXMubGVuZ3RoKSBwYXlsb2FkLmlzc3VlcyA9IHBheWxvYWQuaXNzdWVzLmNvbmNhdCgke2lkfS5pc3N1ZXMubWFwKGlzcyA9PiAoe1xuICAgICAgICAgICAgLi4uaXNzLFxuICAgICAgICAgICAgcGF0aDogaXNzLnBhdGggPyBbJHtlc2Moa2V5KX0sIC4uLmlzcy5wYXRoXSA6IFske2VzYyhrZXkpfV1cbiAgICAgICAgICB9KSkpO2ApO1xuICAgICAgICBkb2Mud3JpdGUoYG5ld1Jlc3VsdFske2VzYyhrZXkpfV0gPSAke2lkfS52YWx1ZWApO1xuICAgICAgfVxuICAgIH1cbiAgICBkb2Mud3JpdGUoYHBheWxvYWQudmFsdWUgPSBuZXdSZXN1bHQ7YCk7XG4gICAgZG9jLndyaXRlKGByZXR1cm4gcGF5bG9hZDtgKTtcbiAgICBjb25zdCBmbiA9IGRvYy5jb21waWxlKCk7XG4gICAgcmV0dXJuIChwYXlsb2FkLCBjdHgpID0+IGZuKHNoYXBlLCBwYXlsb2FkLCBjdHgpO1xuICB9O1xuICBsZXQgZmFzdHBhc3M7XG4gIGNvbnN0IGlzT2JqZWN0MiA9IGlzT2JqZWN0O1xuICBjb25zdCBqaXQgPSAhZ2xvYmFsQ29uZmlnLmppdGxlc3M7XG4gIGNvbnN0IGFsbG93c0V2YWwyID0gYWxsb3dzRXZhbDtcbiAgY29uc3QgZmFzdEVuYWJsZWQgPSBqaXQgJiYgYWxsb3dzRXZhbDIudmFsdWU7XG4gIGNvbnN0IGNhdGNoYWxsID0gZGVmLmNhdGNoYWxsO1xuICBsZXQgdmFsdWU7XG4gIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBjdHgpID0+IHtcbiAgICB2YWx1ZSA/PyAodmFsdWUgPSBfbm9ybWFsaXplZC52YWx1ZSk7XG4gICAgY29uc3QgaW5wdXQgPSBwYXlsb2FkLnZhbHVlO1xuICAgIGlmICghaXNPYmplY3QyKGlucHV0KSkge1xuICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgIGV4cGVjdGVkOiBcIm9iamVjdFwiLFxuICAgICAgICBjb2RlOiBcImludmFsaWRfdHlwZVwiLFxuICAgICAgICBpbnB1dCxcbiAgICAgICAgaW5zdFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICB9XG4gICAgY29uc3QgcHJvbXMgPSBbXTtcbiAgICBpZiAoaml0ICYmIGZhc3RFbmFibGVkICYmIGN0eD8uYXN5bmMgPT09IGZhbHNlICYmIGN0eC5qaXRsZXNzICE9PSB0cnVlKSB7XG4gICAgICBpZiAoIWZhc3RwYXNzKVxuICAgICAgICBmYXN0cGFzcyA9IGdlbmVyYXRlRmFzdHBhc3MoZGVmLnNoYXBlKTtcbiAgICAgIHBheWxvYWQgPSBmYXN0cGFzcyhwYXlsb2FkLCBjdHgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXlsb2FkLnZhbHVlID0ge307XG4gICAgICBjb25zdCBzaGFwZSA9IHZhbHVlLnNoYXBlO1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgdmFsdWUua2V5cykge1xuICAgICAgICBjb25zdCBlbCA9IHNoYXBlW2tleV07XG4gICAgICAgIGNvbnN0IHIgPSBlbC5fem9kLnJ1bih7IHZhbHVlOiBpbnB1dFtrZXldLCBpc3N1ZXM6IFtdIH0sIGN0eCk7XG4gICAgICAgIGNvbnN0IGlzT3B0aW9uYWwgPSBlbC5fem9kLm9wdGluID09PSBcIm9wdGlvbmFsXCIgJiYgZWwuX3pvZC5vcHRvdXQgPT09IFwib3B0aW9uYWxcIjtcbiAgICAgICAgaWYgKHIgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgcHJvbXMucHVzaChyLnRoZW4oKHIyKSA9PiBpc09wdGlvbmFsID8gaGFuZGxlT3B0aW9uYWxPYmplY3RSZXN1bHQocjIsIHBheWxvYWQsIGtleSwgaW5wdXQpIDogaGFuZGxlT2JqZWN0UmVzdWx0KHIyLCBwYXlsb2FkLCBrZXkpKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNPcHRpb25hbCkge1xuICAgICAgICAgIGhhbmRsZU9wdGlvbmFsT2JqZWN0UmVzdWx0KHIsIHBheWxvYWQsIGtleSwgaW5wdXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhhbmRsZU9iamVjdFJlc3VsdChyLCBwYXlsb2FkLCBrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghY2F0Y2hhbGwpIHtcbiAgICAgIHJldHVybiBwcm9tcy5sZW5ndGggPyBQcm9taXNlLmFsbChwcm9tcykudGhlbigoKSA9PiBwYXlsb2FkKSA6IHBheWxvYWQ7XG4gICAgfVxuICAgIGNvbnN0IHVucmVjb2duaXplZCA9IFtdO1xuICAgIGNvbnN0IGtleVNldCA9IHZhbHVlLmtleVNldDtcbiAgICBjb25zdCBfY2F0Y2hhbGwgPSBjYXRjaGFsbC5fem9kO1xuICAgIGNvbnN0IHQgPSBfY2F0Y2hhbGwuZGVmLnR5cGU7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoaW5wdXQpKSB7XG4gICAgICBpZiAoa2V5U2V0LmhhcyhrZXkpKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGlmICh0ID09PSBcIm5ldmVyXCIpIHtcbiAgICAgICAgdW5yZWNvZ25pemVkLnB1c2goa2V5KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCByID0gX2NhdGNoYWxsLnJ1bih7IHZhbHVlOiBpbnB1dFtrZXldLCBpc3N1ZXM6IFtdIH0sIGN0eCk7XG4gICAgICBpZiAociBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgcHJvbXMucHVzaChyLnRoZW4oKHIyKSA9PiBoYW5kbGVPYmplY3RSZXN1bHQocjIsIHBheWxvYWQsIGtleSkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhbmRsZU9iamVjdFJlc3VsdChyLCBwYXlsb2FkLCBrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodW5yZWNvZ25pemVkLmxlbmd0aCkge1xuICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgIGNvZGU6IFwidW5yZWNvZ25pemVkX2tleXNcIixcbiAgICAgICAga2V5czogdW5yZWNvZ25pemVkLFxuICAgICAgICBpbnB1dCxcbiAgICAgICAgaW5zdFxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghcHJvbXMubGVuZ3RoKVxuICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21zKS50aGVuKCgpID0+IHtcbiAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH0pO1xuICB9O1xufSk7XG5mdW5jdGlvbiBoYW5kbGVVbmlvblJlc3VsdHMocmVzdWx0cywgZmluYWwsIGluc3QsIGN0eCkge1xuICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgaWYgKHJlc3VsdC5pc3N1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBmaW5hbC52YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgIHJldHVybiBmaW5hbDtcbiAgICB9XG4gIH1cbiAgZmluYWwuaXNzdWVzLnB1c2goe1xuICAgIGNvZGU6IFwiaW52YWxpZF91bmlvblwiLFxuICAgIGlucHV0OiBmaW5hbC52YWx1ZSxcbiAgICBpbnN0LFxuICAgIGVycm9yczogcmVzdWx0cy5tYXAoKHJlc3VsdCkgPT4gcmVzdWx0Lmlzc3Vlcy5tYXAoKGlzcykgPT4gZmluYWxpemVJc3N1ZShpc3MsIGN0eCwgY29uZmlnKCkpKSlcbiAgfSk7XG4gIHJldHVybiBmaW5hbDtcbn1cbnZhciAkWm9kVW5pb24gPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiJFpvZFVuaW9uXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICBkZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJvcHRpblwiLCAoKSA9PiBkZWYub3B0aW9ucy5zb21lKChvKSA9PiBvLl96b2Qub3B0aW4gPT09IFwib3B0aW9uYWxcIikgPyBcIm9wdGlvbmFsXCIgOiB2b2lkIDApO1xuICBkZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJvcHRvdXRcIiwgKCkgPT4gZGVmLm9wdGlvbnMuc29tZSgobykgPT4gby5fem9kLm9wdG91dCA9PT0gXCJvcHRpb25hbFwiKSA/IFwib3B0aW9uYWxcIiA6IHZvaWQgMCk7XG4gIGRlZmluZUxhenkoaW5zdC5fem9kLCBcInZhbHVlc1wiLCAoKSA9PiB7XG4gICAgaWYgKGRlZi5vcHRpb25zLmV2ZXJ5KChvKSA9PiBvLl96b2QudmFsdWVzKSkge1xuICAgICAgcmV0dXJuIG5ldyBTZXQoZGVmLm9wdGlvbnMuZmxhdE1hcCgob3B0aW9uKSA9PiBBcnJheS5mcm9tKG9wdGlvbi5fem9kLnZhbHVlcykpKTtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfSk7XG4gIGRlZmluZUxhenkoaW5zdC5fem9kLCBcInBhdHRlcm5cIiwgKCkgPT4ge1xuICAgIGlmIChkZWYub3B0aW9ucy5ldmVyeSgobykgPT4gby5fem9kLnBhdHRlcm4pKSB7XG4gICAgICBjb25zdCBwYXR0ZXJucyA9IGRlZi5vcHRpb25zLm1hcCgobykgPT4gby5fem9kLnBhdHRlcm4pO1xuICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoYF4oJHtwYXR0ZXJucy5tYXAoKHApID0+IGNsZWFuUmVnZXgocC5zb3VyY2UpKS5qb2luKFwifFwiKX0pJGApO1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9KTtcbiAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIGN0eCkgPT4ge1xuICAgIGxldCBhc3luYyA9IGZhbHNlO1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBkZWYub3B0aW9ucykge1xuICAgICAgY29uc3QgcmVzdWx0ID0gb3B0aW9uLl96b2QucnVuKHtcbiAgICAgICAgdmFsdWU6IHBheWxvYWQudmFsdWUsXG4gICAgICAgIGlzc3VlczogW11cbiAgICAgIH0sIGN0eCk7XG4gICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgYXN5bmMgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHJlc3VsdC5pc3N1ZXMubGVuZ3RoID09PSAwKVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWFzeW5jKVxuICAgICAgcmV0dXJuIGhhbmRsZVVuaW9uUmVzdWx0cyhyZXN1bHRzLCBwYXlsb2FkLCBpbnN0LCBjdHgpO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChyZXN1bHRzKS50aGVuKChyZXN1bHRzMikgPT4ge1xuICAgICAgcmV0dXJuIGhhbmRsZVVuaW9uUmVzdWx0cyhyZXN1bHRzMiwgcGF5bG9hZCwgaW5zdCwgY3R4KTtcbiAgICB9KTtcbiAgfTtcbn0pO1xudmFyICRab2RJbnRlcnNlY3Rpb24gPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiJFpvZEludGVyc2VjdGlvblwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIGN0eCkgPT4ge1xuICAgIGNvbnN0IGlucHV0ID0gcGF5bG9hZC52YWx1ZTtcbiAgICBjb25zdCBsZWZ0ID0gZGVmLmxlZnQuX3pvZC5ydW4oeyB2YWx1ZTogaW5wdXQsIGlzc3VlczogW10gfSwgY3R4KTtcbiAgICBjb25zdCByaWdodCA9IGRlZi5yaWdodC5fem9kLnJ1bih7IHZhbHVlOiBpbnB1dCwgaXNzdWVzOiBbXSB9LCBjdHgpO1xuICAgIGNvbnN0IGFzeW5jID0gbGVmdCBpbnN0YW5jZW9mIFByb21pc2UgfHwgcmlnaHQgaW5zdGFuY2VvZiBQcm9taXNlO1xuICAgIGlmIChhc3luYykge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtsZWZ0LCByaWdodF0pLnRoZW4oKFtsZWZ0MiwgcmlnaHQyXSkgPT4ge1xuICAgICAgICByZXR1cm4gaGFuZGxlSW50ZXJzZWN0aW9uUmVzdWx0cyhwYXlsb2FkLCBsZWZ0MiwgcmlnaHQyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gaGFuZGxlSW50ZXJzZWN0aW9uUmVzdWx0cyhwYXlsb2FkLCBsZWZ0LCByaWdodCk7XG4gIH07XG59KTtcbmZ1bmN0aW9uIG1lcmdlVmFsdWVzKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSwgZGF0YTogYSB9O1xuICB9XG4gIGlmIChhIGluc3RhbmNlb2YgRGF0ZSAmJiBiIGluc3RhbmNlb2YgRGF0ZSAmJiArYSA9PT0gK2IpIHtcbiAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSwgZGF0YTogYSB9O1xuICB9XG4gIGlmIChpc1BsYWluT2JqZWN0KGEpICYmIGlzUGxhaW5PYmplY3QoYikpIHtcbiAgICBjb25zdCBiS2V5cyA9IE9iamVjdC5rZXlzKGIpO1xuICAgIGNvbnN0IHNoYXJlZEtleXMgPSBPYmplY3Qua2V5cyhhKS5maWx0ZXIoKGtleSkgPT4gYktleXMuaW5kZXhPZihrZXkpICE9PSAtMSk7XG4gICAgY29uc3QgbmV3T2JqID0geyAuLi5hLCAuLi5iIH07XG4gICAgZm9yIChjb25zdCBrZXkgb2Ygc2hhcmVkS2V5cykge1xuICAgICAgY29uc3Qgc2hhcmVkVmFsdWUgPSBtZXJnZVZhbHVlcyhhW2tleV0sIGJba2V5XSk7XG4gICAgICBpZiAoIXNoYXJlZFZhbHVlLnZhbGlkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsaWQ6IGZhbHNlLFxuICAgICAgICAgIG1lcmdlRXJyb3JQYXRoOiBba2V5LCAuLi5zaGFyZWRWYWx1ZS5tZXJnZUVycm9yUGF0aF1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIG5ld09ialtrZXldID0gc2hhcmVkVmFsdWUuZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGRhdGE6IG5ld09iaiB9O1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGEpICYmIEFycmF5LmlzQXJyYXkoYikpIHtcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UsIG1lcmdlRXJyb3JQYXRoOiBbXSB9O1xuICAgIH1cbiAgICBjb25zdCBuZXdBcnJheSA9IFtdO1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBhLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgY29uc3QgaXRlbUEgPSBhW2luZGV4XTtcbiAgICAgIGNvbnN0IGl0ZW1CID0gYltpbmRleF07XG4gICAgICBjb25zdCBzaGFyZWRWYWx1ZSA9IG1lcmdlVmFsdWVzKGl0ZW1BLCBpdGVtQik7XG4gICAgICBpZiAoIXNoYXJlZFZhbHVlLnZhbGlkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsaWQ6IGZhbHNlLFxuICAgICAgICAgIG1lcmdlRXJyb3JQYXRoOiBbaW5kZXgsIC4uLnNoYXJlZFZhbHVlLm1lcmdlRXJyb3JQYXRoXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgbmV3QXJyYXkucHVzaChzaGFyZWRWYWx1ZS5kYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGRhdGE6IG5ld0FycmF5IH07XG4gIH1cbiAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlLCBtZXJnZUVycm9yUGF0aDogW10gfTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUludGVyc2VjdGlvblJlc3VsdHMocmVzdWx0LCBsZWZ0LCByaWdodCkge1xuICBpZiAobGVmdC5pc3N1ZXMubGVuZ3RoKSB7XG4gICAgcmVzdWx0Lmlzc3Vlcy5wdXNoKC4uLmxlZnQuaXNzdWVzKTtcbiAgfVxuICBpZiAocmlnaHQuaXNzdWVzLmxlbmd0aCkge1xuICAgIHJlc3VsdC5pc3N1ZXMucHVzaCguLi5yaWdodC5pc3N1ZXMpO1xuICB9XG4gIGlmIChhYm9ydGVkKHJlc3VsdCkpXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgY29uc3QgbWVyZ2VkID0gbWVyZ2VWYWx1ZXMobGVmdC52YWx1ZSwgcmlnaHQudmFsdWUpO1xuICBpZiAoIW1lcmdlZC52YWxpZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5tZXJnYWJsZSBpbnRlcnNlY3Rpb24uIEVycm9yIHBhdGg6ICR7SlNPTi5zdHJpbmdpZnkobWVyZ2VkLm1lcmdlRXJyb3JQYXRoKX1gKTtcbiAgfVxuICByZXN1bHQudmFsdWUgPSBtZXJnZWQuZGF0YTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbnZhciAkWm9kRW51bSA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCIkWm9kRW51bVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgY29uc3QgdmFsdWVzID0gZ2V0RW51bVZhbHVlcyhkZWYuZW50cmllcyk7XG4gIGluc3QuX3pvZC52YWx1ZXMgPSBuZXcgU2V0KHZhbHVlcyk7XG4gIGluc3QuX3pvZC5wYXR0ZXJuID0gbmV3IFJlZ0V4cChgXigke3ZhbHVlcy5maWx0ZXIoKGspID0+IHByb3BlcnR5S2V5VHlwZXMuaGFzKHR5cGVvZiBrKSkubWFwKChvKSA9PiB0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIiA/IGVzY2FwZVJlZ2V4KG8pIDogby50b1N0cmluZygpKS5qb2luKFwifFwiKX0pJGApO1xuICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgX2N0eCkgPT4ge1xuICAgIGNvbnN0IGlucHV0ID0gcGF5bG9hZC52YWx1ZTtcbiAgICBpZiAoaW5zdC5fem9kLnZhbHVlcy5oYXMoaW5wdXQpKSB7XG4gICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICB9XG4gICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICBjb2RlOiBcImludmFsaWRfdmFsdWVcIixcbiAgICAgIHZhbHVlcyxcbiAgICAgIGlucHV0LFxuICAgICAgaW5zdFxuICAgIH0pO1xuICAgIHJldHVybiBwYXlsb2FkO1xuICB9O1xufSk7XG52YXIgJFpvZFRyYW5zZm9ybSA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCIkWm9kVHJhbnNmb3JtXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgX2N0eCkgPT4ge1xuICAgIGNvbnN0IF9vdXQgPSBkZWYudHJhbnNmb3JtKHBheWxvYWQudmFsdWUsIHBheWxvYWQpO1xuICAgIGlmIChfY3R4LmFzeW5jKSB7XG4gICAgICBjb25zdCBvdXRwdXQgPSBfb3V0IGluc3RhbmNlb2YgUHJvbWlzZSA/IF9vdXQgOiBQcm9taXNlLnJlc29sdmUoX291dCk7XG4gICAgICByZXR1cm4gb3V0cHV0LnRoZW4oKG91dHB1dDIpID0+IHtcbiAgICAgICAgcGF5bG9hZC52YWx1ZSA9IG91dHB1dDI7XG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChfb3V0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgdGhyb3cgbmV3ICRab2RBc3luY0Vycm9yKCk7XG4gICAgfVxuICAgIHBheWxvYWQudmFsdWUgPSBfb3V0O1xuICAgIHJldHVybiBwYXlsb2FkO1xuICB9O1xufSk7XG52YXIgJFpvZE9wdGlvbmFsID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIiRab2RPcHRpb25hbFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgaW5zdC5fem9kLm9wdGluID0gXCJvcHRpb25hbFwiO1xuICBpbnN0Ll96b2Qub3B0b3V0ID0gXCJvcHRpb25hbFwiO1xuICBkZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJ2YWx1ZXNcIiwgKCkgPT4ge1xuICAgIHJldHVybiBkZWYuaW5uZXJUeXBlLl96b2QudmFsdWVzID8gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoWy4uLmRlZi5pbm5lclR5cGUuX3pvZC52YWx1ZXMsIHZvaWQgMF0pIDogdm9pZCAwO1xuICB9KTtcbiAgZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwicGF0dGVyblwiLCAoKSA9PiB7XG4gICAgY29uc3QgcGF0dGVybiA9IGRlZi5pbm5lclR5cGUuX3pvZC5wYXR0ZXJuO1xuICAgIHJldHVybiBwYXR0ZXJuID8gbmV3IFJlZ0V4cChgXigke2NsZWFuUmVnZXgocGF0dGVybi5zb3VyY2UpfSk/JGApIDogdm9pZCAwO1xuICB9KTtcbiAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIGN0eCkgPT4ge1xuICAgIGlmIChkZWYuaW5uZXJUeXBlLl96b2Qub3B0aW4gPT09IFwib3B0aW9uYWxcIikge1xuICAgICAgcmV0dXJuIGRlZi5pbm5lclR5cGUuX3pvZC5ydW4ocGF5bG9hZCwgY3R4KTtcbiAgICB9XG4gICAgaWYgKHBheWxvYWQudmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfVxuICAgIHJldHVybiBkZWYuaW5uZXJUeXBlLl96b2QucnVuKHBheWxvYWQsIGN0eCk7XG4gIH07XG59KTtcbnZhciAkWm9kTnVsbGFibGUgPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiJFpvZE51bGxhYmxlXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICBkZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJvcHRpblwiLCAoKSA9PiBkZWYuaW5uZXJUeXBlLl96b2Qub3B0aW4pO1xuICBkZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJvcHRvdXRcIiwgKCkgPT4gZGVmLmlubmVyVHlwZS5fem9kLm9wdG91dCk7XG4gIGRlZmluZUxhenkoaW5zdC5fem9kLCBcInBhdHRlcm5cIiwgKCkgPT4ge1xuICAgIGNvbnN0IHBhdHRlcm4gPSBkZWYuaW5uZXJUeXBlLl96b2QucGF0dGVybjtcbiAgICByZXR1cm4gcGF0dGVybiA/IG5ldyBSZWdFeHAoYF4oJHtjbGVhblJlZ2V4KHBhdHRlcm4uc291cmNlKX18bnVsbCkkYCkgOiB2b2lkIDA7XG4gIH0pO1xuICBkZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJ2YWx1ZXNcIiwgKCkgPT4ge1xuICAgIHJldHVybiBkZWYuaW5uZXJUeXBlLl96b2QudmFsdWVzID8gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoWy4uLmRlZi5pbm5lclR5cGUuX3pvZC52YWx1ZXMsIG51bGxdKSA6IHZvaWQgMDtcbiAgfSk7XG4gIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBjdHgpID0+IHtcbiAgICBpZiAocGF5bG9hZC52YWx1ZSA9PT0gbnVsbClcbiAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIHJldHVybiBkZWYuaW5uZXJUeXBlLl96b2QucnVuKHBheWxvYWQsIGN0eCk7XG4gIH07XG59KTtcbnZhciAkWm9kRGVmYXVsdCA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCIkWm9kRGVmYXVsdFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgaW5zdC5fem9kLm9wdGluID0gXCJvcHRpb25hbFwiO1xuICBkZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJ2YWx1ZXNcIiwgKCkgPT4gZGVmLmlubmVyVHlwZS5fem9kLnZhbHVlcyk7XG4gIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBjdHgpID0+IHtcbiAgICBpZiAocGF5bG9hZC52YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICBwYXlsb2FkLnZhbHVlID0gZGVmLmRlZmF1bHRWYWx1ZTtcbiAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBkZWYuaW5uZXJUeXBlLl96b2QucnVuKHBheWxvYWQsIGN0eCk7XG4gICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgIHJldHVybiByZXN1bHQudGhlbigocmVzdWx0MikgPT4gaGFuZGxlRGVmYXVsdFJlc3VsdChyZXN1bHQyLCBkZWYpKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhbmRsZURlZmF1bHRSZXN1bHQocmVzdWx0LCBkZWYpO1xuICB9O1xufSk7XG5mdW5jdGlvbiBoYW5kbGVEZWZhdWx0UmVzdWx0KHBheWxvYWQsIGRlZikge1xuICBpZiAocGF5bG9hZC52YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgcGF5bG9hZC52YWx1ZSA9IGRlZi5kZWZhdWx0VmFsdWU7XG4gIH1cbiAgcmV0dXJuIHBheWxvYWQ7XG59XG52YXIgJFpvZFByZWZhdWx0ID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIiRab2RQcmVmYXVsdFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgaW5zdC5fem9kLm9wdGluID0gXCJvcHRpb25hbFwiO1xuICBkZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJ2YWx1ZXNcIiwgKCkgPT4gZGVmLmlubmVyVHlwZS5fem9kLnZhbHVlcyk7XG4gIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBjdHgpID0+IHtcbiAgICBpZiAocGF5bG9hZC52YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICBwYXlsb2FkLnZhbHVlID0gZGVmLmRlZmF1bHRWYWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZi5pbm5lclR5cGUuX3pvZC5ydW4ocGF5bG9hZCwgY3R4KTtcbiAgfTtcbn0pO1xudmFyICRab2ROb25PcHRpb25hbCA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCIkWm9kTm9uT3B0aW9uYWxcIiwgKGluc3QsIGRlZikgPT4ge1xuICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gIGRlZmluZUxhenkoaW5zdC5fem9kLCBcInZhbHVlc1wiLCAoKSA9PiB7XG4gICAgY29uc3QgdiA9IGRlZi5pbm5lclR5cGUuX3pvZC52YWx1ZXM7XG4gICAgcmV0dXJuIHYgPyBuZXcgU2V0KFsuLi52XS5maWx0ZXIoKHgpID0+IHggIT09IHZvaWQgMCkpIDogdm9pZCAwO1xuICB9KTtcbiAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIGN0eCkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IGRlZi5pbm5lclR5cGUuX3pvZC5ydW4ocGF5bG9hZCwgY3R4KTtcbiAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKChyZXN1bHQyKSA9PiBoYW5kbGVOb25PcHRpb25hbFJlc3VsdChyZXN1bHQyLCBpbnN0KSk7XG4gICAgfVxuICAgIHJldHVybiBoYW5kbGVOb25PcHRpb25hbFJlc3VsdChyZXN1bHQsIGluc3QpO1xuICB9O1xufSk7XG5mdW5jdGlvbiBoYW5kbGVOb25PcHRpb25hbFJlc3VsdChwYXlsb2FkLCBpbnN0KSB7XG4gIGlmICghcGF5bG9hZC5pc3N1ZXMubGVuZ3RoICYmIHBheWxvYWQudmFsdWUgPT09IHZvaWQgMCkge1xuICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgY29kZTogXCJpbnZhbGlkX3R5cGVcIixcbiAgICAgIGV4cGVjdGVkOiBcIm5vbm9wdGlvbmFsXCIsXG4gICAgICBpbnB1dDogcGF5bG9hZC52YWx1ZSxcbiAgICAgIGluc3RcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcGF5bG9hZDtcbn1cbnZhciAkWm9kQ2F0Y2ggPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiJFpvZENhdGNoXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICBpbnN0Ll96b2Qub3B0aW4gPSBcIm9wdGlvbmFsXCI7XG4gIGRlZmluZUxhenkoaW5zdC5fem9kLCBcIm9wdG91dFwiLCAoKSA9PiBkZWYuaW5uZXJUeXBlLl96b2Qub3B0b3V0KTtcbiAgZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwidmFsdWVzXCIsICgpID0+IGRlZi5pbm5lclR5cGUuX3pvZC52YWx1ZXMpO1xuICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgY3R4KSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gZGVmLmlubmVyVHlwZS5fem9kLnJ1bihwYXlsb2FkLCBjdHgpO1xuICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICByZXR1cm4gcmVzdWx0LnRoZW4oKHJlc3VsdDIpID0+IHtcbiAgICAgICAgcGF5bG9hZC52YWx1ZSA9IHJlc3VsdDIudmFsdWU7XG4gICAgICAgIGlmIChyZXN1bHQyLmlzc3Vlcy5sZW5ndGgpIHtcbiAgICAgICAgICBwYXlsb2FkLnZhbHVlID0gZGVmLmNhdGNoVmFsdWUoe1xuICAgICAgICAgICAgLi4ucGF5bG9hZCxcbiAgICAgICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgICAgIGlzc3VlczogcmVzdWx0Mi5pc3N1ZXMubWFwKChpc3MpID0+IGZpbmFsaXplSXNzdWUoaXNzLCBjdHgsIGNvbmZpZygpKSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbnB1dDogcGF5bG9hZC52YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHBheWxvYWQuaXNzdWVzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcGF5bG9hZC52YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICBpZiAocmVzdWx0Lmlzc3Vlcy5sZW5ndGgpIHtcbiAgICAgIHBheWxvYWQudmFsdWUgPSBkZWYuY2F0Y2hWYWx1ZSh7XG4gICAgICAgIC4uLnBheWxvYWQsXG4gICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgaXNzdWVzOiByZXN1bHQuaXNzdWVzLm1hcCgoaXNzKSA9PiBmaW5hbGl6ZUlzc3VlKGlzcywgY3R4LCBjb25maWcoKSkpXG4gICAgICAgIH0sXG4gICAgICAgIGlucHV0OiBwYXlsb2FkLnZhbHVlXG4gICAgICB9KTtcbiAgICAgIHBheWxvYWQuaXNzdWVzID0gW107XG4gICAgfVxuICAgIHJldHVybiBwYXlsb2FkO1xuICB9O1xufSk7XG52YXIgJFpvZFBpcGUgPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiJFpvZFBpcGVcIiwgKGluc3QsIGRlZikgPT4ge1xuICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gIGRlZmluZUxhenkoaW5zdC5fem9kLCBcInZhbHVlc1wiLCAoKSA9PiBkZWYuaW4uX3pvZC52YWx1ZXMpO1xuICBkZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJvcHRpblwiLCAoKSA9PiBkZWYuaW4uX3pvZC5vcHRpbik7XG4gIGRlZmluZUxhenkoaW5zdC5fem9kLCBcIm9wdG91dFwiLCAoKSA9PiBkZWYub3V0Ll96b2Qub3B0b3V0KTtcbiAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIGN0eCkgPT4ge1xuICAgIGNvbnN0IGxlZnQgPSBkZWYuaW4uX3pvZC5ydW4ocGF5bG9hZCwgY3R4KTtcbiAgICBpZiAobGVmdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgIHJldHVybiBsZWZ0LnRoZW4oKGxlZnQyKSA9PiBoYW5kbGVQaXBlUmVzdWx0KGxlZnQyLCBkZWYsIGN0eCkpO1xuICAgIH1cbiAgICByZXR1cm4gaGFuZGxlUGlwZVJlc3VsdChsZWZ0LCBkZWYsIGN0eCk7XG4gIH07XG59KTtcbmZ1bmN0aW9uIGhhbmRsZVBpcGVSZXN1bHQobGVmdCwgZGVmLCBjdHgpIHtcbiAgaWYgKGFib3J0ZWQobGVmdCkpIHtcbiAgICByZXR1cm4gbGVmdDtcbiAgfVxuICByZXR1cm4gZGVmLm91dC5fem9kLnJ1bih7IHZhbHVlOiBsZWZ0LnZhbHVlLCBpc3N1ZXM6IGxlZnQuaXNzdWVzIH0sIGN0eCk7XG59XG52YXIgJFpvZFJlYWRvbmx5ID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIiRab2RSZWFkb25seVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwicHJvcFZhbHVlc1wiLCAoKSA9PiBkZWYuaW5uZXJUeXBlLl96b2QucHJvcFZhbHVlcyk7XG4gIGRlZmluZUxhenkoaW5zdC5fem9kLCBcInZhbHVlc1wiLCAoKSA9PiBkZWYuaW5uZXJUeXBlLl96b2QudmFsdWVzKTtcbiAgZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwib3B0aW5cIiwgKCkgPT4gZGVmLmlubmVyVHlwZS5fem9kLm9wdGluKTtcbiAgZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwib3B0b3V0XCIsICgpID0+IGRlZi5pbm5lclR5cGUuX3pvZC5vcHRvdXQpO1xuICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgY3R4KSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gZGVmLmlubmVyVHlwZS5fem9kLnJ1bihwYXlsb2FkLCBjdHgpO1xuICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICByZXR1cm4gcmVzdWx0LnRoZW4oaGFuZGxlUmVhZG9ubHlSZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gaGFuZGxlUmVhZG9ubHlSZXN1bHQocmVzdWx0KTtcbiAgfTtcbn0pO1xuZnVuY3Rpb24gaGFuZGxlUmVhZG9ubHlSZXN1bHQocGF5bG9hZCkge1xuICBwYXlsb2FkLnZhbHVlID0gT2JqZWN0LmZyZWV6ZShwYXlsb2FkLnZhbHVlKTtcbiAgcmV0dXJuIHBheWxvYWQ7XG59XG52YXIgJFpvZEN1c3RvbSA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCIkWm9kQ3VzdG9tXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgJFpvZENoZWNrLmluaXQoaW5zdCwgZGVmKTtcbiAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgXykgPT4ge1xuICAgIHJldHVybiBwYXlsb2FkO1xuICB9O1xuICBpbnN0Ll96b2QuY2hlY2sgPSAocGF5bG9hZCkgPT4ge1xuICAgIGNvbnN0IGlucHV0ID0gcGF5bG9hZC52YWx1ZTtcbiAgICBjb25zdCByID0gZGVmLmZuKGlucHV0KTtcbiAgICBpZiAociBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgIHJldHVybiByLnRoZW4oKHIyKSA9PiBoYW5kbGVSZWZpbmVSZXN1bHQocjIsIHBheWxvYWQsIGlucHV0LCBpbnN0KSk7XG4gICAgfVxuICAgIGhhbmRsZVJlZmluZVJlc3VsdChyLCBwYXlsb2FkLCBpbnB1dCwgaW5zdCk7XG4gICAgcmV0dXJuO1xuICB9O1xufSk7XG5mdW5jdGlvbiBoYW5kbGVSZWZpbmVSZXN1bHQocmVzdWx0LCBwYXlsb2FkLCBpbnB1dCwgaW5zdCkge1xuICBpZiAoIXJlc3VsdCkge1xuICAgIGNvbnN0IF9pc3MgPSB7XG4gICAgICBjb2RlOiBcImN1c3RvbVwiLFxuICAgICAgaW5wdXQsXG4gICAgICBpbnN0LFxuICAgICAgLy8gaW5jb3Jwb3JhdGVzIHBhcmFtcy5lcnJvciBpbnRvIGlzc3VlIHJlcG9ydGluZ1xuICAgICAgcGF0aDogWy4uLmluc3QuX3pvZC5kZWYucGF0aCA/PyBbXV0sXG4gICAgICAvLyBpbmNvcnBvcmF0ZXMgcGFyYW1zLmVycm9yIGludG8gaXNzdWUgcmVwb3J0aW5nXG4gICAgICBjb250aW51ZTogIWluc3QuX3pvZC5kZWYuYWJvcnRcbiAgICAgIC8vIHBhcmFtczogaW5zdC5fem9kLmRlZi5wYXJhbXMsXG4gICAgfTtcbiAgICBpZiAoaW5zdC5fem9kLmRlZi5wYXJhbXMpXG4gICAgICBfaXNzLnBhcmFtcyA9IGluc3QuX3pvZC5kZWYucGFyYW1zO1xuICAgIHBheWxvYWQuaXNzdWVzLnB1c2goaXNzdWUoX2lzcykpO1xuICB9XG59XG5cbi8vIG5vZGVfbW9kdWxlcy8ucG5wbS96b2RANC4wLjEvbm9kZV9tb2R1bGVzL3pvZC92NC9jb3JlL3JlZ2lzdHJpZXMuanNcbnZhciAkb3V0cHV0ID0gU3ltYm9sKFwiWm9kT3V0cHV0XCIpO1xudmFyICRpbnB1dCA9IFN5bWJvbChcIlpvZElucHV0XCIpO1xudmFyICRab2RSZWdpc3RyeSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fbWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLl9pZG1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgYWRkKHNjaGVtYSwgLi4uX21ldGEpIHtcbiAgICBjb25zdCBtZXRhID0gX21ldGFbMF07XG4gICAgdGhpcy5fbWFwLnNldChzY2hlbWEsIG1ldGEpO1xuICAgIGlmIChtZXRhICYmIHR5cGVvZiBtZXRhID09PSBcIm9iamVjdFwiICYmIFwiaWRcIiBpbiBtZXRhKSB7XG4gICAgICBpZiAodGhpcy5faWRtYXAuaGFzKG1ldGEuaWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSUQgJHttZXRhLmlkfSBhbHJlYWR5IGV4aXN0cyBpbiB0aGUgcmVnaXN0cnlgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2lkbWFwLnNldChtZXRhLmlkLCBzY2hlbWEpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjbGVhcigpIHtcbiAgICB0aGlzLl9tYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuX2lkbWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZW1vdmUoc2NoZW1hKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX21hcC5nZXQoc2NoZW1hKTtcbiAgICBpZiAobWV0YSAmJiB0eXBlb2YgbWV0YSA9PT0gXCJvYmplY3RcIiAmJiBcImlkXCIgaW4gbWV0YSkge1xuICAgICAgdGhpcy5faWRtYXAuZGVsZXRlKG1ldGEuaWQpO1xuICAgIH1cbiAgICB0aGlzLl9tYXAuZGVsZXRlKHNjaGVtYSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZ2V0KHNjaGVtYSkge1xuICAgIGNvbnN0IHAgPSBzY2hlbWEuX3pvZC5wYXJlbnQ7XG4gICAgaWYgKHApIHtcbiAgICAgIGNvbnN0IHBtID0geyAuLi50aGlzLmdldChwKSA/PyB7fSB9O1xuICAgICAgZGVsZXRlIHBtLmlkO1xuICAgICAgcmV0dXJuIHsgLi4ucG0sIC4uLnRoaXMuX21hcC5nZXQoc2NoZW1hKSB9O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fbWFwLmdldChzY2hlbWEpO1xuICB9XG4gIGhhcyhzY2hlbWEpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwLmhhcyhzY2hlbWEpO1xuICB9XG59O1xuZnVuY3Rpb24gcmVnaXN0cnkoKSB7XG4gIHJldHVybiBuZXcgJFpvZFJlZ2lzdHJ5KCk7XG59XG52YXIgZ2xvYmFsUmVnaXN0cnkgPSAvKiBAX19QVVJFX18gKi8gcmVnaXN0cnkoKTtcblxuLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3pvZEA0LjAuMS9ub2RlX21vZHVsZXMvem9kL3Y0L2NvcmUvYXBpLmpzXG5mdW5jdGlvbiBfdW5rbm93bihDbGFzczIpIHtcbiAgcmV0dXJuIG5ldyBDbGFzczIoe1xuICAgIHR5cGU6IFwidW5rbm93blwiXG4gIH0pO1xufVxuZnVuY3Rpb24gX25ldmVyKENsYXNzMiwgcGFyYW1zKSB7XG4gIHJldHVybiBuZXcgQ2xhc3MyKHtcbiAgICB0eXBlOiBcIm5ldmVyXCIsXG4gICAgLi4ubm9ybWFsaXplUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59XG5mdW5jdGlvbiBfbWF4TGVuZ3RoKG1heGltdW0sIHBhcmFtcykge1xuICBjb25zdCBjaCA9IG5ldyAkWm9kQ2hlY2tNYXhMZW5ndGgoe1xuICAgIGNoZWNrOiBcIm1heF9sZW5ndGhcIixcbiAgICAuLi5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICBtYXhpbXVtXG4gIH0pO1xuICByZXR1cm4gY2g7XG59XG5mdW5jdGlvbiBfbWluTGVuZ3RoKG1pbmltdW0sIHBhcmFtcykge1xuICByZXR1cm4gbmV3ICRab2RDaGVja01pbkxlbmd0aCh7XG4gICAgY2hlY2s6IFwibWluX2xlbmd0aFwiLFxuICAgIC4uLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIG1pbmltdW1cbiAgfSk7XG59XG5mdW5jdGlvbiBfbGVuZ3RoKGxlbmd0aCwgcGFyYW1zKSB7XG4gIHJldHVybiBuZXcgJFpvZENoZWNrTGVuZ3RoRXF1YWxzKHtcbiAgICBjaGVjazogXCJsZW5ndGhfZXF1YWxzXCIsXG4gICAgLi4ubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgbGVuZ3RoXG4gIH0pO1xufVxuZnVuY3Rpb24gX292ZXJ3cml0ZSh0eCkge1xuICByZXR1cm4gbmV3ICRab2RDaGVja092ZXJ3cml0ZSh7XG4gICAgY2hlY2s6IFwib3ZlcndyaXRlXCIsXG4gICAgdHhcbiAgfSk7XG59XG5mdW5jdGlvbiBfYXJyYXkoQ2xhc3MyLCBlbGVtZW50LCBwYXJhbXMpIHtcbiAgcmV0dXJuIG5ldyBDbGFzczIoe1xuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBlbGVtZW50LFxuICAgIC8vIGdldCBlbGVtZW50KCkge1xuICAgIC8vICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgLy8gfSxcbiAgICAuLi5ub3JtYWxpemVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn1cbmZ1bmN0aW9uIF9yZWZpbmUoQ2xhc3MyLCBmbiwgX3BhcmFtcykge1xuICBjb25zdCBzY2hlbWEgPSBuZXcgQ2xhc3MyKHtcbiAgICB0eXBlOiBcImN1c3RvbVwiLFxuICAgIGNoZWNrOiBcImN1c3RvbVwiLFxuICAgIGZuLFxuICAgIC4uLm5vcm1hbGl6ZVBhcmFtcyhfcGFyYW1zKVxuICB9KTtcbiAgcmV0dXJuIHNjaGVtYTtcbn1cblxuLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3pvZEA0LjAuMS9ub2RlX21vZHVsZXMvem9kL3Y0L2NsYXNzaWMvZXJyb3JzLmpzXG52YXIgaW5pdGlhbGl6ZXIyID0gKGluc3QsIGlzc3VlcykgPT4ge1xuICAkWm9kRXJyb3IuaW5pdChpbnN0LCBpc3N1ZXMpO1xuICBpbnN0Lm5hbWUgPSBcIlpvZEVycm9yXCI7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGluc3QsIHtcbiAgICBmb3JtYXQ6IHtcbiAgICAgIHZhbHVlOiAobWFwcGVyKSA9PiBmb3JtYXRFcnJvcihpbnN0LCBtYXBwZXIpXG4gICAgICAvLyBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB9LFxuICAgIGZsYXR0ZW46IHtcbiAgICAgIHZhbHVlOiAobWFwcGVyKSA9PiBmbGF0dGVuRXJyb3IoaW5zdCwgbWFwcGVyKVxuICAgICAgLy8gZW51bWVyYWJsZTogZmFsc2UsXG4gICAgfSxcbiAgICBhZGRJc3N1ZToge1xuICAgICAgdmFsdWU6IChpc3N1ZTIpID0+IGluc3QuaXNzdWVzLnB1c2goaXNzdWUyKVxuICAgICAgLy8gZW51bWVyYWJsZTogZmFsc2UsXG4gICAgfSxcbiAgICBhZGRJc3N1ZXM6IHtcbiAgICAgIHZhbHVlOiAoaXNzdWVzMikgPT4gaW5zdC5pc3N1ZXMucHVzaCguLi5pc3N1ZXMyKVxuICAgICAgLy8gZW51bWVyYWJsZTogZmFsc2UsXG4gICAgfSxcbiAgICBpc0VtcHR5OiB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiBpbnN0Lmlzc3Vlcy5sZW5ndGggPT09IDA7XG4gICAgICB9XG4gICAgICAvLyBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB9XG4gIH0pO1xufTtcbnZhciBab2RFcnJvciA9ICRjb25zdHJ1Y3RvcihcIlpvZEVycm9yXCIsIGluaXRpYWxpemVyMik7XG52YXIgWm9kUmVhbEVycm9yID0gJGNvbnN0cnVjdG9yKFwiWm9kRXJyb3JcIiwgaW5pdGlhbGl6ZXIyLCB7XG4gIFBhcmVudDogRXJyb3Jcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvLnBucG0vem9kQDQuMC4xL25vZGVfbW9kdWxlcy96b2QvdjQvY2xhc3NpYy9wYXJzZS5qc1xudmFyIHBhcnNlID0gLyogQF9fUFVSRV9fICovIF9wYXJzZShab2RSZWFsRXJyb3IpO1xudmFyIHBhcnNlQXN5bmMgPSAvKiBAX19QVVJFX18gKi8gX3BhcnNlQXN5bmMoWm9kUmVhbEVycm9yKTtcbnZhciBzYWZlUGFyc2UyID0gLyogQF9fUFVSRV9fICovIF9zYWZlUGFyc2UoWm9kUmVhbEVycm9yKTtcbnZhciBzYWZlUGFyc2VBc3luYzIgPSAvKiBAX19QVVJFX18gKi8gX3NhZmVQYXJzZUFzeW5jKFpvZFJlYWxFcnJvcik7XG5cbi8vIG5vZGVfbW9kdWxlcy8ucG5wbS96b2RANC4wLjEvbm9kZV9tb2R1bGVzL3pvZC92NC9jbGFzc2ljL3NjaGVtYXMuanNcbnZhciBab2RUeXBlID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIlpvZFR5cGVcIiwgKGluc3QsIGRlZikgPT4ge1xuICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gIGluc3QuZGVmID0gZGVmO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaW5zdCwgXCJfZGVmXCIsIHsgdmFsdWU6IGRlZiB9KTtcbiAgaW5zdC5jaGVjayA9ICguLi5jaGVja3MpID0+IHtcbiAgICByZXR1cm4gaW5zdC5jbG9uZShcbiAgICAgIHtcbiAgICAgICAgLi4uZGVmLFxuICAgICAgICBjaGVja3M6IFtcbiAgICAgICAgICAuLi5kZWYuY2hlY2tzID8/IFtdLFxuICAgICAgICAgIC4uLmNoZWNrcy5tYXAoKGNoKSA9PiB0eXBlb2YgY2ggPT09IFwiZnVuY3Rpb25cIiA/IHsgX3pvZDogeyBjaGVjazogY2gsIGRlZjogeyBjaGVjazogXCJjdXN0b21cIiB9LCBvbmF0dGFjaDogW10gfSB9IDogY2gpXG4gICAgICAgIF1cbiAgICAgIH1cbiAgICAgIC8vIHsgcGFyZW50OiB0cnVlIH1cbiAgICApO1xuICB9O1xuICBpbnN0LmNsb25lID0gKGRlZjIsIHBhcmFtcykgPT4gY2xvbmUoaW5zdCwgZGVmMiwgcGFyYW1zKTtcbiAgaW5zdC5icmFuZCA9ICgpID0+IGluc3Q7XG4gIGluc3QucmVnaXN0ZXIgPSAocmVnLCBtZXRhKSA9PiB7XG4gICAgcmVnLmFkZChpbnN0LCBtZXRhKTtcbiAgICByZXR1cm4gaW5zdDtcbiAgfTtcbiAgaW5zdC5wYXJzZSA9IChkYXRhLCBwYXJhbXMpID0+IHBhcnNlKGluc3QsIGRhdGEsIHBhcmFtcywgeyBjYWxsZWU6IGluc3QucGFyc2UgfSk7XG4gIGluc3Quc2FmZVBhcnNlID0gKGRhdGEsIHBhcmFtcykgPT4gc2FmZVBhcnNlMihpbnN0LCBkYXRhLCBwYXJhbXMpO1xuICBpbnN0LnBhcnNlQXN5bmMgPSBhc3luYyAoZGF0YSwgcGFyYW1zKSA9PiBwYXJzZUFzeW5jKGluc3QsIGRhdGEsIHBhcmFtcywgeyBjYWxsZWU6IGluc3QucGFyc2VBc3luYyB9KTtcbiAgaW5zdC5zYWZlUGFyc2VBc3luYyA9IGFzeW5jIChkYXRhLCBwYXJhbXMpID0+IHNhZmVQYXJzZUFzeW5jMihpbnN0LCBkYXRhLCBwYXJhbXMpO1xuICBpbnN0LnNwYSA9IGluc3Quc2FmZVBhcnNlQXN5bmM7XG4gIGluc3QucmVmaW5lID0gKGNoZWNrMiwgcGFyYW1zKSA9PiBpbnN0LmNoZWNrKHJlZmluZShjaGVjazIsIHBhcmFtcykpO1xuICBpbnN0LnN1cGVyUmVmaW5lID0gKHJlZmluZW1lbnQpID0+IGluc3QuY2hlY2soc3VwZXJSZWZpbmUocmVmaW5lbWVudCkpO1xuICBpbnN0Lm92ZXJ3cml0ZSA9IChmbikgPT4gaW5zdC5jaGVjayhfb3ZlcndyaXRlKGZuKSk7XG4gIGluc3Qub3B0aW9uYWwgPSAoKSA9PiBvcHRpb25hbChpbnN0KTtcbiAgaW5zdC5udWxsYWJsZSA9ICgpID0+IG51bGxhYmxlKGluc3QpO1xuICBpbnN0Lm51bGxpc2ggPSAoKSA9PiBvcHRpb25hbChudWxsYWJsZShpbnN0KSk7XG4gIGluc3Qubm9ub3B0aW9uYWwgPSAocGFyYW1zKSA9PiBub25vcHRpb25hbChpbnN0LCBwYXJhbXMpO1xuICBpbnN0LmFycmF5ID0gKCkgPT4gYXJyYXkoaW5zdCk7XG4gIGluc3Qub3IgPSAoYXJnKSA9PiB1bmlvbihbaW5zdCwgYXJnXSk7XG4gIGluc3QuYW5kID0gKGFyZykgPT4gaW50ZXJzZWN0aW9uKGluc3QsIGFyZyk7XG4gIGluc3QudHJhbnNmb3JtID0gKHR4KSA9PiBwaXBlKGluc3QsIHRyYW5zZm9ybSh0eCkpO1xuICBpbnN0LmRlZmF1bHQgPSAoZGVmMikgPT4gX2RlZmF1bHQoaW5zdCwgZGVmMik7XG4gIGluc3QucHJlZmF1bHQgPSAoZGVmMikgPT4gcHJlZmF1bHQoaW5zdCwgZGVmMik7XG4gIGluc3QuY2F0Y2ggPSAocGFyYW1zKSA9PiBfY2F0Y2goaW5zdCwgcGFyYW1zKTtcbiAgaW5zdC5waXBlID0gKHRhcmdldCkgPT4gcGlwZShpbnN0LCB0YXJnZXQpO1xuICBpbnN0LnJlYWRvbmx5ID0gKCkgPT4gcmVhZG9ubHkoaW5zdCk7XG4gIGluc3QuZGVzY3JpYmUgPSAoZGVzY3JpcHRpb24pID0+IHtcbiAgICBjb25zdCBjbCA9IGluc3QuY2xvbmUoKTtcbiAgICBnbG9iYWxSZWdpc3RyeS5hZGQoY2wsIHsgZGVzY3JpcHRpb24gfSk7XG4gICAgcmV0dXJuIGNsO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaW5zdCwgXCJkZXNjcmlwdGlvblwiLCB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIGdsb2JhbFJlZ2lzdHJ5LmdldChpbnN0KT8uZGVzY3JpcHRpb247XG4gICAgfSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIGluc3QubWV0YSA9ICguLi5hcmdzKSA9PiB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gZ2xvYmFsUmVnaXN0cnkuZ2V0KGluc3QpO1xuICAgIH1cbiAgICBjb25zdCBjbCA9IGluc3QuY2xvbmUoKTtcbiAgICBnbG9iYWxSZWdpc3RyeS5hZGQoY2wsIGFyZ3NbMF0pO1xuICAgIHJldHVybiBjbDtcbiAgfTtcbiAgaW5zdC5pc09wdGlvbmFsID0gKCkgPT4gaW5zdC5zYWZlUGFyc2Uodm9pZCAwKS5zdWNjZXNzO1xuICBpbnN0LmlzTnVsbGFibGUgPSAoKSA9PiBpbnN0LnNhZmVQYXJzZShudWxsKS5zdWNjZXNzO1xuICByZXR1cm4gaW5zdDtcbn0pO1xudmFyIFpvZFVua25vd24gPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiWm9kVW5rbm93blwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICRab2RVbmtub3duLmluaXQoaW5zdCwgZGVmKTtcbiAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG59KTtcbmZ1bmN0aW9uIHVua25vd24oKSB7XG4gIHJldHVybiBfdW5rbm93bihab2RVbmtub3duKTtcbn1cbnZhciBab2ROZXZlciA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCJab2ROZXZlclwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICRab2ROZXZlci5pbml0KGluc3QsIGRlZik7XG4gIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xufSk7XG5mdW5jdGlvbiBuZXZlcihwYXJhbXMpIHtcbiAgcmV0dXJuIF9uZXZlcihab2ROZXZlciwgcGFyYW1zKTtcbn1cbnZhciBab2RBcnJheSA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCJab2RBcnJheVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICRab2RBcnJheS5pbml0KGluc3QsIGRlZik7XG4gIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICBpbnN0LmVsZW1lbnQgPSBkZWYuZWxlbWVudDtcbiAgaW5zdC5taW4gPSAobWluTGVuZ3RoLCBwYXJhbXMpID0+IGluc3QuY2hlY2soX21pbkxlbmd0aChtaW5MZW5ndGgsIHBhcmFtcykpO1xuICBpbnN0Lm5vbmVtcHR5ID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhfbWluTGVuZ3RoKDEsIHBhcmFtcykpO1xuICBpbnN0Lm1heCA9IChtYXhMZW5ndGgsIHBhcmFtcykgPT4gaW5zdC5jaGVjayhfbWF4TGVuZ3RoKG1heExlbmd0aCwgcGFyYW1zKSk7XG4gIGluc3QubGVuZ3RoID0gKGxlbiwgcGFyYW1zKSA9PiBpbnN0LmNoZWNrKF9sZW5ndGgobGVuLCBwYXJhbXMpKTtcbiAgaW5zdC51bndyYXAgPSAoKSA9PiBpbnN0LmVsZW1lbnQ7XG59KTtcbmZ1bmN0aW9uIGFycmF5KGVsZW1lbnQsIHBhcmFtcykge1xuICByZXR1cm4gX2FycmF5KFpvZEFycmF5LCBlbGVtZW50LCBwYXJhbXMpO1xufVxudmFyIFpvZE9iamVjdCA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCJab2RPYmplY3RcIiwgKGluc3QsIGRlZikgPT4ge1xuICAkWm9kT2JqZWN0LmluaXQoaW5zdCwgZGVmKTtcbiAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gIHV0aWxfZXhwb3J0cy5kZWZpbmVMYXp5KGluc3QsIFwic2hhcGVcIiwgKCkgPT4gZGVmLnNoYXBlKTtcbiAgaW5zdC5rZXlvZiA9ICgpID0+IF9lbnVtKE9iamVjdC5rZXlzKGluc3QuX3pvZC5kZWYuc2hhcGUpKTtcbiAgaW5zdC5jYXRjaGFsbCA9IChjYXRjaGFsbCkgPT4gaW5zdC5jbG9uZSh7IC4uLmluc3QuX3pvZC5kZWYsIGNhdGNoYWxsIH0pO1xuICBpbnN0LnBhc3N0aHJvdWdoID0gKCkgPT4gaW5zdC5jbG9uZSh7IC4uLmluc3QuX3pvZC5kZWYsIGNhdGNoYWxsOiB1bmtub3duKCkgfSk7XG4gIGluc3QubG9vc2UgPSAoKSA9PiBpbnN0LmNsb25lKHsgLi4uaW5zdC5fem9kLmRlZiwgY2F0Y2hhbGw6IHVua25vd24oKSB9KTtcbiAgaW5zdC5zdHJpY3QgPSAoKSA9PiBpbnN0LmNsb25lKHsgLi4uaW5zdC5fem9kLmRlZiwgY2F0Y2hhbGw6IG5ldmVyKCkgfSk7XG4gIGluc3Quc3RyaXAgPSAoKSA9PiBpbnN0LmNsb25lKHsgLi4uaW5zdC5fem9kLmRlZiwgY2F0Y2hhbGw6IHZvaWQgMCB9KTtcbiAgaW5zdC5leHRlbmQgPSAoaW5jb21pbmcpID0+IHtcbiAgICByZXR1cm4gdXRpbF9leHBvcnRzLmV4dGVuZChpbnN0LCBpbmNvbWluZyk7XG4gIH07XG4gIGluc3QubWVyZ2UgPSAob3RoZXIpID0+IHV0aWxfZXhwb3J0cy5tZXJnZShpbnN0LCBvdGhlcik7XG4gIGluc3QucGljayA9IChtYXNrKSA9PiB1dGlsX2V4cG9ydHMucGljayhpbnN0LCBtYXNrKTtcbiAgaW5zdC5vbWl0ID0gKG1hc2spID0+IHV0aWxfZXhwb3J0cy5vbWl0KGluc3QsIG1hc2spO1xuICBpbnN0LnBhcnRpYWwgPSAoLi4uYXJncykgPT4gdXRpbF9leHBvcnRzLnBhcnRpYWwoWm9kT3B0aW9uYWwsIGluc3QsIGFyZ3NbMF0pO1xuICBpbnN0LnJlcXVpcmVkID0gKC4uLmFyZ3MpID0+IHV0aWxfZXhwb3J0cy5yZXF1aXJlZChab2ROb25PcHRpb25hbCwgaW5zdCwgYXJnc1swXSk7XG59KTtcbnZhciBab2RVbmlvbiA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCJab2RVbmlvblwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICRab2RVbmlvbi5pbml0KGluc3QsIGRlZik7XG4gIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICBpbnN0Lm9wdGlvbnMgPSBkZWYub3B0aW9ucztcbn0pO1xuZnVuY3Rpb24gdW5pb24ob3B0aW9ucywgcGFyYW1zKSB7XG4gIHJldHVybiBuZXcgWm9kVW5pb24oe1xuICAgIHR5cGU6IFwidW5pb25cIixcbiAgICBvcHRpb25zLFxuICAgIC4uLnV0aWxfZXhwb3J0cy5ub3JtYWxpemVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn1cbnZhciBab2RJbnRlcnNlY3Rpb24gPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiWm9kSW50ZXJzZWN0aW9uXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgJFpvZEludGVyc2VjdGlvbi5pbml0KGluc3QsIGRlZik7XG4gIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xufSk7XG5mdW5jdGlvbiBpbnRlcnNlY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgcmV0dXJuIG5ldyBab2RJbnRlcnNlY3Rpb24oe1xuICAgIHR5cGU6IFwiaW50ZXJzZWN0aW9uXCIsXG4gICAgbGVmdCxcbiAgICByaWdodFxuICB9KTtcbn1cbnZhciBab2RFbnVtID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIlpvZEVudW1cIiwgKGluc3QsIGRlZikgPT4ge1xuICAkWm9kRW51bS5pbml0KGluc3QsIGRlZik7XG4gIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICBpbnN0LmVudW0gPSBkZWYuZW50cmllcztcbiAgaW5zdC5vcHRpb25zID0gT2JqZWN0LnZhbHVlcyhkZWYuZW50cmllcyk7XG4gIGNvbnN0IGtleXMgPSBuZXcgU2V0KE9iamVjdC5rZXlzKGRlZi5lbnRyaWVzKSk7XG4gIGluc3QuZXh0cmFjdCA9ICh2YWx1ZXMsIHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IG5ld0VudHJpZXMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgaWYgKGtleXMuaGFzKHZhbHVlKSkge1xuICAgICAgICBuZXdFbnRyaWVzW3ZhbHVlXSA9IGRlZi5lbnRyaWVzW3ZhbHVlXTtcbiAgICAgIH0gZWxzZVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEtleSAke3ZhbHVlfSBub3QgZm91bmQgaW4gZW51bWApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFpvZEVudW0oe1xuICAgICAgLi4uZGVmLFxuICAgICAgY2hlY2tzOiBbXSxcbiAgICAgIC4uLnV0aWxfZXhwb3J0cy5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICAgIGVudHJpZXM6IG5ld0VudHJpZXNcbiAgICB9KTtcbiAgfTtcbiAgaW5zdC5leGNsdWRlID0gKHZhbHVlcywgcGFyYW1zKSA9PiB7XG4gICAgY29uc3QgbmV3RW50cmllcyA9IHsgLi4uZGVmLmVudHJpZXMgfTtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgaWYgKGtleXMuaGFzKHZhbHVlKSkge1xuICAgICAgICBkZWxldGUgbmV3RW50cmllc1t2YWx1ZV07XG4gICAgICB9IGVsc2VcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXkgJHt2YWx1ZX0gbm90IGZvdW5kIGluIGVudW1gKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBab2RFbnVtKHtcbiAgICAgIC4uLmRlZixcbiAgICAgIGNoZWNrczogW10sXG4gICAgICAuLi51dGlsX2V4cG9ydHMubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgICBlbnRyaWVzOiBuZXdFbnRyaWVzXG4gICAgfSk7XG4gIH07XG59KTtcbmZ1bmN0aW9uIF9lbnVtKHZhbHVlcywgcGFyYW1zKSB7XG4gIGNvbnN0IGVudHJpZXMgPSBBcnJheS5pc0FycmF5KHZhbHVlcykgPyBPYmplY3QuZnJvbUVudHJpZXModmFsdWVzLm1hcCgodikgPT4gW3YsIHZdKSkgOiB2YWx1ZXM7XG4gIHJldHVybiBuZXcgWm9kRW51bSh7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgZW50cmllcyxcbiAgICAuLi51dGlsX2V4cG9ydHMubm9ybWFsaXplUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59XG52YXIgWm9kVHJhbnNmb3JtID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIlpvZFRyYW5zZm9ybVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICRab2RUcmFuc2Zvcm0uaW5pdChpbnN0LCBkZWYpO1xuICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIF9jdHgpID0+IHtcbiAgICBwYXlsb2FkLmFkZElzc3VlID0gKGlzc3VlMikgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBpc3N1ZTIgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh1dGlsX2V4cG9ydHMuaXNzdWUoaXNzdWUyLCBwYXlsb2FkLnZhbHVlLCBkZWYpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IF9pc3N1ZSA9IGlzc3VlMjtcbiAgICAgICAgaWYgKF9pc3N1ZS5mYXRhbClcbiAgICAgICAgICBfaXNzdWUuY29udGludWUgPSBmYWxzZTtcbiAgICAgICAgX2lzc3VlLmNvZGUgPz8gKF9pc3N1ZS5jb2RlID0gXCJjdXN0b21cIik7XG4gICAgICAgIF9pc3N1ZS5pbnB1dCA/PyAoX2lzc3VlLmlucHV0ID0gcGF5bG9hZC52YWx1ZSk7XG4gICAgICAgIF9pc3N1ZS5pbnN0ID8/IChfaXNzdWUuaW5zdCA9IGluc3QpO1xuICAgICAgICBfaXNzdWUuY29udGludWUgPz8gKF9pc3N1ZS5jb250aW51ZSA9IHRydWUpO1xuICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHV0aWxfZXhwb3J0cy5pc3N1ZShfaXNzdWUpKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG91dHB1dCA9IGRlZi50cmFuc2Zvcm0ocGF5bG9hZC52YWx1ZSwgcGF5bG9hZCk7XG4gICAgaWYgKG91dHB1dCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgIHJldHVybiBvdXRwdXQudGhlbigob3V0cHV0MikgPT4ge1xuICAgICAgICBwYXlsb2FkLnZhbHVlID0gb3V0cHV0MjtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcGF5bG9hZC52YWx1ZSA9IG91dHB1dDtcbiAgICByZXR1cm4gcGF5bG9hZDtcbiAgfTtcbn0pO1xuZnVuY3Rpb24gdHJhbnNmb3JtKGZuKSB7XG4gIHJldHVybiBuZXcgWm9kVHJhbnNmb3JtKHtcbiAgICB0eXBlOiBcInRyYW5zZm9ybVwiLFxuICAgIHRyYW5zZm9ybTogZm5cbiAgfSk7XG59XG52YXIgWm9kT3B0aW9uYWwgPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiWm9kT3B0aW9uYWxcIiwgKGluc3QsIGRlZikgPT4ge1xuICAkWm9kT3B0aW9uYWwuaW5pdChpbnN0LCBkZWYpO1xuICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgaW5zdC51bndyYXAgPSAoKSA9PiBpbnN0Ll96b2QuZGVmLmlubmVyVHlwZTtcbn0pO1xuZnVuY3Rpb24gb3B0aW9uYWwoaW5uZXJUeXBlKSB7XG4gIHJldHVybiBuZXcgWm9kT3B0aW9uYWwoe1xuICAgIHR5cGU6IFwib3B0aW9uYWxcIixcbiAgICBpbm5lclR5cGVcbiAgfSk7XG59XG52YXIgWm9kTnVsbGFibGUgPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiWm9kTnVsbGFibGVcIiwgKGluc3QsIGRlZikgPT4ge1xuICAkWm9kTnVsbGFibGUuaW5pdChpbnN0LCBkZWYpO1xuICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgaW5zdC51bndyYXAgPSAoKSA9PiBpbnN0Ll96b2QuZGVmLmlubmVyVHlwZTtcbn0pO1xuZnVuY3Rpb24gbnVsbGFibGUoaW5uZXJUeXBlKSB7XG4gIHJldHVybiBuZXcgWm9kTnVsbGFibGUoe1xuICAgIHR5cGU6IFwibnVsbGFibGVcIixcbiAgICBpbm5lclR5cGVcbiAgfSk7XG59XG52YXIgWm9kRGVmYXVsdCA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCJab2REZWZhdWx0XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgJFpvZERlZmF1bHQuaW5pdChpbnN0LCBkZWYpO1xuICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgaW5zdC51bndyYXAgPSAoKSA9PiBpbnN0Ll96b2QuZGVmLmlubmVyVHlwZTtcbiAgaW5zdC5yZW1vdmVEZWZhdWx0ID0gaW5zdC51bndyYXA7XG59KTtcbmZ1bmN0aW9uIF9kZWZhdWx0KGlubmVyVHlwZSwgZGVmYXVsdFZhbHVlKSB7XG4gIHJldHVybiBuZXcgWm9kRGVmYXVsdCh7XG4gICAgdHlwZTogXCJkZWZhdWx0XCIsXG4gICAgaW5uZXJUeXBlLFxuICAgIGdldCBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGRlZmF1bHRWYWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gZGVmYXVsdFZhbHVlKCkgOiBkZWZhdWx0VmFsdWU7XG4gICAgfVxuICB9KTtcbn1cbnZhciBab2RQcmVmYXVsdCA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCJab2RQcmVmYXVsdFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICRab2RQcmVmYXVsdC5pbml0KGluc3QsIGRlZik7XG4gIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICBpbnN0LnVud3JhcCA9ICgpID0+IGluc3QuX3pvZC5kZWYuaW5uZXJUeXBlO1xufSk7XG5mdW5jdGlvbiBwcmVmYXVsdChpbm5lclR5cGUsIGRlZmF1bHRWYWx1ZSkge1xuICByZXR1cm4gbmV3IFpvZFByZWZhdWx0KHtcbiAgICB0eXBlOiBcInByZWZhdWx0XCIsXG4gICAgaW5uZXJUeXBlLFxuICAgIGdldCBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGRlZmF1bHRWYWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gZGVmYXVsdFZhbHVlKCkgOiBkZWZhdWx0VmFsdWU7XG4gICAgfVxuICB9KTtcbn1cbnZhciBab2ROb25PcHRpb25hbCA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCJab2ROb25PcHRpb25hbFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICRab2ROb25PcHRpb25hbC5pbml0KGluc3QsIGRlZik7XG4gIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICBpbnN0LnVud3JhcCA9ICgpID0+IGluc3QuX3pvZC5kZWYuaW5uZXJUeXBlO1xufSk7XG5mdW5jdGlvbiBub25vcHRpb25hbChpbm5lclR5cGUsIHBhcmFtcykge1xuICByZXR1cm4gbmV3IFpvZE5vbk9wdGlvbmFsKHtcbiAgICB0eXBlOiBcIm5vbm9wdGlvbmFsXCIsXG4gICAgaW5uZXJUeXBlLFxuICAgIC4uLnV0aWxfZXhwb3J0cy5ub3JtYWxpemVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn1cbnZhciBab2RDYXRjaCA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCJab2RDYXRjaFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICRab2RDYXRjaC5pbml0KGluc3QsIGRlZik7XG4gIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICBpbnN0LnVud3JhcCA9ICgpID0+IGluc3QuX3pvZC5kZWYuaW5uZXJUeXBlO1xuICBpbnN0LnJlbW92ZUNhdGNoID0gaW5zdC51bndyYXA7XG59KTtcbmZ1bmN0aW9uIF9jYXRjaChpbm5lclR5cGUsIGNhdGNoVmFsdWUpIHtcbiAgcmV0dXJuIG5ldyBab2RDYXRjaCh7XG4gICAgdHlwZTogXCJjYXRjaFwiLFxuICAgIGlubmVyVHlwZSxcbiAgICBjYXRjaFZhbHVlOiB0eXBlb2YgY2F0Y2hWYWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gY2F0Y2hWYWx1ZSA6ICgpID0+IGNhdGNoVmFsdWVcbiAgfSk7XG59XG52YXIgWm9kUGlwZSA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCJab2RQaXBlXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgJFpvZFBpcGUuaW5pdChpbnN0LCBkZWYpO1xuICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgaW5zdC5pbiA9IGRlZi5pbjtcbiAgaW5zdC5vdXQgPSBkZWYub3V0O1xufSk7XG5mdW5jdGlvbiBwaXBlKGluXywgb3V0KSB7XG4gIHJldHVybiBuZXcgWm9kUGlwZSh7XG4gICAgdHlwZTogXCJwaXBlXCIsXG4gICAgaW46IGluXyxcbiAgICBvdXRcbiAgICAvLyAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICB9KTtcbn1cbnZhciBab2RSZWFkb25seSA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCJab2RSZWFkb25seVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICRab2RSZWFkb25seS5pbml0KGluc3QsIGRlZik7XG4gIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xufSk7XG5mdW5jdGlvbiByZWFkb25seShpbm5lclR5cGUpIHtcbiAgcmV0dXJuIG5ldyBab2RSZWFkb25seSh7XG4gICAgdHlwZTogXCJyZWFkb25seVwiLFxuICAgIGlubmVyVHlwZVxuICB9KTtcbn1cbnZhciBab2RDdXN0b20gPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiWm9kQ3VzdG9tXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgJFpvZEN1c3RvbS5pbml0KGluc3QsIGRlZik7XG4gIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xufSk7XG5mdW5jdGlvbiBjaGVjayhmbikge1xuICBjb25zdCBjaCA9IG5ldyAkWm9kQ2hlY2soe1xuICAgIGNoZWNrOiBcImN1c3RvbVwiXG4gICAgLy8gLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgfSk7XG4gIGNoLl96b2QuY2hlY2sgPSBmbjtcbiAgcmV0dXJuIGNoO1xufVxuZnVuY3Rpb24gcmVmaW5lKGZuLCBfcGFyYW1zID0ge30pIHtcbiAgcmV0dXJuIF9yZWZpbmUoWm9kQ3VzdG9tLCBmbiwgX3BhcmFtcyk7XG59XG5mdW5jdGlvbiBzdXBlclJlZmluZShmbikge1xuICBjb25zdCBjaCA9IGNoZWNrKChwYXlsb2FkKSA9PiB7XG4gICAgcGF5bG9hZC5hZGRJc3N1ZSA9IChpc3N1ZTIpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgaXNzdWUyID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2godXRpbF9leHBvcnRzLmlzc3VlKGlzc3VlMiwgcGF5bG9hZC52YWx1ZSwgY2guX3pvZC5kZWYpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IF9pc3N1ZSA9IGlzc3VlMjtcbiAgICAgICAgaWYgKF9pc3N1ZS5mYXRhbClcbiAgICAgICAgICBfaXNzdWUuY29udGludWUgPSBmYWxzZTtcbiAgICAgICAgX2lzc3VlLmNvZGUgPz8gKF9pc3N1ZS5jb2RlID0gXCJjdXN0b21cIik7XG4gICAgICAgIF9pc3N1ZS5pbnB1dCA/PyAoX2lzc3VlLmlucHV0ID0gcGF5bG9hZC52YWx1ZSk7XG4gICAgICAgIF9pc3N1ZS5pbnN0ID8/IChfaXNzdWUuaW5zdCA9IGNoKTtcbiAgICAgICAgX2lzc3VlLmNvbnRpbnVlID8/IChfaXNzdWUuY29udGludWUgPSAhY2guX3pvZC5kZWYuYWJvcnQpO1xuICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHV0aWxfZXhwb3J0cy5pc3N1ZShfaXNzdWUpKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBmbihwYXlsb2FkLnZhbHVlLCBwYXlsb2FkKTtcbiAgfSk7XG4gIHJldHVybiBjaDtcbn1cblxuLy8gc3JjL29wZW5hcGkudHNcbnZhciBwYXRocyA9IHt9O1xuZnVuY3Rpb24gZ2V0VHlwZUZyb21ab2RUeXBlKHpvZFR5cGUpIHtcbiAgc3dpdGNoICh6b2RUeXBlLmNvbnN0cnVjdG9yLm5hbWUpIHtcbiAgICBjYXNlIFwiWm9kU3RyaW5nXCI6XG4gICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICBjYXNlIFwiWm9kTnVtYmVyXCI6XG4gICAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgICBjYXNlIFwiWm9kQm9vbGVhblwiOlxuICAgICAgcmV0dXJuIFwiYm9vbGVhblwiO1xuICAgIGNhc2UgXCJab2RPYmplY3RcIjpcbiAgICAgIHJldHVybiBcIm9iamVjdFwiO1xuICAgIGNhc2UgXCJab2RBcnJheVwiOlxuICAgICAgcmV0dXJuIFwiYXJyYXlcIjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFBhcmFtZXRlcnMob3B0aW9ucykge1xuICBjb25zdCBwYXJhbWV0ZXJzID0gW107XG4gIGlmIChvcHRpb25zLm1ldGFkYXRhPy5vcGVuYXBpPy5wYXJhbWV0ZXJzKSB7XG4gICAgcGFyYW1ldGVycy5wdXNoKC4uLm9wdGlvbnMubWV0YWRhdGEub3BlbmFwaS5wYXJhbWV0ZXJzKTtcbiAgICByZXR1cm4gcGFyYW1ldGVycztcbiAgfVxuICBpZiAob3B0aW9ucy5xdWVyeSBpbnN0YW5jZW9mIFpvZE9iamVjdCkge1xuICAgIE9iamVjdC5lbnRyaWVzKG9wdGlvbnMucXVlcnkuc2hhcGUpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgWm9kT2JqZWN0KSB7XG4gICAgICAgIHBhcmFtZXRlcnMucHVzaCh7XG4gICAgICAgICAgbmFtZToga2V5LFxuICAgICAgICAgIGluOiBcInF1ZXJ5XCIsXG4gICAgICAgICAgc2NoZW1hOiB7XG4gICAgICAgICAgICB0eXBlOiBnZXRUeXBlRnJvbVpvZFR5cGUodmFsdWUpLFxuICAgICAgICAgICAgLi4uXCJtaW5MZW5ndGhcIiBpbiB2YWx1ZSAmJiB2YWx1ZS5taW5MZW5ndGggPyB7XG4gICAgICAgICAgICAgIG1pbkxlbmd0aDogdmFsdWUubWluTGVuZ3RoXG4gICAgICAgICAgICB9IDoge30sXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogdmFsdWUuZGVzY3JpcHRpb25cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBwYXJhbWV0ZXJzO1xufVxuZnVuY3Rpb24gZ2V0UmVxdWVzdEJvZHkob3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5tZXRhZGF0YT8ub3BlbmFwaT8ucmVxdWVzdEJvZHkpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5tZXRhZGF0YS5vcGVuYXBpLnJlcXVlc3RCb2R5O1xuICB9XG4gIGlmICghb3B0aW9ucy5ib2R5KSByZXR1cm4gdm9pZCAwO1xuICBpZiAob3B0aW9ucy5ib2R5IGluc3RhbmNlb2YgWm9kT2JqZWN0IHx8IG9wdGlvbnMuYm9keSBpbnN0YW5jZW9mIFpvZE9wdGlvbmFsKSB7XG4gICAgY29uc3Qgc2hhcGUgPSBvcHRpb25zLmJvZHkuc2hhcGU7XG4gICAgaWYgKCFzaGFwZSkgcmV0dXJuIHZvaWQgMDtcbiAgICBjb25zdCBwcm9wZXJ0aWVzID0ge307XG4gICAgY29uc3QgcmVxdWlyZWQyID0gW107XG4gICAgT2JqZWN0LmVudHJpZXMoc2hhcGUpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgWm9kT2JqZWN0KSB7XG4gICAgICAgIHByb3BlcnRpZXNba2V5XSA9IHtcbiAgICAgICAgICB0eXBlOiBnZXRUeXBlRnJvbVpvZFR5cGUodmFsdWUpLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiB2YWx1ZS5kZXNjcmlwdGlvblxuICAgICAgICB9O1xuICAgICAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIFpvZE9wdGlvbmFsKSkge1xuICAgICAgICAgIHJlcXVpcmVkMi5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVxdWlyZWQ6IG9wdGlvbnMuYm9keSBpbnN0YW5jZW9mIFpvZE9wdGlvbmFsID8gZmFsc2UgOiBvcHRpb25zLmJvZHkgPyB0cnVlIDogZmFsc2UsXG4gICAgICBjb250ZW50OiB7XG4gICAgICAgIFwiYXBwbGljYXRpb24vanNvblwiOiB7XG4gICAgICAgICAgc2NoZW1hOiB7XG4gICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgcHJvcGVydGllcyxcbiAgICAgICAgICAgIHJlcXVpcmVkOiByZXF1aXJlZDJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHJldHVybiB2b2lkIDA7XG59XG5mdW5jdGlvbiBnZXRSZXNwb25zZShyZXNwb25zZXMpIHtcbiAgcmV0dXJuIHtcbiAgICBcIjQwMFwiOiB7XG4gICAgICBjb250ZW50OiB7XG4gICAgICAgIFwiYXBwbGljYXRpb24vanNvblwiOiB7XG4gICAgICAgICAgc2NoZW1hOiB7XG4gICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgICBtZXNzYWdlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVxdWlyZWQ6IFtcIm1lc3NhZ2VcIl1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkZXNjcmlwdGlvbjogXCJCYWQgUmVxdWVzdC4gVXN1YWxseSBkdWUgdG8gbWlzc2luZyBwYXJhbWV0ZXJzLCBvciBpbnZhbGlkIHBhcmFtZXRlcnMuXCJcbiAgICB9LFxuICAgIFwiNDAxXCI6IHtcbiAgICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgXCJhcHBsaWNhdGlvbi9qc29uXCI6IHtcbiAgICAgICAgICBzY2hlbWE6IHtcbiAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgIG1lc3NhZ2U6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXF1aXJlZDogW1wibWVzc2FnZVwiXVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRlc2NyaXB0aW9uOiBcIlVuYXV0aG9yaXplZC4gRHVlIHRvIG1pc3Npbmcgb3IgaW52YWxpZCBhdXRoZW50aWNhdGlvbi5cIlxuICAgIH0sXG4gICAgXCI0MDNcIjoge1xuICAgICAgY29udGVudDoge1xuICAgICAgICBcImFwcGxpY2F0aW9uL2pzb25cIjoge1xuICAgICAgICAgIHNjaGVtYToge1xuICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgbWVzc2FnZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRlc2NyaXB0aW9uOiBcIkZvcmJpZGRlbi4gWW91IGRvIG5vdCBoYXZlIHBlcm1pc3Npb24gdG8gYWNjZXNzIHRoaXMgcmVzb3VyY2Ugb3IgdG8gcGVyZm9ybSB0aGlzIGFjdGlvbi5cIlxuICAgIH0sXG4gICAgXCI0MDRcIjoge1xuICAgICAgY29udGVudDoge1xuICAgICAgICBcImFwcGxpY2F0aW9uL2pzb25cIjoge1xuICAgICAgICAgIHNjaGVtYToge1xuICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgbWVzc2FnZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRlc2NyaXB0aW9uOiBcIk5vdCBGb3VuZC4gVGhlIHJlcXVlc3RlZCByZXNvdXJjZSB3YXMgbm90IGZvdW5kLlwiXG4gICAgfSxcbiAgICBcIjQyOVwiOiB7XG4gICAgICBjb250ZW50OiB7XG4gICAgICAgIFwiYXBwbGljYXRpb24vanNvblwiOiB7XG4gICAgICAgICAgc2NoZW1hOiB7XG4gICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgICBtZXNzYWdlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGVzY3JpcHRpb246IFwiVG9vIE1hbnkgUmVxdWVzdHMuIFlvdSBoYXZlIGV4Y2VlZGVkIHRoZSByYXRlIGxpbWl0LiBUcnkgYWdhaW4gbGF0ZXIuXCJcbiAgICB9LFxuICAgIFwiNTAwXCI6IHtcbiAgICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgXCJhcHBsaWNhdGlvbi9qc29uXCI6IHtcbiAgICAgICAgICBzY2hlbWE6IHtcbiAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgIG1lc3NhZ2U6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkZXNjcmlwdGlvbjogXCJJbnRlcm5hbCBTZXJ2ZXIgRXJyb3IuIFRoaXMgaXMgYSBwcm9ibGVtIHdpdGggdGhlIHNlcnZlciB0aGF0IHlvdSBjYW5ub3QgZml4LlwiXG4gICAgfSxcbiAgICAuLi5yZXNwb25zZXNcbiAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRvcihlbmRwb2ludHMsIGNvbmZpZzIpIHtcbiAgY29uc3QgY29tcG9uZW50cyA9IHtcbiAgICBzY2hlbWFzOiB7fVxuICB9O1xuICBPYmplY3QuZW50cmllcyhlbmRwb2ludHMpLmZvckVhY2goKFtfLCB2YWx1ZV0pID0+IHtcbiAgICBjb25zdCBvcHRpb25zID0gdmFsdWUub3B0aW9ucztcbiAgICBpZiAob3B0aW9ucy5tZXRhZGF0YT8uU0VSVkVSX09OTFkpIHJldHVybjtcbiAgICBpZiAob3B0aW9ucy5tZXRob2QgPT09IFwiR0VUXCIpIHtcbiAgICAgIHBhdGhzW3ZhbHVlLnBhdGhdID0ge1xuICAgICAgICBnZXQ6IHtcbiAgICAgICAgICB0YWdzOiBbXCJEZWZhdWx0XCIsIC4uLm9wdGlvbnMubWV0YWRhdGE/Lm9wZW5hcGk/LnRhZ3MgfHwgW11dLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBvcHRpb25zLm1ldGFkYXRhPy5vcGVuYXBpPy5kZXNjcmlwdGlvbixcbiAgICAgICAgICBvcGVyYXRpb25JZDogb3B0aW9ucy5tZXRhZGF0YT8ub3BlbmFwaT8ub3BlcmF0aW9uSWQsXG4gICAgICAgICAgc2VjdXJpdHk6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgYmVhcmVyQXV0aDogW11cbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdLFxuICAgICAgICAgIHBhcmFtZXRlcnM6IGdldFBhcmFtZXRlcnMob3B0aW9ucyksXG4gICAgICAgICAgcmVzcG9uc2VzOiBnZXRSZXNwb25zZShvcHRpb25zLm1ldGFkYXRhPy5vcGVuYXBpPy5yZXNwb25zZXMpXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChvcHRpb25zLm1ldGhvZCA9PT0gXCJQT1NUXCIpIHtcbiAgICAgIGNvbnN0IGJvZHkgPSBnZXRSZXF1ZXN0Qm9keShvcHRpb25zKTtcbiAgICAgIHBhdGhzW3ZhbHVlLnBhdGhdID0ge1xuICAgICAgICBwb3N0OiB7XG4gICAgICAgICAgdGFnczogW1wiRGVmYXVsdFwiLCAuLi5vcHRpb25zLm1ldGFkYXRhPy5vcGVuYXBpPy50YWdzIHx8IFtdXSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogb3B0aW9ucy5tZXRhZGF0YT8ub3BlbmFwaT8uZGVzY3JpcHRpb24sXG4gICAgICAgICAgb3BlcmF0aW9uSWQ6IG9wdGlvbnMubWV0YWRhdGE/Lm9wZW5hcGk/Lm9wZXJhdGlvbklkLFxuICAgICAgICAgIHNlY3VyaXR5OiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGJlYXJlckF1dGg6IFtdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXSxcbiAgICAgICAgICBwYXJhbWV0ZXJzOiBnZXRQYXJhbWV0ZXJzKG9wdGlvbnMpLFxuICAgICAgICAgIC4uLmJvZHkgPyB7IHJlcXVlc3RCb2R5OiBib2R5IH0gOiB7XG4gICAgICAgICAgICByZXF1ZXN0Qm9keToge1xuICAgICAgICAgICAgICAvL3NldCBib2R5IG5vbmVcbiAgICAgICAgICAgICAgY29udGVudDoge1xuICAgICAgICAgICAgICAgIFwiYXBwbGljYXRpb24vanNvblwiOiB7XG4gICAgICAgICAgICAgICAgICBzY2hlbWE6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczoge31cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlc3BvbnNlczogZ2V0UmVzcG9uc2Uob3B0aW9ucy5tZXRhZGF0YT8ub3BlbmFwaT8ucmVzcG9uc2VzKVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IHJlcyA9IHtcbiAgICBvcGVuYXBpOiBcIjMuMS4xXCIsXG4gICAgaW5mbzoge1xuICAgICAgdGl0bGU6IFwiQmV0dGVyIEF1dGhcIixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIkFQSSBSZWZlcmVuY2UgZm9yIHlvdXIgQmV0dGVyIEF1dGggSW5zdGFuY2VcIixcbiAgICAgIHZlcnNpb246IFwiMS4xLjBcIlxuICAgIH0sXG4gICAgY29tcG9uZW50cyxcbiAgICBzZWN1cml0eTogW1xuICAgICAge1xuICAgICAgICBhcGlLZXlDb29raWU6IFtdXG4gICAgICB9XG4gICAgXSxcbiAgICBzZXJ2ZXJzOiBbXG4gICAgICB7XG4gICAgICAgIHVybDogY29uZmlnMj8udXJsXG4gICAgICB9XG4gICAgXSxcbiAgICB0YWdzOiBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwiRGVmYXVsdFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJEZWZhdWx0IGVuZHBvaW50cyB0aGF0IGFyZSBpbmNsdWRlZCB3aXRoIEJldHRlciBBdXRoIGJ5IGRlZmF1bHQuIFRoZXNlIGVuZHBvaW50cyBhcmUgbm90IHBhcnQgb2YgYW55IHBsdWdpbi5cIlxuICAgICAgfVxuICAgIF0sXG4gICAgcGF0aHNcbiAgfTtcbiAgcmV0dXJuIHJlcztcbn1cbnZhciBnZXRIVE1MID0gKGFwaVJlZmVyZW5jZSwgY29uZmlnMikgPT4gYDwhZG9jdHlwZSBodG1sPlxuPGh0bWw+XG4gIDxoZWFkPlxuICAgIDx0aXRsZT5TY2FsYXIgQVBJIFJlZmVyZW5jZTwvdGl0bGU+XG4gICAgPG1ldGEgY2hhcnNldD1cInV0Zi04XCIgLz5cbiAgICA8bWV0YVxuICAgICAgbmFtZT1cInZpZXdwb3J0XCJcbiAgICAgIGNvbnRlbnQ9XCJ3aWR0aD1kZXZpY2Utd2lkdGgsIGluaXRpYWwtc2NhbGU9MVwiIC8+XG4gIDwvaGVhZD5cbiAgPGJvZHk+XG4gICAgPHNjcmlwdFxuICAgICAgaWQ9XCJhcGktcmVmZXJlbmNlXCJcbiAgICAgIHR5cGU9XCJhcHBsaWNhdGlvbi9qc29uXCI+XG4gICAgJHtKU09OLnN0cmluZ2lmeShhcGlSZWZlcmVuY2UpfVxuICAgIDwvc2NyaXB0PlxuXHQgPHNjcmlwdD5cbiAgICAgIHZhciBjb25maWd1cmF0aW9uID0ge1xuXHQgIFx0ZmF2aWNvbjogJHtjb25maWcyPy5sb2dvID8gYGRhdGE6aW1hZ2Uvc3ZnK3htbDt1dGY4LCR7ZW5jb2RlVVJJQ29tcG9uZW50KGNvbmZpZzIubG9nbyl9YCA6IHZvaWQgMH0gLFxuXHQgICBcdHRoZW1lOiAke2NvbmZpZzI/LnRoZW1lIHx8IFwic2F0dXJuXCJ9LFxuICAgICAgICBtZXRhRGF0YToge1xuXHRcdFx0dGl0bGU6ICR7Y29uZmlnMj8udGl0bGUgfHwgXCJPcGVuIEFQSSBSZWZlcmVuY2VcIn0sXG5cdFx0XHRkZXNjcmlwdGlvbjogJHtjb25maWcyPy5kZXNjcmlwdGlvbiB8fCBcIkJldHRlciBDYWxsIE9wZW4gQVBJXCJ9LFxuXHRcdH1cbiAgICAgIH1cbiAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhcGktcmVmZXJlbmNlJykuZGF0YXNldC5jb25maWd1cmF0aW9uID1cbiAgICAgICAgSlNPTi5zdHJpbmdpZnkoY29uZmlndXJhdGlvbilcbiAgICA8L3NjcmlwdD5cblx0ICA8c2NyaXB0IHNyYz1cImh0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vQHNjYWxhci9hcGktcmVmZXJlbmNlXCI+PC9zY3JpcHQ+XG4gIDwvYm9keT5cbjwvaHRtbD5gO1xuXG4vLyBzcmMvcm91dGVyLnRzXG52YXIgY3JlYXRlUm91dGVyID0gKGVuZHBvaW50cywgY29uZmlnMikgPT4ge1xuICBpZiAoIWNvbmZpZzI/Lm9wZW5hcGk/LmRpc2FibGVkKSB7XG4gICAgY29uc3Qgb3BlbmFwaSA9IHtcbiAgICAgIHBhdGg6IFwiL2FwaS9yZWZlcmVuY2VcIixcbiAgICAgIC4uLmNvbmZpZzI/Lm9wZW5hcGlcbiAgICB9O1xuICAgIGVuZHBvaW50c1tcIm9wZW5hcGlcIl0gPSBjcmVhdGVFbmRwb2ludDIoXG4gICAgICBvcGVuYXBpLnBhdGgsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJHRVRcIlxuICAgICAgfSxcbiAgICAgIGFzeW5jIChjKSA9PiB7XG4gICAgICAgIGNvbnN0IHNjaGVtYSA9IGF3YWl0IGdlbmVyYXRvcihlbmRwb2ludHMpO1xuICAgICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKGdldEhUTUwoc2NoZW1hLCBvcGVuYXBpLnNjYWxhciksIHtcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcInRleHQvaHRtbFwiXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGNvbnN0IHJvdXRlciA9IGNyZWF0ZVJvdTNSb3V0ZXIoKTtcbiAgY29uc3QgbWlkZGxld2FyZVJvdXRlciA9IGNyZWF0ZVJvdTNSb3V0ZXIoKTtcbiAgZm9yIChjb25zdCBlbmRwb2ludCBvZiBPYmplY3QudmFsdWVzKGVuZHBvaW50cykpIHtcbiAgICBpZiAoIWVuZHBvaW50Lm9wdGlvbnMpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoZW5kcG9pbnQub3B0aW9ucz8ubWV0YWRhdGE/LlNFUlZFUl9PTkxZKSBjb250aW51ZTtcbiAgICBjb25zdCBtZXRob2RzID0gQXJyYXkuaXNBcnJheShlbmRwb2ludC5vcHRpb25zPy5tZXRob2QpID8gZW5kcG9pbnQub3B0aW9ucy5tZXRob2QgOiBbZW5kcG9pbnQub3B0aW9ucz8ubWV0aG9kXTtcbiAgICBmb3IgKGNvbnN0IG1ldGhvZCBvZiBtZXRob2RzKSB7XG4gICAgICBhZGRSb3V0ZShyb3V0ZXIsIG1ldGhvZCwgZW5kcG9pbnQucGF0aCwgZW5kcG9pbnQpO1xuICAgIH1cbiAgfVxuICBpZiAoY29uZmlnMj8ucm91dGVyTWlkZGxld2FyZT8ubGVuZ3RoKSB7XG4gICAgZm9yIChjb25zdCB7IHBhdGgsIG1pZGRsZXdhcmUgfSBvZiBjb25maWcyLnJvdXRlck1pZGRsZXdhcmUpIHtcbiAgICAgIGFkZFJvdXRlKG1pZGRsZXdhcmVSb3V0ZXIsIFwiKlwiLCBwYXRoLCBtaWRkbGV3YXJlKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgcHJvY2Vzc1JlcXVlc3QgPSBhc3luYyAocmVxdWVzdCkgPT4ge1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuICAgIGNvbnN0IHBhdGggPSBjb25maWcyPy5iYXNlUGF0aCA/IHVybC5wYXRobmFtZS5zcGxpdChjb25maWcyLmJhc2VQYXRoKS5yZWR1Y2UoKGFjYywgY3VyciwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChpbmRleCAhPT0gMCkge1xuICAgICAgICBpZiAoaW5kZXggPiAxKSB7XG4gICAgICAgICAgYWNjLnB1c2goYCR7Y29uZmlnMi5iYXNlUGF0aH0ke2N1cnJ9YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWNjLnB1c2goY3Vycik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgW10pLmpvaW4oXCJcIikgOiB1cmwucGF0aG5hbWU7XG4gICAgaWYgKCFwYXRoPy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwgeyBzdGF0dXM6IDQwNCwgc3RhdHVzVGV4dDogXCJOb3QgRm91bmRcIiB9KTtcbiAgICB9XG4gICAgY29uc3Qgcm91dGUgPSBmaW5kUm91dGUocm91dGVyLCByZXF1ZXN0Lm1ldGhvZCwgcGF0aCk7XG4gICAgaWYgKCFyb3V0ZT8uZGF0YSkge1xuICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7IHN0YXR1czogNDA0LCBzdGF0dXNUZXh0OiBcIk5vdCBGb3VuZFwiIH0pO1xuICAgIH1cbiAgICBjb25zdCBxdWVyeSA9IHt9O1xuICAgIHVybC5zZWFyY2hQYXJhbXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgaWYgKGtleSBpbiBxdWVyeSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShxdWVyeVtrZXldKSkge1xuICAgICAgICAgIHF1ZXJ5W2tleV0ucHVzaCh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcXVlcnlba2V5XSA9IFtxdWVyeVtrZXldLCB2YWx1ZV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXJ5W2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBoYW5kbGVyID0gcm91dGUuZGF0YTtcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgcGF0aCxcbiAgICAgIG1ldGhvZDogcmVxdWVzdC5tZXRob2QsXG4gICAgICBoZWFkZXJzOiByZXF1ZXN0LmhlYWRlcnMsXG4gICAgICBwYXJhbXM6IHJvdXRlLnBhcmFtcyA/IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocm91dGUucGFyYW1zKSkgOiB7fSxcbiAgICAgIHJlcXVlc3QsXG4gICAgICBib2R5OiBoYW5kbGVyLm9wdGlvbnMuZGlzYWJsZUJvZHkgPyB2b2lkIDAgOiBhd2FpdCBnZXRCb2R5KGhhbmRsZXIub3B0aW9ucy5jbG9uZVJlcXVlc3QgPyByZXF1ZXN0LmNsb25lKCkgOiByZXF1ZXN0KSxcbiAgICAgIHF1ZXJ5LFxuICAgICAgX2ZsYWc6IFwicm91dGVyXCIsXG4gICAgICBhc1Jlc3BvbnNlOiB0cnVlLFxuICAgICAgY29udGV4dDogY29uZmlnMj8ucm91dGVyQ29udGV4dFxuICAgIH07XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG1pZGRsZXdhcmVSb3V0ZXMgPSBmaW5kQWxsUm91dGVzKG1pZGRsZXdhcmVSb3V0ZXIsIFwiKlwiLCBwYXRoKTtcbiAgICAgIGlmIChtaWRkbGV3YXJlUm91dGVzPy5sZW5ndGgpIHtcbiAgICAgICAgZm9yIChjb25zdCB7IGRhdGE6IG1pZGRsZXdhcmUsIHBhcmFtcyB9IG9mIG1pZGRsZXdhcmVSb3V0ZXMpIHtcbiAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBtaWRkbGV3YXJlKHtcbiAgICAgICAgICAgIC4uLmNvbnRleHQsXG4gICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgICBhc1Jlc3BvbnNlOiBmYWxzZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChyZXMgaW5zdGFuY2VvZiBSZXNwb25zZSkgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBoYW5kbGVyKGNvbnRleHQpO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBUElFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHRvUmVzcG9uc2UoZXJyb3IpO1xuICAgICAgfVxuICAgICAgY29uc29sZS5lcnJvcihgIyBTRVJWRVJfRVJST1I6IGAsIGVycm9yKTtcbiAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwge1xuICAgICAgICBzdGF0dXM6IDUwMCxcbiAgICAgICAgc3RhdHVzVGV4dDogXCJJbnRlcm5hbCBTZXJ2ZXIgRXJyb3JcIlxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4ge1xuICAgIGhhbmRsZXI6IGFzeW5jIChyZXF1ZXN0KSA9PiB7XG4gICAgICBjb25zdCBvblJlcSA9IGF3YWl0IGNvbmZpZzI/Lm9uUmVxdWVzdD8uKHJlcXVlc3QpO1xuICAgICAgaWYgKG9uUmVxIGluc3RhbmNlb2YgUmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuIG9uUmVxO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVxID0gb25SZXEgaW5zdGFuY2VvZiBSZXF1ZXN0ID8gb25SZXEgOiByZXF1ZXN0O1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgcHJvY2Vzc1JlcXVlc3QocmVxKTtcbiAgICAgIGNvbnN0IG9uUmVzID0gYXdhaXQgY29uZmlnMj8ub25SZXNwb25zZT8uKHJlcyk7XG4gICAgICBpZiAob25SZXMgaW5zdGFuY2VvZiBSZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gb25SZXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0sXG4gICAgZW5kcG9pbnRzXG4gIH07XG59O1xuZXhwb3J0IHtcbiAgQVBJRXJyb3IsXG4gIF9zdGF0dXNDb2RlLFxuICBjcmVhdGVFbmRwb2ludDIgYXMgY3JlYXRlRW5kcG9pbnQsXG4gIGNyZWF0ZUludGVybmFsQ29udGV4dCxcbiAgY3JlYXRlTWlkZGxld2FyZSxcbiAgY3JlYXRlUm91dGVyLFxuICBnZW5lcmF0b3IsXG4gIGdldENvb2tpZUtleSxcbiAgZ2V0SFRNTCxcbiAgcGFyc2VDb29raWVzLFxuICBzZXJpYWxpemVDb29raWUsXG4gIHNlcmlhbGl6ZVNpZ25lZENvb2tpZSxcbiAgdG9SZXNwb25zZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/better-call/dist/index.js\n");

/***/ })

};
;