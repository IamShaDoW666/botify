"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/msgpackr";
exports.ids = ["vendor-chunks/msgpackr"];
exports.modules = {

/***/ "(action-browser)/../../node_modules/msgpackr/iterators.js":
/*!************************************************!*\
  !*** ../../node_modules/msgpackr/iterators.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeIter: () => (/* binding */ decodeIter),\n/* harmony export */   encodeIter: () => (/* binding */ encodeIter),\n/* harmony export */   packIter: () => (/* binding */ packIter),\n/* harmony export */   unpackIter: () => (/* binding */ unpackIter)\n/* harmony export */ });\n/* harmony import */ var _pack_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pack.js */ \"(action-browser)/../../node_modules/msgpackr/pack.js\");\n/* harmony import */ var _unpack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./unpack.js */ \"(action-browser)/../../node_modules/msgpackr/unpack.js\");\n\n\n\n/**\n * Given an Iterable first argument, returns an Iterable where each value is packed as a Buffer\n * If the argument is only Async Iterable, the return value will be an Async Iterable.\n * @param {Iterable|Iterator|AsyncIterable|AsyncIterator} objectIterator - iterable source, like a Readable object stream, an array, Set, or custom object\n * @param {options} [options] - msgpackr pack options\n * @returns {IterableIterator|Promise.<AsyncIterableIterator>}\n */\nfunction packIter (objectIterator, options = {}) {\n  if (!objectIterator || typeof objectIterator !== 'object') {\n    throw new Error('first argument must be an Iterable, Async Iterable, or a Promise for an Async Iterable')\n  } else if (typeof objectIterator[Symbol.iterator] === 'function') {\n    return packIterSync(objectIterator, options)\n  } else if (typeof objectIterator.then === 'function' || typeof objectIterator[Symbol.asyncIterator] === 'function') {\n    return packIterAsync(objectIterator, options)\n  } else {\n    throw new Error('first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a Promise')\n  }\n}\n\nfunction * packIterSync (objectIterator, options) {\n  const packr = new _pack_js__WEBPACK_IMPORTED_MODULE_0__.Packr(options)\n  for (const value of objectIterator) {\n    yield packr.pack(value)\n  }\n}\n\nasync function * packIterAsync (objectIterator, options) {\n  const packr = new _pack_js__WEBPACK_IMPORTED_MODULE_0__.Packr(options)\n  for await (const value of objectIterator) {\n    yield packr.pack(value)\n  }\n}\n\n/**\n * Given an Iterable/Iterator input which yields buffers, returns an IterableIterator which yields sync decoded objects\n * Or, given an Async Iterable/Iterator which yields promises resolving in buffers, returns an AsyncIterableIterator.\n * @param {Iterable|Iterator|AsyncIterable|AsyncIterableIterator} bufferIterator\n * @param {object} [options] - unpackr options\n * @returns {IterableIterator|Promise.<AsyncIterableIterator}\n */\nfunction unpackIter (bufferIterator, options = {}) {\n  if (!bufferIterator || typeof bufferIterator !== 'object') {\n    throw new Error('first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a promise')\n  }\n\n  const unpackr = new _unpack_js__WEBPACK_IMPORTED_MODULE_1__.Unpackr(options)\n  let incomplete\n  const parser = (chunk) => {\n    let yields\n    // if there's incomplete data from previous chunk, concatinate and try again\n    if (incomplete) {\n      chunk = Buffer.concat([incomplete, chunk])\n      incomplete = undefined\n    }\n\n    try {\n      yields = unpackr.unpackMultiple(chunk)\n    } catch (err) {\n      if (err.incomplete) {\n        incomplete = chunk.slice(err.lastPosition)\n        yields = err.values\n      } else {\n        throw err\n      }\n    }\n    return yields\n  }\n\n  if (typeof bufferIterator[Symbol.iterator] === 'function') {\n    return (function * iter () {\n      for (const value of bufferIterator) {\n        yield * parser(value)\n      }\n    })()\n  } else if (typeof bufferIterator[Symbol.asyncIterator] === 'function') {\n    return (async function * iter () {\n      for await (const value of bufferIterator) {\n        yield * parser(value)\n      }\n    })()\n  }\n}\nconst decodeIter = unpackIter\nconst encodeIter = packIter//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvbXNncGFja3IvaXRlcmF0b3JzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFpQztBQUNJOztBQUVyQztBQUNBO0FBQ0E7QUFDQSxXQUFXLCtDQUErQztBQUMxRCxXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ08sK0NBQStDO0FBQ3REO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLDJDQUFLO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLDJDQUFLO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdURBQXVEO0FBQ2xFLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDTyxpREFBaUQ7QUFDeEQ7QUFDQTtBQUNBOztBQUVBLHNCQUFzQiwrQ0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNPO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWxhbi9EZXNrdG9wL0FwcHMvYmV0dGVyLWF1dGgvbm9kZV9tb2R1bGVzL21zZ3BhY2tyL2l0ZXJhdG9ycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQYWNrciB9IGZyb20gJy4vcGFjay5qcydcbmltcG9ydCB7IFVucGFja3IgfSBmcm9tICcuL3VucGFjay5qcydcblxuLyoqXG4gKiBHaXZlbiBhbiBJdGVyYWJsZSBmaXJzdCBhcmd1bWVudCwgcmV0dXJucyBhbiBJdGVyYWJsZSB3aGVyZSBlYWNoIHZhbHVlIGlzIHBhY2tlZCBhcyBhIEJ1ZmZlclxuICogSWYgdGhlIGFyZ3VtZW50IGlzIG9ubHkgQXN5bmMgSXRlcmFibGUsIHRoZSByZXR1cm4gdmFsdWUgd2lsbCBiZSBhbiBBc3luYyBJdGVyYWJsZS5cbiAqIEBwYXJhbSB7SXRlcmFibGV8SXRlcmF0b3J8QXN5bmNJdGVyYWJsZXxBc3luY0l0ZXJhdG9yfSBvYmplY3RJdGVyYXRvciAtIGl0ZXJhYmxlIHNvdXJjZSwgbGlrZSBhIFJlYWRhYmxlIG9iamVjdCBzdHJlYW0sIGFuIGFycmF5LCBTZXQsIG9yIGN1c3RvbSBvYmplY3RcbiAqIEBwYXJhbSB7b3B0aW9uc30gW29wdGlvbnNdIC0gbXNncGFja3IgcGFjayBvcHRpb25zXG4gKiBAcmV0dXJucyB7SXRlcmFibGVJdGVyYXRvcnxQcm9taXNlLjxBc3luY0l0ZXJhYmxlSXRlcmF0b3I+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFja0l0ZXIgKG9iamVjdEl0ZXJhdG9yLCBvcHRpb25zID0ge30pIHtcbiAgaWYgKCFvYmplY3RJdGVyYXRvciB8fCB0eXBlb2Ygb2JqZWN0SXRlcmF0b3IgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGFuIEl0ZXJhYmxlLCBBc3luYyBJdGVyYWJsZSwgb3IgYSBQcm9taXNlIGZvciBhbiBBc3luYyBJdGVyYWJsZScpXG4gIH0gZWxzZSBpZiAodHlwZW9mIG9iamVjdEl0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gcGFja0l0ZXJTeW5jKG9iamVjdEl0ZXJhdG9yLCBvcHRpb25zKVxuICB9IGVsc2UgaWYgKHR5cGVvZiBvYmplY3RJdGVyYXRvci50aGVuID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBvYmplY3RJdGVyYXRvcltTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gcGFja0l0ZXJBc3luYyhvYmplY3RJdGVyYXRvciwgb3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYW4gSXRlcmFibGUsIEFzeW5jIEl0ZXJhYmxlLCBJdGVyYXRvciwgQXN5bmMgSXRlcmF0b3IsIG9yIGEgUHJvbWlzZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gKiBwYWNrSXRlclN5bmMgKG9iamVjdEl0ZXJhdG9yLCBvcHRpb25zKSB7XG4gIGNvbnN0IHBhY2tyID0gbmV3IFBhY2tyKG9wdGlvbnMpXG4gIGZvciAoY29uc3QgdmFsdWUgb2Ygb2JqZWN0SXRlcmF0b3IpIHtcbiAgICB5aWVsZCBwYWNrci5wYWNrKHZhbHVlKVxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uICogcGFja0l0ZXJBc3luYyAob2JqZWN0SXRlcmF0b3IsIG9wdGlvbnMpIHtcbiAgY29uc3QgcGFja3IgPSBuZXcgUGFja3Iob3B0aW9ucylcbiAgZm9yIGF3YWl0IChjb25zdCB2YWx1ZSBvZiBvYmplY3RJdGVyYXRvcikge1xuICAgIHlpZWxkIHBhY2tyLnBhY2sodmFsdWUpXG4gIH1cbn1cblxuLyoqXG4gKiBHaXZlbiBhbiBJdGVyYWJsZS9JdGVyYXRvciBpbnB1dCB3aGljaCB5aWVsZHMgYnVmZmVycywgcmV0dXJucyBhbiBJdGVyYWJsZUl0ZXJhdG9yIHdoaWNoIHlpZWxkcyBzeW5jIGRlY29kZWQgb2JqZWN0c1xuICogT3IsIGdpdmVuIGFuIEFzeW5jIEl0ZXJhYmxlL0l0ZXJhdG9yIHdoaWNoIHlpZWxkcyBwcm9taXNlcyByZXNvbHZpbmcgaW4gYnVmZmVycywgcmV0dXJucyBhbiBBc3luY0l0ZXJhYmxlSXRlcmF0b3IuXG4gKiBAcGFyYW0ge0l0ZXJhYmxlfEl0ZXJhdG9yfEFzeW5jSXRlcmFibGV8QXN5bmNJdGVyYWJsZUl0ZXJhdG9yfSBidWZmZXJJdGVyYXRvclxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIHVucGFja3Igb3B0aW9uc1xuICogQHJldHVybnMge0l0ZXJhYmxlSXRlcmF0b3J8UHJvbWlzZS48QXN5bmNJdGVyYWJsZUl0ZXJhdG9yfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdW5wYWNrSXRlciAoYnVmZmVySXRlcmF0b3IsIG9wdGlvbnMgPSB7fSkge1xuICBpZiAoIWJ1ZmZlckl0ZXJhdG9yIHx8IHR5cGVvZiBidWZmZXJJdGVyYXRvciAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYW4gSXRlcmFibGUsIEFzeW5jIEl0ZXJhYmxlLCBJdGVyYXRvciwgQXN5bmMgSXRlcmF0b3IsIG9yIGEgcHJvbWlzZScpXG4gIH1cblxuICBjb25zdCB1bnBhY2tyID0gbmV3IFVucGFja3Iob3B0aW9ucylcbiAgbGV0IGluY29tcGxldGVcbiAgY29uc3QgcGFyc2VyID0gKGNodW5rKSA9PiB7XG4gICAgbGV0IHlpZWxkc1xuICAgIC8vIGlmIHRoZXJlJ3MgaW5jb21wbGV0ZSBkYXRhIGZyb20gcHJldmlvdXMgY2h1bmssIGNvbmNhdGluYXRlIGFuZCB0cnkgYWdhaW5cbiAgICBpZiAoaW5jb21wbGV0ZSkge1xuICAgICAgY2h1bmsgPSBCdWZmZXIuY29uY2F0KFtpbmNvbXBsZXRlLCBjaHVua10pXG4gICAgICBpbmNvbXBsZXRlID0gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHlpZWxkcyA9IHVucGFja3IudW5wYWNrTXVsdGlwbGUoY2h1bmspXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyLmluY29tcGxldGUpIHtcbiAgICAgICAgaW5jb21wbGV0ZSA9IGNodW5rLnNsaWNlKGVyci5sYXN0UG9zaXRpb24pXG4gICAgICAgIHlpZWxkcyA9IGVyci52YWx1ZXNcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVyclxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geWllbGRzXG4gIH1cblxuICBpZiAodHlwZW9mIGJ1ZmZlckl0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gKGZ1bmN0aW9uICogaXRlciAoKSB7XG4gICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIGJ1ZmZlckl0ZXJhdG9yKSB7XG4gICAgICAgIHlpZWxkICogcGFyc2VyKHZhbHVlKVxuICAgICAgfVxuICAgIH0pKClcbiAgfSBlbHNlIGlmICh0eXBlb2YgYnVmZmVySXRlcmF0b3JbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIChhc3luYyBmdW5jdGlvbiAqIGl0ZXIgKCkge1xuICAgICAgZm9yIGF3YWl0IChjb25zdCB2YWx1ZSBvZiBidWZmZXJJdGVyYXRvcikge1xuICAgICAgICB5aWVsZCAqIHBhcnNlcih2YWx1ZSlcbiAgICAgIH1cbiAgICB9KSgpXG4gIH1cbn1cbmV4cG9ydCBjb25zdCBkZWNvZGVJdGVyID0gdW5wYWNrSXRlclxuZXhwb3J0IGNvbnN0IGVuY29kZUl0ZXIgPSBwYWNrSXRlciJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/../../node_modules/msgpackr/iterators.js\n");

/***/ }),

/***/ "(action-browser)/../../node_modules/msgpackr/node-index.js":
/*!*************************************************!*\
  !*** ../../node_modules/msgpackr/node-index.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ALWAYS: () => (/* reexport safe */ _pack_js__WEBPACK_IMPORTED_MODULE_0__.ALWAYS),\n/* harmony export */   C1: () => (/* reexport safe */ _unpack_js__WEBPACK_IMPORTED_MODULE_1__.C1),\n/* harmony export */   DECIMAL_FIT: () => (/* reexport safe */ _pack_js__WEBPACK_IMPORTED_MODULE_0__.DECIMAL_FIT),\n/* harmony export */   DECIMAL_ROUND: () => (/* reexport safe */ _pack_js__WEBPACK_IMPORTED_MODULE_0__.DECIMAL_ROUND),\n/* harmony export */   Decoder: () => (/* reexport safe */ _unpack_js__WEBPACK_IMPORTED_MODULE_1__.Decoder),\n/* harmony export */   DecoderStream: () => (/* reexport safe */ _stream_js__WEBPACK_IMPORTED_MODULE_3__.UnpackrStream),\n/* harmony export */   Encoder: () => (/* reexport safe */ _pack_js__WEBPACK_IMPORTED_MODULE_0__.Encoder),\n/* harmony export */   EncoderStream: () => (/* reexport safe */ _stream_js__WEBPACK_IMPORTED_MODULE_3__.PackrStream),\n/* harmony export */   FLOAT32_OPTIONS: () => (/* reexport safe */ _unpack_js__WEBPACK_IMPORTED_MODULE_1__.FLOAT32_OPTIONS),\n/* harmony export */   NEVER: () => (/* reexport safe */ _pack_js__WEBPACK_IMPORTED_MODULE_0__.NEVER),\n/* harmony export */   Packr: () => (/* reexport safe */ _pack_js__WEBPACK_IMPORTED_MODULE_0__.Packr),\n/* harmony export */   PackrStream: () => (/* reexport safe */ _stream_js__WEBPACK_IMPORTED_MODULE_3__.PackrStream),\n/* harmony export */   Unpackr: () => (/* reexport safe */ _unpack_js__WEBPACK_IMPORTED_MODULE_1__.Unpackr),\n/* harmony export */   UnpackrStream: () => (/* reexport safe */ _stream_js__WEBPACK_IMPORTED_MODULE_3__.UnpackrStream),\n/* harmony export */   addExtension: () => (/* reexport safe */ _pack_js__WEBPACK_IMPORTED_MODULE_0__.addExtension),\n/* harmony export */   clearSource: () => (/* reexport safe */ _unpack_js__WEBPACK_IMPORTED_MODULE_1__.clearSource),\n/* harmony export */   decode: () => (/* reexport safe */ _unpack_js__WEBPACK_IMPORTED_MODULE_1__.decode),\n/* harmony export */   decodeIter: () => (/* reexport safe */ _iterators_js__WEBPACK_IMPORTED_MODULE_4__.decodeIter),\n/* harmony export */   encode: () => (/* reexport safe */ _pack_js__WEBPACK_IMPORTED_MODULE_0__.encode),\n/* harmony export */   encodeIter: () => (/* reexport safe */ _iterators_js__WEBPACK_IMPORTED_MODULE_4__.encodeIter),\n/* harmony export */   isNativeAccelerationEnabled: () => (/* reexport safe */ _unpack_js__WEBPACK_IMPORTED_MODULE_1__.isNativeAccelerationEnabled),\n/* harmony export */   mapsAsObjects: () => (/* binding */ mapsAsObjects),\n/* harmony export */   pack: () => (/* reexport safe */ _pack_js__WEBPACK_IMPORTED_MODULE_0__.pack),\n/* harmony export */   roundFloat32: () => (/* reexport safe */ _unpack_js__WEBPACK_IMPORTED_MODULE_1__.roundFloat32),\n/* harmony export */   unpack: () => (/* reexport safe */ _unpack_js__WEBPACK_IMPORTED_MODULE_1__.unpack),\n/* harmony export */   unpackMultiple: () => (/* reexport safe */ _unpack_js__WEBPACK_IMPORTED_MODULE_1__.unpackMultiple),\n/* harmony export */   useRecords: () => (/* binding */ useRecords)\n/* harmony export */ });\n/* harmony import */ var _pack_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pack.js */ \"(action-browser)/../../node_modules/msgpackr/pack.js\");\n/* harmony import */ var _unpack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./unpack.js */ \"(action-browser)/../../node_modules/msgpackr/unpack.js\");\n/* harmony import */ var _struct_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./struct.js */ \"(action-browser)/../../node_modules/msgpackr/struct.js\");\n/* harmony import */ var _stream_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stream.js */ \"(action-browser)/../../node_modules/msgpackr/stream.js\");\n/* harmony import */ var _iterators_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./iterators.js */ \"(action-browser)/../../node_modules/msgpackr/iterators.js\");\n/* harmony import */ var module__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! module */ \"module\");\n\n\n;\n\n\nconst useRecords = false\nconst mapsAsObjects = true\n;\n\n\nconst nativeAccelerationDisabled = process.env.MSGPACKR_NATIVE_ACCELERATION_DISABLED !== undefined && process.env.MSGPACKR_NATIVE_ACCELERATION_DISABLED.toLowerCase() === 'true';\n\nif (!nativeAccelerationDisabled) {\n\tlet extractor\n\ttry {\n\t\tif (typeof require == 'function')\n\t\t\textractor = require('msgpackr-extract')\n\t\telse\n\t\t\textractor = (0,module__WEBPACK_IMPORTED_MODULE_5__.createRequire)(\"file:///Users/milan/Desktop/Apps/better-auth/node_modules/msgpackr/node-index.js\")('msgpackr-extract')\n\t\tif (extractor)\n\t\t\t(0,_unpack_js__WEBPACK_IMPORTED_MODULE_1__.setExtractor)(extractor.extractStrings)\n\t} catch (error) {\n\t\t// native module is optional\n\t}\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvbXNncGFja3Ivbm9kZS1pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBaUg7QUFDMEM7QUFDM0osQ0FBb0I7QUFDa0c7QUFDL0Q7QUFDaEQ7QUFDQTtBQUNQLENBQTBDO0FBQ0o7O0FBRXRDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscURBQWEsQ0FBQyxrRkFBZTtBQUM1QztBQUNBLEdBQUcsd0RBQVk7QUFDZixHQUFHO0FBQ0g7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvbWlsYW4vRGVza3RvcC9BcHBzL2JldHRlci1hdXRoL25vZGVfbW9kdWxlcy9tc2dwYWNrci9ub2RlLWluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IFBhY2tyLCBFbmNvZGVyLCBhZGRFeHRlbnNpb24sIHBhY2ssIGVuY29kZSwgTkVWRVIsIEFMV0FZUywgREVDSU1BTF9ST1VORCwgREVDSU1BTF9GSVQgfSBmcm9tICcuL3BhY2suanMnXG5leHBvcnQgeyBVbnBhY2tyLCBEZWNvZGVyLCBDMSwgdW5wYWNrLCB1bnBhY2tNdWx0aXBsZSwgZGVjb2RlLCBGTE9BVDMyX09QVElPTlMsIGNsZWFyU291cmNlLCByb3VuZEZsb2F0MzIsIGlzTmF0aXZlQWNjZWxlcmF0aW9uRW5hYmxlZCB9IGZyb20gJy4vdW5wYWNrLmpzJ1xuaW1wb3J0ICcuL3N0cnVjdC5qcydcbmV4cG9ydCB7IFBhY2tyU3RyZWFtLCBVbnBhY2tyU3RyZWFtLCBQYWNrclN0cmVhbSBhcyBFbmNvZGVyU3RyZWFtLCBVbnBhY2tyU3RyZWFtIGFzIERlY29kZXJTdHJlYW0gfSBmcm9tICcuL3N0cmVhbS5qcydcbmV4cG9ydCB7IGRlY29kZUl0ZXIsIGVuY29kZUl0ZXIgfSBmcm9tICcuL2l0ZXJhdG9ycy5qcydcbmV4cG9ydCBjb25zdCB1c2VSZWNvcmRzID0gZmFsc2VcbmV4cG9ydCBjb25zdCBtYXBzQXNPYmplY3RzID0gdHJ1ZVxuaW1wb3J0IHsgc2V0RXh0cmFjdG9yIH0gZnJvbSAnLi91bnBhY2suanMnXG5pbXBvcnQgeyBjcmVhdGVSZXF1aXJlIH0gZnJvbSAnbW9kdWxlJ1xuXG5jb25zdCBuYXRpdmVBY2NlbGVyYXRpb25EaXNhYmxlZCA9IHByb2Nlc3MuZW52Lk1TR1BBQ0tSX05BVElWRV9BQ0NFTEVSQVRJT05fRElTQUJMRUQgIT09IHVuZGVmaW5lZCAmJiBwcm9jZXNzLmVudi5NU0dQQUNLUl9OQVRJVkVfQUNDRUxFUkFUSU9OX0RJU0FCTEVELnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcblxuaWYgKCFuYXRpdmVBY2NlbGVyYXRpb25EaXNhYmxlZCkge1xuXHRsZXQgZXh0cmFjdG9yXG5cdHRyeSB7XG5cdFx0aWYgKHR5cGVvZiByZXF1aXJlID09ICdmdW5jdGlvbicpXG5cdFx0XHRleHRyYWN0b3IgPSByZXF1aXJlKCdtc2dwYWNrci1leHRyYWN0Jylcblx0XHRlbHNlXG5cdFx0XHRleHRyYWN0b3IgPSBjcmVhdGVSZXF1aXJlKGltcG9ydC5tZXRhLnVybCkoJ21zZ3BhY2tyLWV4dHJhY3QnKVxuXHRcdGlmIChleHRyYWN0b3IpXG5cdFx0XHRzZXRFeHRyYWN0b3IoZXh0cmFjdG9yLmV4dHJhY3RTdHJpbmdzKVxuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIG5hdGl2ZSBtb2R1bGUgaXMgb3B0aW9uYWxcblx0fVxufSJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/../../node_modules/msgpackr/node-index.js\n");

/***/ }),

/***/ "(action-browser)/../../node_modules/msgpackr/pack.js":
/*!*******************************************!*\
  !*** ../../node_modules/msgpackr/pack.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ALWAYS: () => (/* binding */ ALWAYS),\n/* harmony export */   DECIMAL_FIT: () => (/* binding */ DECIMAL_FIT),\n/* harmony export */   DECIMAL_ROUND: () => (/* binding */ DECIMAL_ROUND),\n/* harmony export */   Encoder: () => (/* binding */ Encoder),\n/* harmony export */   FLOAT32_OPTIONS: () => (/* reexport safe */ _unpack_js__WEBPACK_IMPORTED_MODULE_0__.FLOAT32_OPTIONS),\n/* harmony export */   NEVER: () => (/* binding */ NEVER),\n/* harmony export */   Packr: () => (/* binding */ Packr),\n/* harmony export */   RECORD_SYMBOL: () => (/* binding */ RECORD_SYMBOL),\n/* harmony export */   RESERVE_START_SPACE: () => (/* binding */ RESERVE_START_SPACE),\n/* harmony export */   RESET_BUFFER_MODE: () => (/* binding */ RESET_BUFFER_MODE),\n/* harmony export */   REUSE_BUFFER_MODE: () => (/* binding */ REUSE_BUFFER_MODE),\n/* harmony export */   addExtension: () => (/* binding */ addExtension),\n/* harmony export */   encode: () => (/* binding */ encode),\n/* harmony export */   pack: () => (/* binding */ pack),\n/* harmony export */   setWriteStructSlots: () => (/* binding */ setWriteStructSlots)\n/* harmony export */ });\n/* harmony import */ var _unpack_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./unpack.js */ \"(action-browser)/../../node_modules/msgpackr/unpack.js\");\n\nlet textEncoder\ntry {\n\ttextEncoder = new TextEncoder()\n} catch (error) {}\nlet extensions, extensionClasses\nconst hasNodeBuffer = typeof Buffer !== 'undefined'\nconst ByteArrayAllocate = hasNodeBuffer ?\n\tfunction(length) { return Buffer.allocUnsafeSlow(length) } : Uint8Array\nconst ByteArray = hasNodeBuffer ? Buffer : Uint8Array\nconst MAX_BUFFER_SIZE = hasNodeBuffer ? 0x100000000 : 0x7fd00000\nlet target, keysTarget\nlet targetView\nlet position = 0\nlet safeEnd\nlet bundledStrings = null\nlet writeStructSlots\nconst MAX_BUNDLE_SIZE = 0x5500 // maximum characters such that the encoded bytes fits in 16 bits.\nconst hasNonLatin = /[\\u0080-\\uFFFF]/\nconst RECORD_SYMBOL = Symbol('record-id')\nclass Packr extends _unpack_js__WEBPACK_IMPORTED_MODULE_0__.Unpackr {\n\tconstructor(options) {\n\t\tsuper(options)\n\t\tthis.offset = 0\n\t\tlet typeBuffer\n\t\tlet start\n\t\tlet hasSharedUpdate\n\t\tlet structures\n\t\tlet referenceMap\n\t\tlet encodeUtf8 = ByteArray.prototype.utf8Write ? function(string, position) {\n\t\t\treturn target.utf8Write(string, position, target.byteLength - position)\n\t\t} : (textEncoder && textEncoder.encodeInto) ?\n\t\t\tfunction(string, position) {\n\t\t\t\treturn textEncoder.encodeInto(string, target.subarray(position)).written\n\t\t\t} : false\n\n\t\tlet packr = this\n\t\tif (!options)\n\t\t\toptions = {}\n\t\tlet isSequential = options && options.sequential\n\t\tlet hasSharedStructures = options.structures || options.saveStructures\n\t\tlet maxSharedStructures = options.maxSharedStructures\n\t\tif (maxSharedStructures == null)\n\t\t\tmaxSharedStructures = hasSharedStructures ? 32 : 0\n\t\tif (maxSharedStructures > 8160)\n\t\t\tthrow new Error('Maximum maxSharedStructure is 8160')\n\t\tif (options.structuredClone && options.moreTypes == undefined) {\n\t\t\tthis.moreTypes = true\n\t\t}\n\t\tlet maxOwnStructures = options.maxOwnStructures\n\t\tif (maxOwnStructures == null)\n\t\t\tmaxOwnStructures = hasSharedStructures ? 32 : 64\n\t\tif (!this.structures && options.useRecords != false)\n\t\t\tthis.structures = []\n\t\t// two byte record ids for shared structures\n\t\tlet useTwoByteRecords = maxSharedStructures > 32 || (maxOwnStructures + maxSharedStructures > 64)\n\t\tlet sharedLimitId = maxSharedStructures + 0x40\n\t\tlet maxStructureId = maxSharedStructures + maxOwnStructures + 0x40\n\t\tif (maxStructureId > 8256) {\n\t\t\tthrow new Error('Maximum maxSharedStructure + maxOwnStructure is 8192')\n\t\t}\n\t\tlet recordIdsToRemove = []\n\t\tlet transitionsCount = 0\n\t\tlet serializationsSinceTransitionRebuild = 0\n\n\t\tthis.pack = this.encode = function(value, encodeOptions) {\n\t\t\tif (!target) {\n\t\t\t\ttarget = new ByteArrayAllocate(8192)\n\t\t\t\ttargetView = target.dataView || (target.dataView = new DataView(target.buffer, 0, 8192))\n\t\t\t\tposition = 0\n\t\t\t}\n\t\t\tsafeEnd = target.length - 10\n\t\t\tif (safeEnd - position < 0x800) {\n\t\t\t\t// don't start too close to the end,\n\t\t\t\ttarget = new ByteArrayAllocate(target.length)\n\t\t\t\ttargetView = target.dataView || (target.dataView = new DataView(target.buffer, 0, target.length))\n\t\t\t\tsafeEnd = target.length - 10\n\t\t\t\tposition = 0\n\t\t\t} else\n\t\t\t\tposition = (position + 7) & 0x7ffffff8 // Word align to make any future copying of this buffer faster\n\t\t\tstart = position\n\t\t\tif (encodeOptions & RESERVE_START_SPACE) position += (encodeOptions & 0xff)\n\t\t\treferenceMap = packr.structuredClone ? new Map() : null\n\t\t\tif (packr.bundleStrings && typeof value !== 'string') {\n\t\t\t\tbundledStrings = []\n\t\t\t\tbundledStrings.size = Infinity // force a new bundle start on first string\n\t\t\t} else\n\t\t\t\tbundledStrings = null\n\t\t\tstructures = packr.structures\n\t\t\tif (structures) {\n\t\t\t\tif (structures.uninitialized)\n\t\t\t\t\tstructures = packr._mergeStructures(packr.getStructures())\n\t\t\t\tlet sharedLength = structures.sharedLength || 0\n\t\t\t\tif (sharedLength > maxSharedStructures) {\n\t\t\t\t\t//if (maxSharedStructures <= 32 && structures.sharedLength > 32) // TODO: could support this, but would need to update the limit ids\n\t\t\t\t\tthrow new Error('Shared structures is larger than maximum shared structures, try increasing maxSharedStructures to ' + structures.sharedLength)\n\t\t\t\t}\n\t\t\t\tif (!structures.transitions) {\n\t\t\t\t\t// rebuild our structure transitions\n\t\t\t\t\tstructures.transitions = Object.create(null)\n\t\t\t\t\tfor (let i = 0; i < sharedLength; i++) {\n\t\t\t\t\t\tlet keys = structures[i]\n\t\t\t\t\t\tif (!keys)\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\tlet nextTransition, transition = structures.transitions\n\t\t\t\t\t\tfor (let j = 0, l = keys.length; j < l; j++) {\n\t\t\t\t\t\t\tlet key = keys[j]\n\t\t\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttransition[RECORD_SYMBOL] = i + 0x40\n\t\t\t\t\t}\n\t\t\t\t\tthis.lastNamedStructuresLength = sharedLength\n\t\t\t\t}\n\t\t\t\tif (!isSequential) {\n\t\t\t\t\tstructures.nextId = sharedLength + 0x40\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hasSharedUpdate)\n\t\t\t\thasSharedUpdate = false\n\t\t\tlet encodingError;\n\t\t\ttry {\n\t\t\t\tif (packr.randomAccessStructure && value && value.constructor && value.constructor === Object)\n\t\t\t\t\twriteStruct(value);\n\t\t\t\telse\n\t\t\t\t\tpack(value)\n\t\t\t\tlet lastBundle = bundledStrings;\n\t\t\t\tif (bundledStrings)\n\t\t\t\t\twriteBundles(start, pack, 0)\n\t\t\t\tif (referenceMap && referenceMap.idsToInsert) {\n\t\t\t\t\tlet idsToInsert = referenceMap.idsToInsert.sort((a, b) => a.offset > b.offset ? 1 : -1);\n\t\t\t\t\tlet i = idsToInsert.length;\n\t\t\t\t\tlet incrementPosition = -1;\n\t\t\t\t\twhile (lastBundle && i > 0) {\n\t\t\t\t\t\tlet insertionPoint = idsToInsert[--i].offset + start;\n\t\t\t\t\t\tif (insertionPoint < (lastBundle.stringsPosition + start) && incrementPosition === -1)\n\t\t\t\t\t\t\tincrementPosition = 0;\n\t\t\t\t\t\tif (insertionPoint > (lastBundle.position + start)) {\n\t\t\t\t\t\t\tif (incrementPosition >= 0)\n\t\t\t\t\t\t\t\tincrementPosition += 6;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (incrementPosition >= 0) {\n\t\t\t\t\t\t\t\t// update the bundle reference now\n\t\t\t\t\t\t\t\ttargetView.setUint32(lastBundle.position + start,\n\t\t\t\t\t\t\t\t\ttargetView.getUint32(lastBundle.position + start) + incrementPosition)\n\t\t\t\t\t\t\t\tincrementPosition = -1; // reset\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlastBundle = lastBundle.previous;\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (incrementPosition >= 0 && lastBundle) {\n\t\t\t\t\t\t// update the bundle reference now\n\t\t\t\t\t\ttargetView.setUint32(lastBundle.position + start,\n\t\t\t\t\t\t\ttargetView.getUint32(lastBundle.position + start) + incrementPosition)\n\t\t\t\t\t}\n\t\t\t\t\tposition += idsToInsert.length * 6;\n\t\t\t\t\tif (position > safeEnd)\n\t\t\t\t\t\tmakeRoom(position)\n\t\t\t\t\tpackr.offset = position\n\t\t\t\t\tlet serialized = insertIds(target.subarray(start, position), idsToInsert)\n\t\t\t\t\treferenceMap = null\n\t\t\t\t\treturn serialized\n\t\t\t\t}\n\t\t\t\tpackr.offset = position // update the offset so next serialization doesn't write over our buffer, but can continue writing to same buffer sequentially\n\t\t\t\tif (encodeOptions & REUSE_BUFFER_MODE) {\n\t\t\t\t\ttarget.start = start\n\t\t\t\t\ttarget.end = position\n\t\t\t\t\treturn target\n\t\t\t\t}\n\t\t\t\treturn target.subarray(start, position) // position can change if we call pack again in saveStructures, so we get the buffer now\n\t\t\t} catch(error) {\n\t\t\t\tencodingError = error;\n\t\t\t\tthrow error;\n\t\t\t} finally {\n\t\t\t\tif (structures) {\n\t\t\t\t\tresetStructures();\n\t\t\t\t\tif (hasSharedUpdate && packr.saveStructures) {\n\t\t\t\t\t\tlet sharedLength = structures.sharedLength || 0\n\t\t\t\t\t\t// we can't rely on start/end with REUSE_BUFFER_MODE since they will (probably) change when we save\n\t\t\t\t\t\tlet returnBuffer = target.subarray(start, position)\n\t\t\t\t\t\tlet newSharedData = prepareStructures(structures, packr);\n\t\t\t\t\t\tif (!encodingError) { // TODO: If there is an encoding error, should make the structures as uninitialized so they get rebuilt next time\n\t\t\t\t\t\t\tif (packr.saveStructures(newSharedData, newSharedData.isCompatible) === false) {\n\t\t\t\t\t\t\t\t// get updated structures and try again if the update failed\n\t\t\t\t\t\t\t\treturn packr.pack(value, encodeOptions)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpackr.lastNamedStructuresLength = sharedLength\n\t\t\t\t\t\t\t// don't keep large buffers around\n\t\t\t\t\t\t\tif (target.length > 0x40000000) target = null\n\t\t\t\t\t\t\treturn returnBuffer\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// don't keep large buffers around, they take too much memory and cause problems (limit at 1GB)\n\t\t\t\tif (target.length > 0x40000000) target = null\n\t\t\t\tif (encodeOptions & RESET_BUFFER_MODE)\n\t\t\t\t\tposition = start\n\t\t\t}\n\t\t}\n\t\tconst resetStructures = () => {\n\t\t\tif (serializationsSinceTransitionRebuild < 10)\n\t\t\t\tserializationsSinceTransitionRebuild++\n\t\t\tlet sharedLength = structures.sharedLength || 0\n\t\t\tif (structures.length > sharedLength && !isSequential)\n\t\t\t\tstructures.length = sharedLength\n\t\t\tif (transitionsCount > 10000) {\n\t\t\t\t// force a rebuild occasionally after a lot of transitions so it can get cleaned up\n\t\t\t\tstructures.transitions = null\n\t\t\t\tserializationsSinceTransitionRebuild = 0\n\t\t\t\ttransitionsCount = 0\n\t\t\t\tif (recordIdsToRemove.length > 0)\n\t\t\t\t\trecordIdsToRemove = []\n\t\t\t} else if (recordIdsToRemove.length > 0 && !isSequential) {\n\t\t\t\tfor (let i = 0, l = recordIdsToRemove.length; i < l; i++) {\n\t\t\t\t\trecordIdsToRemove[i][RECORD_SYMBOL] = 0\n\t\t\t\t}\n\t\t\t\trecordIdsToRemove = []\n\t\t\t}\n\t\t}\n\t\tconst packArray = (value) => {\n\t\t\tvar length = value.length\n\t\t\tif (length < 0x10) {\n\t\t\t\ttarget[position++] = 0x90 | length\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xdc\n\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xdd\n\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\tposition += 4\n\t\t\t}\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tpack(value[i])\n\t\t\t}\n\t\t}\n\t\tconst pack = (value) => {\n\t\t\tif (position > safeEnd)\n\t\t\t\ttarget = makeRoom(position)\n\n\t\t\tvar type = typeof value\n\t\t\tvar length\n\t\t\tif (type === 'string') {\n\t\t\t\tlet strLength = value.length\n\t\t\t\tif (bundledStrings && strLength >= 4 && strLength < 0x1000) {\n\t\t\t\t\tif ((bundledStrings.size += strLength) > MAX_BUNDLE_SIZE) {\n\t\t\t\t\t\tlet extStart\n\t\t\t\t\t\tlet maxBytes = (bundledStrings[0] ? bundledStrings[0].length * 3 + bundledStrings[1].length : 0) + 10\n\t\t\t\t\t\tif (position + maxBytes > safeEnd)\n\t\t\t\t\t\t\ttarget = makeRoom(position + maxBytes)\n\t\t\t\t\t\tlet lastBundle\n\t\t\t\t\t\tif (bundledStrings.position) { // here we use the 0x62 extension to write the last bundle and reserve space for the reference pointer to the next/current bundle\n\t\t\t\t\t\t\tlastBundle = bundledStrings\n\t\t\t\t\t\t\ttarget[position] = 0xc8 // ext 16\n\t\t\t\t\t\t\tposition += 3 // reserve for the writing bundle size\n\t\t\t\t\t\t\ttarget[position++] = 0x62 // 'b'\n\t\t\t\t\t\t\textStart = position - start\n\t\t\t\t\t\t\tposition += 4 // reserve for writing bundle reference\n\t\t\t\t\t\t\twriteBundles(start, pack, 0) // write the last bundles\n\t\t\t\t\t\t\ttargetView.setUint16(extStart + start - 3, position - start - extStart)\n\t\t\t\t\t\t} else { // here we use the 0x62 extension just to reserve the space for the reference pointer to the bundle (will be updated once the bundle is written)\n\t\t\t\t\t\t\ttarget[position++] = 0xd6 // fixext 4\n\t\t\t\t\t\t\ttarget[position++] = 0x62 // 'b'\n\t\t\t\t\t\t\textStart = position - start\n\t\t\t\t\t\t\tposition += 4 // reserve for writing bundle reference\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbundledStrings = ['', ''] // create new ones\n\t\t\t\t\t\tbundledStrings.previous = lastBundle;\n\t\t\t\t\t\tbundledStrings.size = 0\n\t\t\t\t\t\tbundledStrings.position = extStart\n\t\t\t\t\t}\n\t\t\t\t\tlet twoByte = hasNonLatin.test(value)\n\t\t\t\t\tbundledStrings[twoByte ? 0 : 1] += value\n\t\t\t\t\ttarget[position++] = 0xc1\n\t\t\t\t\tpack(twoByte ? -strLength : strLength);\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tlet headerSize\n\t\t\t\t// first we estimate the header size, so we can write to the correct location\n\t\t\t\tif (strLength < 0x20) {\n\t\t\t\t\theaderSize = 1\n\t\t\t\t} else if (strLength < 0x100) {\n\t\t\t\t\theaderSize = 2\n\t\t\t\t} else if (strLength < 0x10000) {\n\t\t\t\t\theaderSize = 3\n\t\t\t\t} else {\n\t\t\t\t\theaderSize = 5\n\t\t\t\t}\n\t\t\t\tlet maxBytes = strLength * 3\n\t\t\t\tif (position + maxBytes > safeEnd)\n\t\t\t\t\ttarget = makeRoom(position + maxBytes)\n\n\t\t\t\tif (strLength < 0x40 || !encodeUtf8) {\n\t\t\t\t\tlet i, c1, c2, strPosition = position + headerSize\n\t\t\t\t\tfor (i = 0; i < strLength; i++) {\n\t\t\t\t\t\tc1 = value.charCodeAt(i)\n\t\t\t\t\t\tif (c1 < 0x80) {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1\n\t\t\t\t\t\t} else if (c1 < 0x800) {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 | 0xc0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t(c1 & 0xfc00) === 0xd800 &&\n\t\t\t\t\t\t\t((c2 = value.charCodeAt(i + 1)) & 0xfc00) === 0xdc00\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tc1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff)\n\t\t\t\t\t\t\ti++\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 18 | 0xf0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 | 0xe0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlength = strPosition - position - headerSize\n\t\t\t\t} else {\n\t\t\t\t\tlength = encodeUtf8(value, position + headerSize)\n\t\t\t\t}\n\n\t\t\t\tif (length < 0x20) {\n\t\t\t\t\ttarget[position++] = 0xa0 | length\n\t\t\t\t} else if (length < 0x100) {\n\t\t\t\t\tif (headerSize < 2) {\n\t\t\t\t\t\ttarget.copyWithin(position + 2, position + 1, position + 1 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\t\ttarget[position++] = length\n\t\t\t\t} else if (length < 0x10000) {\n\t\t\t\t\tif (headerSize < 3) {\n\t\t\t\t\t\ttarget.copyWithin(position + 3, position + 2, position + 2 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xda\n\t\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t\t} else {\n\t\t\t\t\tif (headerSize < 5) {\n\t\t\t\t\t\ttarget.copyWithin(position + 5, position + 3, position + 3 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xdb\n\t\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\t\tposition += 4\n\t\t\t\t}\n\t\t\t\tposition += length\n\t\t\t} else if (type === 'number') {\n\t\t\t\tif (value >>> 0 === value) {// positive integer, 32-bit or less\n\t\t\t\t\t// positive uint\n\t\t\t\t\tif (value < 0x20 || (value < 0x80 && this.useRecords === false) || (value < 0x40 && !this.randomAccessStructure)) {\n\t\t\t\t\t\ttarget[position++] = value\n\t\t\t\t\t} else if (value < 0x100) {\n\t\t\t\t\t\ttarget[position++] = 0xcc\n\t\t\t\t\t\ttarget[position++] = value\n\t\t\t\t\t} else if (value < 0x10000) {\n\t\t\t\t\t\ttarget[position++] = 0xcd\n\t\t\t\t\t\ttarget[position++] = value >> 8\n\t\t\t\t\t\ttarget[position++] = value & 0xff\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[position++] = 0xce\n\t\t\t\t\t\ttargetView.setUint32(position, value)\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t}\n\t\t\t\t} else if (value >> 0 === value) { // negative integer\n\t\t\t\t\tif (value >= -0x20) {\n\t\t\t\t\t\ttarget[position++] = 0x100 + value\n\t\t\t\t\t} else if (value >= -0x80) {\n\t\t\t\t\t\ttarget[position++] = 0xd0\n\t\t\t\t\t\ttarget[position++] = value + 0x100\n\t\t\t\t\t} else if (value >= -0x8000) {\n\t\t\t\t\t\ttarget[position++] = 0xd1\n\t\t\t\t\t\ttargetView.setInt16(position, value)\n\t\t\t\t\t\tposition += 2\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[position++] = 0xd2\n\t\t\t\t\t\ttargetView.setInt32(position, value)\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet useFloat32\n\t\t\t\t\tif ((useFloat32 = this.useFloat32) > 0 && value < 0x100000000 && value >= -0x80000000) {\n\t\t\t\t\t\ttarget[position++] = 0xca\n\t\t\t\t\t\ttargetView.setFloat32(position, value)\n\t\t\t\t\t\tlet xShifted\n\t\t\t\t\t\tif (useFloat32 < 4 ||\n\t\t\t\t\t\t\t\t// this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\t\t\t((xShifted = value * _unpack_js__WEBPACK_IMPORTED_MODULE_0__.mult10[((target[position] & 0x7f) << 1) | (target[position + 1] >> 7)]) >> 0) === xShifted) {\n\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tposition-- // move back into position for writing a double\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xcb\n\t\t\t\t\ttargetView.setFloat64(position, value)\n\t\t\t\t\tposition += 8\n\t\t\t\t}\n\t\t\t} else if (type === 'object' || type === 'function') {\n\t\t\t\tif (!value)\n\t\t\t\t\ttarget[position++] = 0xc0\n\t\t\t\telse {\n\t\t\t\t\tif (referenceMap) {\n\t\t\t\t\t\tlet referee = referenceMap.get(value)\n\t\t\t\t\t\tif (referee) {\n\t\t\t\t\t\t\tif (!referee.id) {\n\t\t\t\t\t\t\t\tlet idsToInsert = referenceMap.idsToInsert || (referenceMap.idsToInsert = [])\n\t\t\t\t\t\t\t\treferee.id = idsToInsert.push(referee)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttarget[position++] = 0xd6 // fixext 4\n\t\t\t\t\t\t\ttarget[position++] = 0x70 // \"p\" for pointer\n\t\t\t\t\t\t\ttargetView.setUint32(position, referee.id)\n\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\treferenceMap.set(value, { offset: position - start })\n\t\t\t\t\t}\n\t\t\t\t\tlet constructor = value.constructor\n\t\t\t\t\tif (constructor === Object) {\n\t\t\t\t\t\twriteObject(value)\n\t\t\t\t\t} else if (constructor === Array) {\n\t\t\t\t\t\tpackArray(value)\n\t\t\t\t\t} else if (constructor === Map) {\n\t\t\t\t\t\tif (this.mapAsEmptyObject) target[position++] = 0x80\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tlength = value.size\n\t\t\t\t\t\t\tif (length < 0x10) {\n\t\t\t\t\t\t\t\ttarget[position++] = 0x80 | length\n\t\t\t\t\t\t\t} else if (length < 0x10000) {\n\t\t\t\t\t\t\t\ttarget[position++] = 0xde\n\t\t\t\t\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\t\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttarget[position++] = 0xdf\n\t\t\t\t\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (let [key, entryValue] of value) {\n\t\t\t\t\t\t\t\tpack(key)\n\t\t\t\t\t\t\t\tpack(entryValue)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (let i = 0, l = extensions.length; i < l; i++) {\n\t\t\t\t\t\t\tlet extensionClass = extensionClasses[i]\n\t\t\t\t\t\t\tif (value instanceof extensionClass) {\n\t\t\t\t\t\t\t\tlet extension = extensions[i]\n\t\t\t\t\t\t\t\tif (extension.write) {\n\t\t\t\t\t\t\t\t\tif (extension.type) {\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = 0xd4 // one byte \"tag\" extension\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = extension.type\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = 0\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tlet writeResult = extension.write.call(this, value)\n\t\t\t\t\t\t\t\t\tif (writeResult === value) { // avoid infinite recursion\n\t\t\t\t\t\t\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\t\t\t\t\t\t\tpackArray(value)\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\twriteObject(value)\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tpack(writeResult)\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlet currentTarget = target\n\t\t\t\t\t\t\t\tlet currentTargetView = targetView\n\t\t\t\t\t\t\t\tlet currentPosition = position\n\t\t\t\t\t\t\t\ttarget = null\n\t\t\t\t\t\t\t\tlet result\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tresult = extension.pack.call(this, value, (size) => {\n\t\t\t\t\t\t\t\t\t\t// restore target and use it\n\t\t\t\t\t\t\t\t\t\ttarget = currentTarget\n\t\t\t\t\t\t\t\t\t\tcurrentTarget = null\n\t\t\t\t\t\t\t\t\t\tposition += size\n\t\t\t\t\t\t\t\t\t\tif (position > safeEnd)\n\t\t\t\t\t\t\t\t\t\t\tmakeRoom(position)\n\t\t\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\t\t\ttarget, targetView, position: position - size\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}, pack)\n\t\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\t\t// restore current target information (unless already restored)\n\t\t\t\t\t\t\t\t\tif (currentTarget) {\n\t\t\t\t\t\t\t\t\t\ttarget = currentTarget\n\t\t\t\t\t\t\t\t\t\ttargetView = currentTargetView\n\t\t\t\t\t\t\t\t\t\tposition = currentPosition\n\t\t\t\t\t\t\t\t\t\tsafeEnd = target.length - 10\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (result) {\n\t\t\t\t\t\t\t\t\tif (result.length + position > safeEnd)\n\t\t\t\t\t\t\t\t\t\tmakeRoom(result.length + position)\n\t\t\t\t\t\t\t\t\tposition = writeExtensionData(result, target, position, extension.type)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// check isArray after extensions, because extensions can extend Array\n\t\t\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\t\t\tpackArray(value)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// use this as an alternate mechanism for expressing how to serialize\n\t\t\t\t\t\t\tif (value.toJSON) {\n\t\t\t\t\t\t\t\tconst json = value.toJSON()\n\t\t\t\t\t\t\t\t// if for some reason value.toJSON returns itself it'll loop forever\n\t\t\t\t\t\t\t\tif (json !== value)\n\t\t\t\t\t\t\t\t\treturn pack(json)\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// if there is a writeFunction, use it, otherwise just encode as undefined\n\t\t\t\t\t\t\tif (type === 'function')\n\t\t\t\t\t\t\t\treturn pack(this.writeFunction && this.writeFunction(value));\n\n\t\t\t\t\t\t\t// no extension found, write as plain object\n\t\t\t\t\t\t\twriteObject(value)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (type === 'boolean') {\n\t\t\t\ttarget[position++] = value ? 0xc3 : 0xc2\n\t\t\t} else if (type === 'bigint') {\n\t\t\t\tif (value < 0x8000000000000000 && value >= -0x8000000000000000) {\n\t\t\t\t\t// use a signed int as long as it fits\n\t\t\t\t\ttarget[position++] = 0xd3\n\t\t\t\t\ttargetView.setBigInt64(position, value)\n\t\t\t\t} else if (value < 0x10000000000000000 && value > 0) {\n\t\t\t\t\t// if we can fit an unsigned int, use that\n\t\t\t\t\ttarget[position++] = 0xcf\n\t\t\t\t\ttargetView.setBigUint64(position, value)\n\t\t\t\t} else {\n\t\t\t\t\t// overflow\n\t\t\t\t\tif (this.largeBigIntToFloat) {\n\t\t\t\t\t\ttarget[position++] = 0xcb\n\t\t\t\t\t\ttargetView.setFloat64(position, Number(value))\n\t\t\t\t\t} else if (this.largeBigIntToString) {\n\t\t\t\t\t\treturn pack(value.toString());\n\t\t\t\t\t} else if (this.useBigIntExtension || this.moreTypes) {\n\t\t\t\t\t\tlet empty = value < 0 ? BigInt(-1) : BigInt(0)\n\n\t\t\t\t\t\tlet array\n\t\t\t\t\t\tif (value >> BigInt(0x10000) === empty) {\n\t\t\t\t\t\t\tlet mask = BigInt(0x10000000000000000) - BigInt(1) // literal would overflow\n\t\t\t\t\t\t\tlet chunks = []\n\t\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\t\tchunks.push(value & mask)\n\t\t\t\t\t\t\t\tif ((value >> BigInt(63)) === empty) break\n\t\t\t\t\t\t\t\tvalue >>= BigInt(64)\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tarray = new Uint8Array(new BigUint64Array(chunks).buffer)\n\t\t\t\t\t\t\tarray.reverse()\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlet invert = value < 0\n\t\t\t\t\t\t\tlet string = (invert ? ~value : value).toString(16)\n\t\t\t\t\t\t\tif (string.length % 2) {\n\t\t\t\t\t\t\t\tstring = '0' + string\n\t\t\t\t\t\t\t} else if (parseInt(string.charAt(0), 16) >= 8) {\n\t\t\t\t\t\t\t\tstring = '00' + string\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (hasNodeBuffer) {\n\t\t\t\t\t\t\t\tarray = Buffer.from(string, 'hex')\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tarray = new Uint8Array(string.length / 2)\n\t\t\t\t\t\t\t\tfor (let i = 0; i < array.length; i++) {\n\t\t\t\t\t\t\t\t\tarray[i] = parseInt(string.slice(i * 2, i * 2 + 2), 16)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (invert) {\n\t\t\t\t\t\t\t\tfor (let i = 0; i < array.length; i++) array[i] = ~array[i]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (array.length + position > safeEnd)\n\t\t\t\t\t\t\tmakeRoom(array.length + position)\n\t\t\t\t\t\tposition = writeExtensionData(array, target, position, 0x42)\n\t\t\t\t\t\treturn\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new RangeError(value + ' was too large to fit in MessagePack 64-bit integer format, use' +\n\t\t\t\t\t\t\t' useBigIntExtension, or set largeBigIntToFloat to convert to float-64, or set' +\n\t\t\t\t\t\t\t' largeBigIntToString to convert to string')\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tposition += 8\n\t\t\t} else if (type === 'undefined') {\n\t\t\t\tif (this.encodeUndefinedAsNil)\n\t\t\t\t\ttarget[position++] = 0xc0\n\t\t\t\telse {\n\t\t\t\t\ttarget[position++] = 0xd4 // a number of implementations use fixext1 with type 0, data 0 to denote undefined, so we follow suite\n\t\t\t\t\ttarget[position++] = 0\n\t\t\t\t\ttarget[position++] = 0\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new Error('Unknown type: ' + type)\n\t\t\t}\n\t\t}\n\n\t\tconst writePlainObject = (this.variableMapSize || this.coercibleKeyAsNumber || this.skipValues) ? (object) => {\n\t\t\t// this method is slightly slower, but generates \"preferred serialization\" (optimally small for smaller objects)\n\t\t\tlet keys;\n\t\t\tif (this.skipValues) {\n\t\t\t\tkeys = [];\n\t\t\t\tfor (let key in object) {\n\t\t\t\t\tif ((typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) &&\n\t\t\t\t\t\t!this.skipValues.includes(object[key]))\n\t\t\t\t\t\tkeys.push(key);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tkeys = Object.keys(object)\n\t\t\t}\n\t\t\tlet length = keys.length\n\t\t\tif (length < 0x10) {\n\t\t\t\ttarget[position++] = 0x80 | length\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xde\n\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xdf\n\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\tposition += 4\n\t\t\t}\n\t\t\tlet key\n\t\t\tif (this.coercibleKeyAsNumber) {\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tkey = keys[i]\n\t\t\t\t\tlet num = Number(key)\n\t\t\t\t\tpack(isNaN(num) ? key : num)\n\t\t\t\t\tpack(object[key])\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tpack(key = keys[i])\n\t\t\t\t\tpack(object[key])\n\t\t\t\t}\n\t\t\t}\n\t\t} :\n\t\t(object) => {\n\t\t\ttarget[position++] = 0xde // always using map 16, so we can preallocate and set the length afterwards\n\t\t\tlet objectOffset = position - start\n\t\t\tposition += 2\n\t\t\tlet size = 0\n\t\t\tfor (let key in object) {\n\t\t\t\tif (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n\t\t\t\t\tpack(key)\n\t\t\t\t\tpack(object[key])\n\t\t\t\t\tsize++\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (size > 0xffff) {\n\t\t\t\tthrow new Error('Object is too large to serialize with fast 16-bit map size,' +\n\t\t\t\t' use the \"variableMapSize\" option to serialize this object');\n\t\t\t}\n\t\t\ttarget[objectOffset++ + start] = size >> 8\n\t\t\ttarget[objectOffset + start] = size & 0xff\n\t\t}\n\n\t\tconst writeRecord = this.useRecords === false ? writePlainObject :\n\t\t(options.progressiveRecords && !useTwoByteRecords) ?  // this is about 2% faster for highly stable structures, since it only requires one for-in loop (but much more expensive when new structure needs to be written)\n\t\t(object) => {\n\t\t\tlet nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null))\n\t\t\tlet objectOffset = position++ - start\n\t\t\tlet wroteKeys\n\t\t\tfor (let key in object) {\n\t\t\t\tif (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\tif (nextTransition)\n\t\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\telse {\n\t\t\t\t\t\t// record doesn't exist, create full new record and insert it\n\t\t\t\t\t\tlet keys = Object.keys(object)\n\t\t\t\t\t\tlet lastTransition = transition\n\t\t\t\t\t\ttransition = structures.transitions\n\t\t\t\t\t\tlet newTransitions = 0\n\t\t\t\t\t\tfor (let i = 0, l = keys.length; i < l; i++) {\n\t\t\t\t\t\t\tlet key = keys[i]\n\t\t\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\t\t\tnewTransitions++\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (objectOffset + start + 1 == position) {\n\t\t\t\t\t\t\t// first key, so we don't need to insert, we can just write record directly\n\t\t\t\t\t\t\tposition--\n\t\t\t\t\t\t\tnewRecord(transition, keys, newTransitions)\n\t\t\t\t\t\t} else // otherwise we need to insert the record, moving existing data after the record\n\t\t\t\t\t\t\tinsertNewRecord(transition, keys, objectOffset, newTransitions)\n\t\t\t\t\t\twroteKeys = true\n\t\t\t\t\t\ttransition = lastTransition[key]\n\t\t\t\t\t}\n\t\t\t\t\tpack(object[key])\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!wroteKeys) {\n\t\t\t\tlet recordId = transition[RECORD_SYMBOL]\n\t\t\t\tif (recordId)\n\t\t\t\t\ttarget[objectOffset + start] = recordId\n\t\t\t\telse\n\t\t\t\t\tinsertNewRecord(transition, Object.keys(object), objectOffset, 0)\n\t\t\t}\n\t\t} :\n\t\t(object) => {\n\t\t\tlet nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null))\n\t\t\tlet newTransitions = 0\n\t\t\tfor (let key in object) if (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n\t\t\t\tnextTransition = transition[key]\n\t\t\t\tif (!nextTransition) {\n\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\tnewTransitions++\n\t\t\t\t}\n\t\t\t\ttransition = nextTransition\n\t\t\t}\n\t\t\tlet recordId = transition[RECORD_SYMBOL]\n\t\t\tif (recordId) {\n\t\t\t\tif (recordId >= 0x60 && useTwoByteRecords) {\n\t\t\t\t\ttarget[position++] = ((recordId -= 0x60) & 0x1f) + 0x60\n\t\t\t\t\ttarget[position++] = recordId >> 5\n\t\t\t\t} else\n\t\t\t\t\ttarget[position++] = recordId\n\t\t\t} else {\n\t\t\t\tnewRecord(transition, transition.__keys__ || Object.keys(object), newTransitions)\n\t\t\t}\n\t\t\t// now write the values\n\t\t\tfor (let key in object)\n\t\t\t\tif (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n\t\t\t\t\tpack(object[key])\n\t\t\t\t}\n\t\t}\n\n\t\t// create reference to useRecords if useRecords is a function\n\t\tconst checkUseRecords = typeof this.useRecords == 'function' && this.useRecords;\n\n\t\tconst writeObject = checkUseRecords ? (object) => {\n\t\t\tcheckUseRecords(object) ? writeRecord(object) : writePlainObject(object)\n\t\t} : writeRecord\n\n\t\tconst makeRoom = (end) => {\n\t\t\tlet newSize\n\t\t\tif (end > 0x1000000) {\n\t\t\t\t// special handling for really large buffers\n\t\t\t\tif ((end - start) > MAX_BUFFER_SIZE)\n\t\t\t\t\tthrow new Error('Packed buffer would be larger than maximum buffer size')\n\t\t\t\tnewSize = Math.min(MAX_BUFFER_SIZE,\n\t\t\t\t\tMath.round(Math.max((end - start) * (end > 0x4000000 ? 1.25 : 2), 0x400000) / 0x1000) * 0x1000)\n\t\t\t} else // faster handling for smaller buffers\n\t\t\t\tnewSize = ((Math.max((end - start) << 2, target.length - 1) >> 12) + 1) << 12\n\t\t\tlet newBuffer = new ByteArrayAllocate(newSize)\n\t\t\ttargetView = newBuffer.dataView || (newBuffer.dataView = new DataView(newBuffer.buffer, 0, newSize))\n\t\t\tend = Math.min(end, target.length)\n\t\t\tif (target.copy)\n\t\t\t\ttarget.copy(newBuffer, 0, start, end)\n\t\t\telse\n\t\t\t\tnewBuffer.set(target.slice(start, end))\n\t\t\tposition -= start\n\t\t\tstart = 0\n\t\t\tsafeEnd = newBuffer.length - 10\n\t\t\treturn target = newBuffer\n\t\t}\n\t\tconst newRecord = (transition, keys, newTransitions) => {\n\t\t\tlet recordId = structures.nextId\n\t\t\tif (!recordId)\n\t\t\t\trecordId = 0x40\n\t\t\tif (recordId < sharedLimitId && this.shouldShareStructure && !this.shouldShareStructure(keys)) {\n\t\t\t\trecordId = structures.nextOwnId\n\t\t\t\tif (!(recordId < maxStructureId))\n\t\t\t\t\trecordId = sharedLimitId\n\t\t\t\tstructures.nextOwnId = recordId + 1\n\t\t\t} else {\n\t\t\t\tif (recordId >= maxStructureId)// cycle back around\n\t\t\t\t\trecordId = sharedLimitId\n\t\t\t\tstructures.nextId = recordId + 1\n\t\t\t}\n\t\t\tlet highByte = keys.highByte = recordId >= 0x60 && useTwoByteRecords ? (recordId - 0x60) >> 5 : -1\n\t\t\ttransition[RECORD_SYMBOL] = recordId\n\t\t\ttransition.__keys__ = keys\n\t\t\tstructures[recordId - 0x40] = keys\n\n\t\t\tif (recordId < sharedLimitId) {\n\t\t\t\tkeys.isShared = true\n\t\t\t\tstructures.sharedLength = recordId - 0x3f\n\t\t\t\thasSharedUpdate = true\n\t\t\t\tif (highByte >= 0) {\n\t\t\t\t\ttarget[position++] = (recordId & 0x1f) + 0x60\n\t\t\t\t\ttarget[position++] = highByte\n\t\t\t\t} else {\n\t\t\t\t\ttarget[position++] = recordId\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (highByte >= 0) {\n\t\t\t\t\ttarget[position++] = 0xd5 // fixext 2\n\t\t\t\t\ttarget[position++] = 0x72 // \"r\" record defintion extension type\n\t\t\t\t\ttarget[position++] = (recordId & 0x1f) + 0x60\n\t\t\t\t\ttarget[position++] = highByte\n\t\t\t\t} else {\n\t\t\t\t\ttarget[position++] = 0xd4 // fixext 1\n\t\t\t\t\ttarget[position++] = 0x72 // \"r\" record defintion extension type\n\t\t\t\t\ttarget[position++] = recordId\n\t\t\t\t}\n\n\t\t\t\tif (newTransitions)\n\t\t\t\t\ttransitionsCount += serializationsSinceTransitionRebuild * newTransitions\n\t\t\t\t// record the removal of the id, we can maintain our shared structure\n\t\t\t\tif (recordIdsToRemove.length >= maxOwnStructures)\n\t\t\t\t\trecordIdsToRemove.shift()[RECORD_SYMBOL] = 0 // we are cycling back through, and have to remove old ones\n\t\t\t\trecordIdsToRemove.push(transition)\n\t\t\t\tpack(keys)\n\t\t\t}\n\t\t}\n\t\tconst insertNewRecord = (transition, keys, insertionOffset, newTransitions) => {\n\t\t\tlet mainTarget = target\n\t\t\tlet mainPosition = position\n\t\t\tlet mainSafeEnd = safeEnd\n\t\t\tlet mainStart = start\n\t\t\ttarget = keysTarget\n\t\t\tposition = 0\n\t\t\tstart = 0\n\t\t\tif (!target)\n\t\t\t\tkeysTarget = target = new ByteArrayAllocate(8192)\n\t\t\tsafeEnd = target.length - 10\n\t\t\tnewRecord(transition, keys, newTransitions)\n\t\t\tkeysTarget = target\n\t\t\tlet keysPosition = position\n\t\t\ttarget = mainTarget\n\t\t\tposition = mainPosition\n\t\t\tsafeEnd = mainSafeEnd\n\t\t\tstart = mainStart\n\t\t\tif (keysPosition > 1) {\n\t\t\t\tlet newEnd = position + keysPosition - 1\n\t\t\t\tif (newEnd > safeEnd)\n\t\t\t\t\tmakeRoom(newEnd)\n\t\t\t\tlet insertionPosition = insertionOffset + start\n\t\t\t\ttarget.copyWithin(insertionPosition + keysPosition, insertionPosition + 1, position)\n\t\t\t\ttarget.set(keysTarget.slice(0, keysPosition), insertionPosition)\n\t\t\t\tposition = newEnd\n\t\t\t} else {\n\t\t\t\ttarget[insertionOffset + start] = keysTarget[0]\n\t\t\t}\n\t\t}\n\t\tconst writeStruct = (object) => {\n\t\t\tlet newPosition = writeStructSlots(object, target, start, position, structures, makeRoom, (value, newPosition, notifySharedUpdate) => {\n\t\t\t\tif (notifySharedUpdate)\n\t\t\t\t\treturn hasSharedUpdate = true;\n\t\t\t\tposition = newPosition;\n\t\t\t\tlet startTarget = target;\n\t\t\t\tpack(value);\n\t\t\t\tresetStructures();\n\t\t\t\tif (startTarget !== target) {\n\t\t\t\t\treturn { position, targetView, target }; // indicate the buffer was re-allocated\n\t\t\t\t}\n\t\t\t\treturn position;\n\t\t\t}, this);\n\t\t\tif (newPosition === 0) // bail and go to a msgpack object\n\t\t\t\treturn writeObject(object);\n\t\t\tposition = newPosition;\n\t\t}\n\t}\n\tuseBuffer(buffer) {\n\t\t// this means we are finished using our own buffer and we can write over it safely\n\t\ttarget = buffer\n\t\ttarget.dataView || (target.dataView = new DataView(target.buffer, target.byteOffset, target.byteLength))\n\t\ttargetView = target.dataView;\n\t\tposition = 0\n\t}\n\tset position (value) {\n\t\tposition = value;\n\t}\n\tget position() {\n\t\treturn position;\n\t}\n\tclearSharedData() {\n\t\tif (this.structures)\n\t\t\tthis.structures = []\n\t\tif (this.typedStructs)\n\t\t\tthis.typedStructs = []\n\t}\n}\n\nextensionClasses = [ Date, Set, Error, RegExp, ArrayBuffer, Object.getPrototypeOf(Uint8Array.prototype).constructor /*TypedArray*/, DataView, _unpack_js__WEBPACK_IMPORTED_MODULE_0__.C1Type ]\nextensions = [{\n\tpack(date, allocateForWrite, pack) {\n\t\tlet seconds = date.getTime() / 1000\n\t\tif ((this.useTimestamp32 || date.getMilliseconds() === 0) && seconds >= 0 && seconds < 0x100000000) {\n\t\t\t// Timestamp 32\n\t\t\tlet { target, targetView, position} = allocateForWrite(6)\n\t\t\ttarget[position++] = 0xd6\n\t\t\ttarget[position++] = 0xff\n\t\t\ttargetView.setUint32(position, seconds)\n\t\t} else if (seconds > 0 && seconds < 0x100000000) {\n\t\t\t// Timestamp 64\n\t\t\tlet { target, targetView, position} = allocateForWrite(10)\n\t\t\ttarget[position++] = 0xd7\n\t\t\ttarget[position++] = 0xff\n\t\t\ttargetView.setUint32(position, date.getMilliseconds() * 4000000 + ((seconds / 1000 / 0x100000000) >> 0))\n\t\t\ttargetView.setUint32(position + 4, seconds)\n\t\t} else if (isNaN(seconds)) {\n\t\t\tif (this.onInvalidDate) {\n\t\t\t\tallocateForWrite(0)\n\t\t\t\treturn pack(this.onInvalidDate())\n\t\t\t}\n\t\t\t// Intentionally invalid timestamp\n\t\t\tlet { target, targetView, position} = allocateForWrite(3)\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0xff\n\t\t\ttarget[position++] = 0xff\n\t\t} else {\n\t\t\t// Timestamp 96\n\t\t\tlet { target, targetView, position} = allocateForWrite(15)\n\t\t\ttarget[position++] = 0xc7\n\t\t\ttarget[position++] = 12\n\t\t\ttarget[position++] = 0xff\n\t\t\ttargetView.setUint32(position, date.getMilliseconds() * 1000000)\n\t\t\ttargetView.setBigInt64(position + 4, BigInt(Math.floor(seconds)))\n\t\t}\n\t}\n}, {\n\tpack(set, allocateForWrite, pack) {\n\t\tif (this.setAsEmptyObject) {\n\t\t\tallocateForWrite(0);\n\t\t\treturn pack({})\n\t\t}\n\t\tlet array = Array.from(set)\n\t\tlet { target, position} = allocateForWrite(this.moreTypes ? 3 : 0)\n\t\tif (this.moreTypes) {\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0x73 // 's' for Set\n\t\t\ttarget[position++] = 0\n\t\t}\n\t\tpack(array)\n\t}\n}, {\n\tpack(error, allocateForWrite, pack) {\n\t\tlet { target, position} = allocateForWrite(this.moreTypes ? 3 : 0)\n\t\tif (this.moreTypes) {\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0x65 // 'e' for error\n\t\t\ttarget[position++] = 0\n\t\t}\n\t\tpack([ error.name, error.message, error.cause ])\n\t}\n}, {\n\tpack(regex, allocateForWrite, pack) {\n\t\tlet { target, position} = allocateForWrite(this.moreTypes ? 3 : 0)\n\t\tif (this.moreTypes) {\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0x78 // 'x' for regeXp\n\t\t\ttarget[position++] = 0\n\t\t}\n\t\tpack([ regex.source, regex.flags ])\n\t}\n}, {\n\tpack(arrayBuffer, allocateForWrite) {\n\t\tif (this.moreTypes)\n\t\t\twriteExtBuffer(arrayBuffer, 0x10, allocateForWrite)\n\t\telse\n\t\t\twriteBuffer(hasNodeBuffer ? Buffer.from(arrayBuffer) : new Uint8Array(arrayBuffer), allocateForWrite)\n\t}\n}, {\n\tpack(typedArray, allocateForWrite) {\n\t\tlet constructor = typedArray.constructor\n\t\tif (constructor !== ByteArray && this.moreTypes)\n\t\t\twriteExtBuffer(typedArray, _unpack_js__WEBPACK_IMPORTED_MODULE_0__.typedArrays.indexOf(constructor.name), allocateForWrite)\n\t\telse\n\t\t\twriteBuffer(typedArray, allocateForWrite)\n\t}\n}, {\n\tpack(arrayBuffer, allocateForWrite) {\n\t\tif (this.moreTypes)\n\t\t\twriteExtBuffer(arrayBuffer, 0x11, allocateForWrite)\n\t\telse\n\t\t\twriteBuffer(hasNodeBuffer ? Buffer.from(arrayBuffer) : new Uint8Array(arrayBuffer), allocateForWrite)\n\t}\n}, {\n\tpack(c1, allocateForWrite) { // specific 0xC1 object\n\t\tlet { target, position} = allocateForWrite(1)\n\t\ttarget[position] = 0xc1\n\t}\n}]\n\nfunction writeExtBuffer(typedArray, type, allocateForWrite, encode) {\n\tlet length = typedArray.byteLength\n\tif (length + 1 < 0x100) {\n\t\tvar { target, position } = allocateForWrite(4 + length)\n\t\ttarget[position++] = 0xc7\n\t\ttarget[position++] = length + 1\n\t} else if (length + 1 < 0x10000) {\n\t\tvar { target, position } = allocateForWrite(5 + length)\n\t\ttarget[position++] = 0xc8\n\t\ttarget[position++] = (length + 1) >> 8\n\t\ttarget[position++] = (length + 1) & 0xff\n\t} else {\n\t\tvar { target, position, targetView } = allocateForWrite(7 + length)\n\t\ttarget[position++] = 0xc9\n\t\ttargetView.setUint32(position, length + 1) // plus one for the type byte\n\t\tposition += 4\n\t}\n\ttarget[position++] = 0x74 // \"t\" for typed array\n\ttarget[position++] = type\n\tif (!typedArray.buffer) typedArray = new Uint8Array(typedArray)\n\ttarget.set(new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength), position)\n}\nfunction writeBuffer(buffer, allocateForWrite) {\n\tlet length = buffer.byteLength\n\tvar target, position\n\tif (length < 0x100) {\n\t\tvar { target, position } = allocateForWrite(length + 2)\n\t\ttarget[position++] = 0xc4\n\t\ttarget[position++] = length\n\t} else if (length < 0x10000) {\n\t\tvar { target, position } = allocateForWrite(length + 3)\n\t\ttarget[position++] = 0xc5\n\t\ttarget[position++] = length >> 8\n\t\ttarget[position++] = length & 0xff\n\t} else {\n\t\tvar { target, position, targetView } = allocateForWrite(length + 5)\n\t\ttarget[position++] = 0xc6\n\t\ttargetView.setUint32(position, length)\n\t\tposition += 4\n\t}\n\ttarget.set(buffer, position)\n}\n\nfunction writeExtensionData(result, target, position, type) {\n\tlet length = result.length\n\tswitch (length) {\n\t\tcase 1:\n\t\t\ttarget[position++] = 0xd4\n\t\t\tbreak\n\t\tcase 2:\n\t\t\ttarget[position++] = 0xd5\n\t\t\tbreak\n\t\tcase 4:\n\t\t\ttarget[position++] = 0xd6\n\t\t\tbreak\n\t\tcase 8:\n\t\t\ttarget[position++] = 0xd7\n\t\t\tbreak\n\t\tcase 16:\n\t\t\ttarget[position++] = 0xd8\n\t\t\tbreak\n\t\tdefault:\n\t\t\tif (length < 0x100) {\n\t\t\t\ttarget[position++] = 0xc7\n\t\t\t\ttarget[position++] = length\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xc8\n\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xc9\n\t\t\t\ttarget[position++] = length >> 24\n\t\t\t\ttarget[position++] = (length >> 16) & 0xff\n\t\t\t\ttarget[position++] = (length >> 8) & 0xff\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t}\n\t}\n\ttarget[position++] = type\n\ttarget.set(result, position)\n\tposition += length\n\treturn position\n}\n\nfunction insertIds(serialized, idsToInsert) {\n\t// insert the ids that need to be referenced for structured clones\n\tlet nextId\n\tlet distanceToMove = idsToInsert.length * 6\n\tlet lastEnd = serialized.length - distanceToMove\n\twhile (nextId = idsToInsert.pop()) {\n\t\tlet offset = nextId.offset\n\t\tlet id = nextId.id\n\t\tserialized.copyWithin(offset + distanceToMove, offset, lastEnd)\n\t\tdistanceToMove -= 6\n\t\tlet position = offset + distanceToMove\n\t\tserialized[position++] = 0xd6\n\t\tserialized[position++] = 0x69 // 'i'\n\t\tserialized[position++] = id >> 24\n\t\tserialized[position++] = (id >> 16) & 0xff\n\t\tserialized[position++] = (id >> 8) & 0xff\n\t\tserialized[position++] = id & 0xff\n\t\tlastEnd = offset\n\t}\n\treturn serialized\n}\n\nfunction writeBundles(start, pack, incrementPosition) {\n\tif (bundledStrings.length > 0) {\n\t\ttargetView.setUint32(bundledStrings.position + start, position + incrementPosition - bundledStrings.position - start)\n\t\tbundledStrings.stringsPosition = position - start;\n\t\tlet writeStrings = bundledStrings\n\t\tbundledStrings = null\n\t\tpack(writeStrings[0])\n\t\tpack(writeStrings[1])\n\t}\n}\n\nfunction addExtension(extension) {\n\tif (extension.Class) {\n\t\tif (!extension.pack && !extension.write)\n\t\t\tthrow new Error('Extension has no pack or write function')\n\t\tif (extension.pack && !extension.type)\n\t\t\tthrow new Error('Extension has no type (numeric code to identify the extension)')\n\t\textensionClasses.unshift(extension.Class)\n\t\textensions.unshift(extension)\n\t}\n\t(0,_unpack_js__WEBPACK_IMPORTED_MODULE_0__.addExtension)(extension)\n}\nfunction prepareStructures(structures, packr) {\n\tstructures.isCompatible = (existingStructures) => {\n\t\tlet compatible = !existingStructures || ((packr.lastNamedStructuresLength || 0) === existingStructures.length)\n\t\tif (!compatible) // we want to merge these existing structures immediately since we already have it and we are in the right transaction\n\t\t\tpackr._mergeStructures(existingStructures);\n\t\treturn compatible;\n\t}\n\treturn structures\n}\nfunction setWriteStructSlots(writeSlots, makeStructures) {\n\twriteStructSlots = writeSlots;\n\tprepareStructures = makeStructures;\n}\n\nlet defaultPackr = new Packr({ useRecords: false })\nconst pack = defaultPackr.pack\nconst encode = defaultPackr.pack\nconst Encoder = Packr\n\n;\nconst { NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT } = _unpack_js__WEBPACK_IMPORTED_MODULE_0__.FLOAT32_OPTIONS\nconst REUSE_BUFFER_MODE = 512\nconst RESET_BUFFER_MODE = 1024\nconst RESERVE_START_SPACE = 2048\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvbXNncGFja3IvcGFjay5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXNHO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0NBQXdDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDQSxvQkFBb0IsK0NBQU87QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsa0JBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsa0RBQWtELE9BQU87QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLE9BQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixlQUFlO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0saUNBQWlDO0FBQ3ZDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOENBQU07QUFDbkM7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLGlDQUFpQywwQkFBMEI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDZDQUE2QyxPQUFPO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTCxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdDQUFnQztBQUM5QztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhJQUE4SSw4Q0FBTTtBQUNwSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw4QkFBOEI7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsU0FBUyw4QkFBOEI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsOEJBQThCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLFNBQVMsOEJBQThCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsbURBQVc7QUFDekM7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCw4QkFBOEI7QUFDOUIsUUFBUSxrQkFBa0I7QUFDMUI7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsUUFBUSxtQkFBbUI7QUFDM0I7QUFDQTtBQUNBLEdBQUc7QUFDSCxRQUFRLG1CQUFtQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsUUFBUSwrQkFBK0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG1CQUFtQjtBQUMzQjtBQUNBO0FBQ0EsR0FBRztBQUNILFFBQVEsbUJBQW1CO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxRQUFRLCtCQUErQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3REFBa0I7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNzQztBQUM3QyxDQUE2QztBQUN0QyxRQUFRLDRDQUE0QyxFQUFFLHVEQUFlO0FBQ3JFO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL21pbGFuL0Rlc2t0b3AvQXBwcy9iZXR0ZXItYXV0aC9ub2RlX21vZHVsZXMvbXNncGFja3IvcGFjay5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBVbnBhY2tyLCBtdWx0MTAsIEMxVHlwZSwgdHlwZWRBcnJheXMsIGFkZEV4dGVuc2lvbiBhcyB1bnBhY2tBZGRFeHRlbnNpb24gfSBmcm9tICcuL3VucGFjay5qcydcbmxldCB0ZXh0RW5jb2RlclxudHJ5IHtcblx0dGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKVxufSBjYXRjaCAoZXJyb3IpIHt9XG5sZXQgZXh0ZW5zaW9ucywgZXh0ZW5zaW9uQ2xhc3Nlc1xuY29uc3QgaGFzTm9kZUJ1ZmZlciA9IHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnXG5jb25zdCBCeXRlQXJyYXlBbGxvY2F0ZSA9IGhhc05vZGVCdWZmZXIgP1xuXHRmdW5jdGlvbihsZW5ndGgpIHsgcmV0dXJuIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cobGVuZ3RoKSB9IDogVWludDhBcnJheVxuY29uc3QgQnl0ZUFycmF5ID0gaGFzTm9kZUJ1ZmZlciA/IEJ1ZmZlciA6IFVpbnQ4QXJyYXlcbmNvbnN0IE1BWF9CVUZGRVJfU0laRSA9IGhhc05vZGVCdWZmZXIgPyAweDEwMDAwMDAwMCA6IDB4N2ZkMDAwMDBcbmxldCB0YXJnZXQsIGtleXNUYXJnZXRcbmxldCB0YXJnZXRWaWV3XG5sZXQgcG9zaXRpb24gPSAwXG5sZXQgc2FmZUVuZFxubGV0IGJ1bmRsZWRTdHJpbmdzID0gbnVsbFxubGV0IHdyaXRlU3RydWN0U2xvdHNcbmNvbnN0IE1BWF9CVU5ETEVfU0laRSA9IDB4NTUwMCAvLyBtYXhpbXVtIGNoYXJhY3RlcnMgc3VjaCB0aGF0IHRoZSBlbmNvZGVkIGJ5dGVzIGZpdHMgaW4gMTYgYml0cy5cbmNvbnN0IGhhc05vbkxhdGluID0gL1tcXHUwMDgwLVxcdUZGRkZdL1xuZXhwb3J0IGNvbnN0IFJFQ09SRF9TWU1CT0wgPSBTeW1ib2woJ3JlY29yZC1pZCcpXG5leHBvcnQgY2xhc3MgUGFja3IgZXh0ZW5kcyBVbnBhY2tyIHtcblx0Y29uc3RydWN0b3Iob3B0aW9ucykge1xuXHRcdHN1cGVyKG9wdGlvbnMpXG5cdFx0dGhpcy5vZmZzZXQgPSAwXG5cdFx0bGV0IHR5cGVCdWZmZXJcblx0XHRsZXQgc3RhcnRcblx0XHRsZXQgaGFzU2hhcmVkVXBkYXRlXG5cdFx0bGV0IHN0cnVjdHVyZXNcblx0XHRsZXQgcmVmZXJlbmNlTWFwXG5cdFx0bGV0IGVuY29kZVV0ZjggPSBCeXRlQXJyYXkucHJvdG90eXBlLnV0ZjhXcml0ZSA/IGZ1bmN0aW9uKHN0cmluZywgcG9zaXRpb24pIHtcblx0XHRcdHJldHVybiB0YXJnZXQudXRmOFdyaXRlKHN0cmluZywgcG9zaXRpb24sIHRhcmdldC5ieXRlTGVuZ3RoIC0gcG9zaXRpb24pXG5cdFx0fSA6ICh0ZXh0RW5jb2RlciAmJiB0ZXh0RW5jb2Rlci5lbmNvZGVJbnRvKSA/XG5cdFx0XHRmdW5jdGlvbihzdHJpbmcsIHBvc2l0aW9uKSB7XG5cdFx0XHRcdHJldHVybiB0ZXh0RW5jb2Rlci5lbmNvZGVJbnRvKHN0cmluZywgdGFyZ2V0LnN1YmFycmF5KHBvc2l0aW9uKSkud3JpdHRlblxuXHRcdFx0fSA6IGZhbHNlXG5cblx0XHRsZXQgcGFja3IgPSB0aGlzXG5cdFx0aWYgKCFvcHRpb25zKVxuXHRcdFx0b3B0aW9ucyA9IHt9XG5cdFx0bGV0IGlzU2VxdWVudGlhbCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5zZXF1ZW50aWFsXG5cdFx0bGV0IGhhc1NoYXJlZFN0cnVjdHVyZXMgPSBvcHRpb25zLnN0cnVjdHVyZXMgfHwgb3B0aW9ucy5zYXZlU3RydWN0dXJlc1xuXHRcdGxldCBtYXhTaGFyZWRTdHJ1Y3R1cmVzID0gb3B0aW9ucy5tYXhTaGFyZWRTdHJ1Y3R1cmVzXG5cdFx0aWYgKG1heFNoYXJlZFN0cnVjdHVyZXMgPT0gbnVsbClcblx0XHRcdG1heFNoYXJlZFN0cnVjdHVyZXMgPSBoYXNTaGFyZWRTdHJ1Y3R1cmVzID8gMzIgOiAwXG5cdFx0aWYgKG1heFNoYXJlZFN0cnVjdHVyZXMgPiA4MTYwKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNYXhpbXVtIG1heFNoYXJlZFN0cnVjdHVyZSBpcyA4MTYwJylcblx0XHRpZiAob3B0aW9ucy5zdHJ1Y3R1cmVkQ2xvbmUgJiYgb3B0aW9ucy5tb3JlVHlwZXMgPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLm1vcmVUeXBlcyA9IHRydWVcblx0XHR9XG5cdFx0bGV0IG1heE93blN0cnVjdHVyZXMgPSBvcHRpb25zLm1heE93blN0cnVjdHVyZXNcblx0XHRpZiAobWF4T3duU3RydWN0dXJlcyA9PSBudWxsKVxuXHRcdFx0bWF4T3duU3RydWN0dXJlcyA9IGhhc1NoYXJlZFN0cnVjdHVyZXMgPyAzMiA6IDY0XG5cdFx0aWYgKCF0aGlzLnN0cnVjdHVyZXMgJiYgb3B0aW9ucy51c2VSZWNvcmRzICE9IGZhbHNlKVxuXHRcdFx0dGhpcy5zdHJ1Y3R1cmVzID0gW11cblx0XHQvLyB0d28gYnl0ZSByZWNvcmQgaWRzIGZvciBzaGFyZWQgc3RydWN0dXJlc1xuXHRcdGxldCB1c2VUd29CeXRlUmVjb3JkcyA9IG1heFNoYXJlZFN0cnVjdHVyZXMgPiAzMiB8fCAobWF4T3duU3RydWN0dXJlcyArIG1heFNoYXJlZFN0cnVjdHVyZXMgPiA2NClcblx0XHRsZXQgc2hhcmVkTGltaXRJZCA9IG1heFNoYXJlZFN0cnVjdHVyZXMgKyAweDQwXG5cdFx0bGV0IG1heFN0cnVjdHVyZUlkID0gbWF4U2hhcmVkU3RydWN0dXJlcyArIG1heE93blN0cnVjdHVyZXMgKyAweDQwXG5cdFx0aWYgKG1heFN0cnVjdHVyZUlkID4gODI1Nikge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNYXhpbXVtIG1heFNoYXJlZFN0cnVjdHVyZSArIG1heE93blN0cnVjdHVyZSBpcyA4MTkyJylcblx0XHR9XG5cdFx0bGV0IHJlY29yZElkc1RvUmVtb3ZlID0gW11cblx0XHRsZXQgdHJhbnNpdGlvbnNDb3VudCA9IDBcblx0XHRsZXQgc2VyaWFsaXphdGlvbnNTaW5jZVRyYW5zaXRpb25SZWJ1aWxkID0gMFxuXG5cdFx0dGhpcy5wYWNrID0gdGhpcy5lbmNvZGUgPSBmdW5jdGlvbih2YWx1ZSwgZW5jb2RlT3B0aW9ucykge1xuXHRcdFx0aWYgKCF0YXJnZXQpIHtcblx0XHRcdFx0dGFyZ2V0ID0gbmV3IEJ5dGVBcnJheUFsbG9jYXRlKDgxOTIpXG5cdFx0XHRcdHRhcmdldFZpZXcgPSB0YXJnZXQuZGF0YVZpZXcgfHwgKHRhcmdldC5kYXRhVmlldyA9IG5ldyBEYXRhVmlldyh0YXJnZXQuYnVmZmVyLCAwLCA4MTkyKSlcblx0XHRcdFx0cG9zaXRpb24gPSAwXG5cdFx0XHR9XG5cdFx0XHRzYWZlRW5kID0gdGFyZ2V0Lmxlbmd0aCAtIDEwXG5cdFx0XHRpZiAoc2FmZUVuZCAtIHBvc2l0aW9uIDwgMHg4MDApIHtcblx0XHRcdFx0Ly8gZG9uJ3Qgc3RhcnQgdG9vIGNsb3NlIHRvIHRoZSBlbmQsXG5cdFx0XHRcdHRhcmdldCA9IG5ldyBCeXRlQXJyYXlBbGxvY2F0ZSh0YXJnZXQubGVuZ3RoKVxuXHRcdFx0XHR0YXJnZXRWaWV3ID0gdGFyZ2V0LmRhdGFWaWV3IHx8ICh0YXJnZXQuZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcodGFyZ2V0LmJ1ZmZlciwgMCwgdGFyZ2V0Lmxlbmd0aCkpXG5cdFx0XHRcdHNhZmVFbmQgPSB0YXJnZXQubGVuZ3RoIC0gMTBcblx0XHRcdFx0cG9zaXRpb24gPSAwXG5cdFx0XHR9IGVsc2Vcblx0XHRcdFx0cG9zaXRpb24gPSAocG9zaXRpb24gKyA3KSAmIDB4N2ZmZmZmZjggLy8gV29yZCBhbGlnbiB0byBtYWtlIGFueSBmdXR1cmUgY29weWluZyBvZiB0aGlzIGJ1ZmZlciBmYXN0ZXJcblx0XHRcdHN0YXJ0ID0gcG9zaXRpb25cblx0XHRcdGlmIChlbmNvZGVPcHRpb25zICYgUkVTRVJWRV9TVEFSVF9TUEFDRSkgcG9zaXRpb24gKz0gKGVuY29kZU9wdGlvbnMgJiAweGZmKVxuXHRcdFx0cmVmZXJlbmNlTWFwID0gcGFja3Iuc3RydWN0dXJlZENsb25lID8gbmV3IE1hcCgpIDogbnVsbFxuXHRcdFx0aWYgKHBhY2tyLmJ1bmRsZVN0cmluZ3MgJiYgdHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuXHRcdFx0XHRidW5kbGVkU3RyaW5ncyA9IFtdXG5cdFx0XHRcdGJ1bmRsZWRTdHJpbmdzLnNpemUgPSBJbmZpbml0eSAvLyBmb3JjZSBhIG5ldyBidW5kbGUgc3RhcnQgb24gZmlyc3Qgc3RyaW5nXG5cdFx0XHR9IGVsc2Vcblx0XHRcdFx0YnVuZGxlZFN0cmluZ3MgPSBudWxsXG5cdFx0XHRzdHJ1Y3R1cmVzID0gcGFja3Iuc3RydWN0dXJlc1xuXHRcdFx0aWYgKHN0cnVjdHVyZXMpIHtcblx0XHRcdFx0aWYgKHN0cnVjdHVyZXMudW5pbml0aWFsaXplZClcblx0XHRcdFx0XHRzdHJ1Y3R1cmVzID0gcGFja3IuX21lcmdlU3RydWN0dXJlcyhwYWNrci5nZXRTdHJ1Y3R1cmVzKCkpXG5cdFx0XHRcdGxldCBzaGFyZWRMZW5ndGggPSBzdHJ1Y3R1cmVzLnNoYXJlZExlbmd0aCB8fCAwXG5cdFx0XHRcdGlmIChzaGFyZWRMZW5ndGggPiBtYXhTaGFyZWRTdHJ1Y3R1cmVzKSB7XG5cdFx0XHRcdFx0Ly9pZiAobWF4U2hhcmVkU3RydWN0dXJlcyA8PSAzMiAmJiBzdHJ1Y3R1cmVzLnNoYXJlZExlbmd0aCA+IDMyKSAvLyBUT0RPOiBjb3VsZCBzdXBwb3J0IHRoaXMsIGJ1dCB3b3VsZCBuZWVkIHRvIHVwZGF0ZSB0aGUgbGltaXQgaWRzXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdTaGFyZWQgc3RydWN0dXJlcyBpcyBsYXJnZXIgdGhhbiBtYXhpbXVtIHNoYXJlZCBzdHJ1Y3R1cmVzLCB0cnkgaW5jcmVhc2luZyBtYXhTaGFyZWRTdHJ1Y3R1cmVzIHRvICcgKyBzdHJ1Y3R1cmVzLnNoYXJlZExlbmd0aClcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIXN0cnVjdHVyZXMudHJhbnNpdGlvbnMpIHtcblx0XHRcdFx0XHQvLyByZWJ1aWxkIG91ciBzdHJ1Y3R1cmUgdHJhbnNpdGlvbnNcblx0XHRcdFx0XHRzdHJ1Y3R1cmVzLnRyYW5zaXRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgc2hhcmVkTGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdGxldCBrZXlzID0gc3RydWN0dXJlc1tpXVxuXHRcdFx0XHRcdFx0aWYgKCFrZXlzKVxuXHRcdFx0XHRcdFx0XHRjb250aW51ZVxuXHRcdFx0XHRcdFx0bGV0IG5leHRUcmFuc2l0aW9uLCB0cmFuc2l0aW9uID0gc3RydWN0dXJlcy50cmFuc2l0aW9uc1xuXHRcdFx0XHRcdFx0Zm9yIChsZXQgaiA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaiA8IGw7IGorKykge1xuXHRcdFx0XHRcdFx0XHRsZXQga2V5ID0ga2V5c1tqXVxuXHRcdFx0XHRcdFx0XHRuZXh0VHJhbnNpdGlvbiA9IHRyYW5zaXRpb25ba2V5XVxuXHRcdFx0XHRcdFx0XHRpZiAoIW5leHRUcmFuc2l0aW9uKSB7XG5cdFx0XHRcdFx0XHRcdFx0bmV4dFRyYW5zaXRpb24gPSB0cmFuc2l0aW9uW2tleV0gPSBPYmplY3QuY3JlYXRlKG51bGwpXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0dHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0cmFuc2l0aW9uW1JFQ09SRF9TWU1CT0xdID0gaSArIDB4NDBcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5sYXN0TmFtZWRTdHJ1Y3R1cmVzTGVuZ3RoID0gc2hhcmVkTGVuZ3RoXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFpc1NlcXVlbnRpYWwpIHtcblx0XHRcdFx0XHRzdHJ1Y3R1cmVzLm5leHRJZCA9IHNoYXJlZExlbmd0aCArIDB4NDBcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGhhc1NoYXJlZFVwZGF0ZSlcblx0XHRcdFx0aGFzU2hhcmVkVXBkYXRlID0gZmFsc2Vcblx0XHRcdGxldCBlbmNvZGluZ0Vycm9yO1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0aWYgKHBhY2tyLnJhbmRvbUFjY2Vzc1N0cnVjdHVyZSAmJiB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KVxuXHRcdFx0XHRcdHdyaXRlU3RydWN0KHZhbHVlKTtcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdHBhY2sodmFsdWUpXG5cdFx0XHRcdGxldCBsYXN0QnVuZGxlID0gYnVuZGxlZFN0cmluZ3M7XG5cdFx0XHRcdGlmIChidW5kbGVkU3RyaW5ncylcblx0XHRcdFx0XHR3cml0ZUJ1bmRsZXMoc3RhcnQsIHBhY2ssIDApXG5cdFx0XHRcdGlmIChyZWZlcmVuY2VNYXAgJiYgcmVmZXJlbmNlTWFwLmlkc1RvSW5zZXJ0KSB7XG5cdFx0XHRcdFx0bGV0IGlkc1RvSW5zZXJ0ID0gcmVmZXJlbmNlTWFwLmlkc1RvSW5zZXJ0LnNvcnQoKGEsIGIpID0+IGEub2Zmc2V0ID4gYi5vZmZzZXQgPyAxIDogLTEpO1xuXHRcdFx0XHRcdGxldCBpID0gaWRzVG9JbnNlcnQubGVuZ3RoO1xuXHRcdFx0XHRcdGxldCBpbmNyZW1lbnRQb3NpdGlvbiA9IC0xO1xuXHRcdFx0XHRcdHdoaWxlIChsYXN0QnVuZGxlICYmIGkgPiAwKSB7XG5cdFx0XHRcdFx0XHRsZXQgaW5zZXJ0aW9uUG9pbnQgPSBpZHNUb0luc2VydFstLWldLm9mZnNldCArIHN0YXJ0O1xuXHRcdFx0XHRcdFx0aWYgKGluc2VydGlvblBvaW50IDwgKGxhc3RCdW5kbGUuc3RyaW5nc1Bvc2l0aW9uICsgc3RhcnQpICYmIGluY3JlbWVudFBvc2l0aW9uID09PSAtMSlcblx0XHRcdFx0XHRcdFx0aW5jcmVtZW50UG9zaXRpb24gPSAwO1xuXHRcdFx0XHRcdFx0aWYgKGluc2VydGlvblBvaW50ID4gKGxhc3RCdW5kbGUucG9zaXRpb24gKyBzdGFydCkpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGluY3JlbWVudFBvc2l0aW9uID49IDApXG5cdFx0XHRcdFx0XHRcdFx0aW5jcmVtZW50UG9zaXRpb24gKz0gNjtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGlmIChpbmNyZW1lbnRQb3NpdGlvbiA+PSAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gdXBkYXRlIHRoZSBidW5kbGUgcmVmZXJlbmNlIG5vd1xuXHRcdFx0XHRcdFx0XHRcdHRhcmdldFZpZXcuc2V0VWludDMyKGxhc3RCdW5kbGUucG9zaXRpb24gKyBzdGFydCxcblx0XHRcdFx0XHRcdFx0XHRcdHRhcmdldFZpZXcuZ2V0VWludDMyKGxhc3RCdW5kbGUucG9zaXRpb24gKyBzdGFydCkgKyBpbmNyZW1lbnRQb3NpdGlvbilcblx0XHRcdFx0XHRcdFx0XHRpbmNyZW1lbnRQb3NpdGlvbiA9IC0xOyAvLyByZXNldFxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGxhc3RCdW5kbGUgPSBsYXN0QnVuZGxlLnByZXZpb3VzO1xuXHRcdFx0XHRcdFx0XHRpKys7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChpbmNyZW1lbnRQb3NpdGlvbiA+PSAwICYmIGxhc3RCdW5kbGUpIHtcblx0XHRcdFx0XHRcdC8vIHVwZGF0ZSB0aGUgYnVuZGxlIHJlZmVyZW5jZSBub3dcblx0XHRcdFx0XHRcdHRhcmdldFZpZXcuc2V0VWludDMyKGxhc3RCdW5kbGUucG9zaXRpb24gKyBzdGFydCxcblx0XHRcdFx0XHRcdFx0dGFyZ2V0Vmlldy5nZXRVaW50MzIobGFzdEJ1bmRsZS5wb3NpdGlvbiArIHN0YXJ0KSArIGluY3JlbWVudFBvc2l0aW9uKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwb3NpdGlvbiArPSBpZHNUb0luc2VydC5sZW5ndGggKiA2O1xuXHRcdFx0XHRcdGlmIChwb3NpdGlvbiA+IHNhZmVFbmQpXG5cdFx0XHRcdFx0XHRtYWtlUm9vbShwb3NpdGlvbilcblx0XHRcdFx0XHRwYWNrci5vZmZzZXQgPSBwb3NpdGlvblxuXHRcdFx0XHRcdGxldCBzZXJpYWxpemVkID0gaW5zZXJ0SWRzKHRhcmdldC5zdWJhcnJheShzdGFydCwgcG9zaXRpb24pLCBpZHNUb0luc2VydClcblx0XHRcdFx0XHRyZWZlcmVuY2VNYXAgPSBudWxsXG5cdFx0XHRcdFx0cmV0dXJuIHNlcmlhbGl6ZWRcblx0XHRcdFx0fVxuXHRcdFx0XHRwYWNrci5vZmZzZXQgPSBwb3NpdGlvbiAvLyB1cGRhdGUgdGhlIG9mZnNldCBzbyBuZXh0IHNlcmlhbGl6YXRpb24gZG9lc24ndCB3cml0ZSBvdmVyIG91ciBidWZmZXIsIGJ1dCBjYW4gY29udGludWUgd3JpdGluZyB0byBzYW1lIGJ1ZmZlciBzZXF1ZW50aWFsbHlcblx0XHRcdFx0aWYgKGVuY29kZU9wdGlvbnMgJiBSRVVTRV9CVUZGRVJfTU9ERSkge1xuXHRcdFx0XHRcdHRhcmdldC5zdGFydCA9IHN0YXJ0XG5cdFx0XHRcdFx0dGFyZ2V0LmVuZCA9IHBvc2l0aW9uXG5cdFx0XHRcdFx0cmV0dXJuIHRhcmdldFxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0YXJnZXQuc3ViYXJyYXkoc3RhcnQsIHBvc2l0aW9uKSAvLyBwb3NpdGlvbiBjYW4gY2hhbmdlIGlmIHdlIGNhbGwgcGFjayBhZ2FpbiBpbiBzYXZlU3RydWN0dXJlcywgc28gd2UgZ2V0IHRoZSBidWZmZXIgbm93XG5cdFx0XHR9IGNhdGNoKGVycm9yKSB7XG5cdFx0XHRcdGVuY29kaW5nRXJyb3IgPSBlcnJvcjtcblx0XHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRpZiAoc3RydWN0dXJlcykge1xuXHRcdFx0XHRcdHJlc2V0U3RydWN0dXJlcygpO1xuXHRcdFx0XHRcdGlmIChoYXNTaGFyZWRVcGRhdGUgJiYgcGFja3Iuc2F2ZVN0cnVjdHVyZXMpIHtcblx0XHRcdFx0XHRcdGxldCBzaGFyZWRMZW5ndGggPSBzdHJ1Y3R1cmVzLnNoYXJlZExlbmd0aCB8fCAwXG5cdFx0XHRcdFx0XHQvLyB3ZSBjYW4ndCByZWx5IG9uIHN0YXJ0L2VuZCB3aXRoIFJFVVNFX0JVRkZFUl9NT0RFIHNpbmNlIHRoZXkgd2lsbCAocHJvYmFibHkpIGNoYW5nZSB3aGVuIHdlIHNhdmVcblx0XHRcdFx0XHRcdGxldCByZXR1cm5CdWZmZXIgPSB0YXJnZXQuc3ViYXJyYXkoc3RhcnQsIHBvc2l0aW9uKVxuXHRcdFx0XHRcdFx0bGV0IG5ld1NoYXJlZERhdGEgPSBwcmVwYXJlU3RydWN0dXJlcyhzdHJ1Y3R1cmVzLCBwYWNrcik7XG5cdFx0XHRcdFx0XHRpZiAoIWVuY29kaW5nRXJyb3IpIHsgLy8gVE9ETzogSWYgdGhlcmUgaXMgYW4gZW5jb2RpbmcgZXJyb3IsIHNob3VsZCBtYWtlIHRoZSBzdHJ1Y3R1cmVzIGFzIHVuaW5pdGlhbGl6ZWQgc28gdGhleSBnZXQgcmVidWlsdCBuZXh0IHRpbWVcblx0XHRcdFx0XHRcdFx0aWYgKHBhY2tyLnNhdmVTdHJ1Y3R1cmVzKG5ld1NoYXJlZERhdGEsIG5ld1NoYXJlZERhdGEuaXNDb21wYXRpYmxlKSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBnZXQgdXBkYXRlZCBzdHJ1Y3R1cmVzIGFuZCB0cnkgYWdhaW4gaWYgdGhlIHVwZGF0ZSBmYWlsZWRcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcGFja3IucGFjayh2YWx1ZSwgZW5jb2RlT3B0aW9ucylcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRwYWNrci5sYXN0TmFtZWRTdHJ1Y3R1cmVzTGVuZ3RoID0gc2hhcmVkTGVuZ3RoXG5cdFx0XHRcdFx0XHRcdC8vIGRvbid0IGtlZXAgbGFyZ2UgYnVmZmVycyBhcm91bmRcblx0XHRcdFx0XHRcdFx0aWYgKHRhcmdldC5sZW5ndGggPiAweDQwMDAwMDAwKSB0YXJnZXQgPSBudWxsXG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXR1cm5CdWZmZXJcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gZG9uJ3Qga2VlcCBsYXJnZSBidWZmZXJzIGFyb3VuZCwgdGhleSB0YWtlIHRvbyBtdWNoIG1lbW9yeSBhbmQgY2F1c2UgcHJvYmxlbXMgKGxpbWl0IGF0IDFHQilcblx0XHRcdFx0aWYgKHRhcmdldC5sZW5ndGggPiAweDQwMDAwMDAwKSB0YXJnZXQgPSBudWxsXG5cdFx0XHRcdGlmIChlbmNvZGVPcHRpb25zICYgUkVTRVRfQlVGRkVSX01PREUpXG5cdFx0XHRcdFx0cG9zaXRpb24gPSBzdGFydFxuXHRcdFx0fVxuXHRcdH1cblx0XHRjb25zdCByZXNldFN0cnVjdHVyZXMgPSAoKSA9PiB7XG5cdFx0XHRpZiAoc2VyaWFsaXphdGlvbnNTaW5jZVRyYW5zaXRpb25SZWJ1aWxkIDwgMTApXG5cdFx0XHRcdHNlcmlhbGl6YXRpb25zU2luY2VUcmFuc2l0aW9uUmVidWlsZCsrXG5cdFx0XHRsZXQgc2hhcmVkTGVuZ3RoID0gc3RydWN0dXJlcy5zaGFyZWRMZW5ndGggfHwgMFxuXHRcdFx0aWYgKHN0cnVjdHVyZXMubGVuZ3RoID4gc2hhcmVkTGVuZ3RoICYmICFpc1NlcXVlbnRpYWwpXG5cdFx0XHRcdHN0cnVjdHVyZXMubGVuZ3RoID0gc2hhcmVkTGVuZ3RoXG5cdFx0XHRpZiAodHJhbnNpdGlvbnNDb3VudCA+IDEwMDAwKSB7XG5cdFx0XHRcdC8vIGZvcmNlIGEgcmVidWlsZCBvY2Nhc2lvbmFsbHkgYWZ0ZXIgYSBsb3Qgb2YgdHJhbnNpdGlvbnMgc28gaXQgY2FuIGdldCBjbGVhbmVkIHVwXG5cdFx0XHRcdHN0cnVjdHVyZXMudHJhbnNpdGlvbnMgPSBudWxsXG5cdFx0XHRcdHNlcmlhbGl6YXRpb25zU2luY2VUcmFuc2l0aW9uUmVidWlsZCA9IDBcblx0XHRcdFx0dHJhbnNpdGlvbnNDb3VudCA9IDBcblx0XHRcdFx0aWYgKHJlY29yZElkc1RvUmVtb3ZlLmxlbmd0aCA+IDApXG5cdFx0XHRcdFx0cmVjb3JkSWRzVG9SZW1vdmUgPSBbXVxuXHRcdFx0fSBlbHNlIGlmIChyZWNvcmRJZHNUb1JlbW92ZS5sZW5ndGggPiAwICYmICFpc1NlcXVlbnRpYWwpIHtcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSByZWNvcmRJZHNUb1JlbW92ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRyZWNvcmRJZHNUb1JlbW92ZVtpXVtSRUNPUkRfU1lNQk9MXSA9IDBcblx0XHRcdFx0fVxuXHRcdFx0XHRyZWNvcmRJZHNUb1JlbW92ZSA9IFtdXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNvbnN0IHBhY2tBcnJheSA9ICh2YWx1ZSkgPT4ge1xuXHRcdFx0dmFyIGxlbmd0aCA9IHZhbHVlLmxlbmd0aFxuXHRcdFx0aWYgKGxlbmd0aCA8IDB4MTApIHtcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHg5MCB8IGxlbmd0aFxuXHRcdFx0fSBlbHNlIGlmIChsZW5ndGggPCAweDEwMDAwKSB7XG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZGNcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoID4+IDhcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoICYgMHhmZlxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkZFxuXHRcdFx0XHR0YXJnZXRWaWV3LnNldFVpbnQzMihwb3NpdGlvbiwgbGVuZ3RoKVxuXHRcdFx0XHRwb3NpdGlvbiArPSA0XG5cdFx0XHR9XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHBhY2sodmFsdWVbaV0pXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNvbnN0IHBhY2sgPSAodmFsdWUpID0+IHtcblx0XHRcdGlmIChwb3NpdGlvbiA+IHNhZmVFbmQpXG5cdFx0XHRcdHRhcmdldCA9IG1ha2VSb29tKHBvc2l0aW9uKVxuXG5cdFx0XHR2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZVxuXHRcdFx0dmFyIGxlbmd0aFxuXHRcdFx0aWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdGxldCBzdHJMZW5ndGggPSB2YWx1ZS5sZW5ndGhcblx0XHRcdFx0aWYgKGJ1bmRsZWRTdHJpbmdzICYmIHN0ckxlbmd0aCA+PSA0ICYmIHN0ckxlbmd0aCA8IDB4MTAwMCkge1xuXHRcdFx0XHRcdGlmICgoYnVuZGxlZFN0cmluZ3Muc2l6ZSArPSBzdHJMZW5ndGgpID4gTUFYX0JVTkRMRV9TSVpFKSB7XG5cdFx0XHRcdFx0XHRsZXQgZXh0U3RhcnRcblx0XHRcdFx0XHRcdGxldCBtYXhCeXRlcyA9IChidW5kbGVkU3RyaW5nc1swXSA/IGJ1bmRsZWRTdHJpbmdzWzBdLmxlbmd0aCAqIDMgKyBidW5kbGVkU3RyaW5nc1sxXS5sZW5ndGggOiAwKSArIDEwXG5cdFx0XHRcdFx0XHRpZiAocG9zaXRpb24gKyBtYXhCeXRlcyA+IHNhZmVFbmQpXG5cdFx0XHRcdFx0XHRcdHRhcmdldCA9IG1ha2VSb29tKHBvc2l0aW9uICsgbWF4Qnl0ZXMpXG5cdFx0XHRcdFx0XHRsZXQgbGFzdEJ1bmRsZVxuXHRcdFx0XHRcdFx0aWYgKGJ1bmRsZWRTdHJpbmdzLnBvc2l0aW9uKSB7IC8vIGhlcmUgd2UgdXNlIHRoZSAweDYyIGV4dGVuc2lvbiB0byB3cml0ZSB0aGUgbGFzdCBidW5kbGUgYW5kIHJlc2VydmUgc3BhY2UgZm9yIHRoZSByZWZlcmVuY2UgcG9pbnRlciB0byB0aGUgbmV4dC9jdXJyZW50IGJ1bmRsZVxuXHRcdFx0XHRcdFx0XHRsYXN0QnVuZGxlID0gYnVuZGxlZFN0cmluZ3Ncblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uXSA9IDB4YzggLy8gZXh0IDE2XG5cdFx0XHRcdFx0XHRcdHBvc2l0aW9uICs9IDMgLy8gcmVzZXJ2ZSBmb3IgdGhlIHdyaXRpbmcgYnVuZGxlIHNpemVcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHg2MiAvLyAnYidcblx0XHRcdFx0XHRcdFx0ZXh0U3RhcnQgPSBwb3NpdGlvbiAtIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdHBvc2l0aW9uICs9IDQgLy8gcmVzZXJ2ZSBmb3Igd3JpdGluZyBidW5kbGUgcmVmZXJlbmNlXG5cdFx0XHRcdFx0XHRcdHdyaXRlQnVuZGxlcyhzdGFydCwgcGFjaywgMCkgLy8gd3JpdGUgdGhlIGxhc3QgYnVuZGxlc1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRWaWV3LnNldFVpbnQxNihleHRTdGFydCArIHN0YXJ0IC0gMywgcG9zaXRpb24gLSBzdGFydCAtIGV4dFN0YXJ0KVxuXHRcdFx0XHRcdFx0fSBlbHNlIHsgLy8gaGVyZSB3ZSB1c2UgdGhlIDB4NjIgZXh0ZW5zaW9uIGp1c3QgdG8gcmVzZXJ2ZSB0aGUgc3BhY2UgZm9yIHRoZSByZWZlcmVuY2UgcG9pbnRlciB0byB0aGUgYnVuZGxlICh3aWxsIGJlIHVwZGF0ZWQgb25jZSB0aGUgYnVuZGxlIGlzIHdyaXR0ZW4pXG5cdFx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDYgLy8gZml4ZXh0IDRcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHg2MiAvLyAnYidcblx0XHRcdFx0XHRcdFx0ZXh0U3RhcnQgPSBwb3NpdGlvbiAtIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdHBvc2l0aW9uICs9IDQgLy8gcmVzZXJ2ZSBmb3Igd3JpdGluZyBidW5kbGUgcmVmZXJlbmNlXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRidW5kbGVkU3RyaW5ncyA9IFsnJywgJyddIC8vIGNyZWF0ZSBuZXcgb25lc1xuXHRcdFx0XHRcdFx0YnVuZGxlZFN0cmluZ3MucHJldmlvdXMgPSBsYXN0QnVuZGxlO1xuXHRcdFx0XHRcdFx0YnVuZGxlZFN0cmluZ3Muc2l6ZSA9IDBcblx0XHRcdFx0XHRcdGJ1bmRsZWRTdHJpbmdzLnBvc2l0aW9uID0gZXh0U3RhcnRcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bGV0IHR3b0J5dGUgPSBoYXNOb25MYXRpbi50ZXN0KHZhbHVlKVxuXHRcdFx0XHRcdGJ1bmRsZWRTdHJpbmdzW3R3b0J5dGUgPyAwIDogMV0gKz0gdmFsdWVcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGMxXG5cdFx0XHRcdFx0cGFjayh0d29CeXRlID8gLXN0ckxlbmd0aCA6IHN0ckxlbmd0aCk7XG5cdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdH1cblx0XHRcdFx0bGV0IGhlYWRlclNpemVcblx0XHRcdFx0Ly8gZmlyc3Qgd2UgZXN0aW1hdGUgdGhlIGhlYWRlciBzaXplLCBzbyB3ZSBjYW4gd3JpdGUgdG8gdGhlIGNvcnJlY3QgbG9jYXRpb25cblx0XHRcdFx0aWYgKHN0ckxlbmd0aCA8IDB4MjApIHtcblx0XHRcdFx0XHRoZWFkZXJTaXplID0gMVxuXHRcdFx0XHR9IGVsc2UgaWYgKHN0ckxlbmd0aCA8IDB4MTAwKSB7XG5cdFx0XHRcdFx0aGVhZGVyU2l6ZSA9IDJcblx0XHRcdFx0fSBlbHNlIGlmIChzdHJMZW5ndGggPCAweDEwMDAwKSB7XG5cdFx0XHRcdFx0aGVhZGVyU2l6ZSA9IDNcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRoZWFkZXJTaXplID0gNVxuXHRcdFx0XHR9XG5cdFx0XHRcdGxldCBtYXhCeXRlcyA9IHN0ckxlbmd0aCAqIDNcblx0XHRcdFx0aWYgKHBvc2l0aW9uICsgbWF4Qnl0ZXMgPiBzYWZlRW5kKVxuXHRcdFx0XHRcdHRhcmdldCA9IG1ha2VSb29tKHBvc2l0aW9uICsgbWF4Qnl0ZXMpXG5cblx0XHRcdFx0aWYgKHN0ckxlbmd0aCA8IDB4NDAgfHwgIWVuY29kZVV0ZjgpIHtcblx0XHRcdFx0XHRsZXQgaSwgYzEsIGMyLCBzdHJQb3NpdGlvbiA9IHBvc2l0aW9uICsgaGVhZGVyU2l6ZVxuXHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBzdHJMZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0YzEgPSB2YWx1ZS5jaGFyQ29kZUF0KGkpXG5cdFx0XHRcdFx0XHRpZiAoYzEgPCAweDgwKSB7XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtzdHJQb3NpdGlvbisrXSA9IGMxXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGMxIDwgMHg4MDApIHtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3N0clBvc2l0aW9uKytdID0gYzEgPj4gNiB8IDB4YzBcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3N0clBvc2l0aW9uKytdID0gYzEgJiAweDNmIHwgMHg4MFxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChcblx0XHRcdFx0XHRcdFx0KGMxICYgMHhmYzAwKSA9PT0gMHhkODAwICYmXG5cdFx0XHRcdFx0XHRcdCgoYzIgPSB2YWx1ZS5jaGFyQ29kZUF0KGkgKyAxKSkgJiAweGZjMDApID09PSAweGRjMDBcblx0XHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0XHRjMSA9IDB4MTAwMDAgKyAoKGMxICYgMHgwM2ZmKSA8PCAxMCkgKyAoYzIgJiAweDAzZmYpXG5cdFx0XHRcdFx0XHRcdGkrK1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRbc3RyUG9zaXRpb24rK10gPSBjMSA+PiAxOCB8IDB4ZjBcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3N0clBvc2l0aW9uKytdID0gYzEgPj4gMTIgJiAweDNmIHwgMHg4MFxuXHRcdFx0XHRcdFx0XHR0YXJnZXRbc3RyUG9zaXRpb24rK10gPSBjMSA+PiA2ICYgMHgzZiB8IDB4ODBcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3N0clBvc2l0aW9uKytdID0gYzEgJiAweDNmIHwgMHg4MFxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3N0clBvc2l0aW9uKytdID0gYzEgPj4gMTIgfCAweGUwXG5cdFx0XHRcdFx0XHRcdHRhcmdldFtzdHJQb3NpdGlvbisrXSA9IGMxID4+IDYgJiAweDNmIHwgMHg4MFxuXHRcdFx0XHRcdFx0XHR0YXJnZXRbc3RyUG9zaXRpb24rK10gPSBjMSAmIDB4M2YgfCAweDgwXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGxlbmd0aCA9IHN0clBvc2l0aW9uIC0gcG9zaXRpb24gLSBoZWFkZXJTaXplXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bGVuZ3RoID0gZW5jb2RlVXRmOCh2YWx1ZSwgcG9zaXRpb24gKyBoZWFkZXJTaXplKVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGxlbmd0aCA8IDB4MjApIHtcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGEwIHwgbGVuZ3RoXG5cdFx0XHRcdH0gZWxzZSBpZiAobGVuZ3RoIDwgMHgxMDApIHtcblx0XHRcdFx0XHRpZiAoaGVhZGVyU2l6ZSA8IDIpIHtcblx0XHRcdFx0XHRcdHRhcmdldC5jb3B5V2l0aGluKHBvc2l0aW9uICsgMiwgcG9zaXRpb24gKyAxLCBwb3NpdGlvbiArIDEgKyBsZW5ndGgpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDlcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSBsZW5ndGhcblx0XHRcdFx0fSBlbHNlIGlmIChsZW5ndGggPCAweDEwMDAwKSB7XG5cdFx0XHRcdFx0aWYgKGhlYWRlclNpemUgPCAzKSB7XG5cdFx0XHRcdFx0XHR0YXJnZXQuY29weVdpdGhpbihwb3NpdGlvbiArIDMsIHBvc2l0aW9uICsgMiwgcG9zaXRpb24gKyAyICsgbGVuZ3RoKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGRhXG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoID4+IDhcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSBsZW5ndGggJiAweGZmXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKGhlYWRlclNpemUgPCA1KSB7XG5cdFx0XHRcdFx0XHR0YXJnZXQuY29weVdpdGhpbihwb3NpdGlvbiArIDUsIHBvc2l0aW9uICsgMywgcG9zaXRpb24gKyAzICsgbGVuZ3RoKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGRiXG5cdFx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRVaW50MzIocG9zaXRpb24sIGxlbmd0aClcblx0XHRcdFx0XHRwb3NpdGlvbiArPSA0XG5cdFx0XHRcdH1cblx0XHRcdFx0cG9zaXRpb24gKz0gbGVuZ3RoXG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdGlmICh2YWx1ZSA+Pj4gMCA9PT0gdmFsdWUpIHsvLyBwb3NpdGl2ZSBpbnRlZ2VyLCAzMi1iaXQgb3IgbGVzc1xuXHRcdFx0XHRcdC8vIHBvc2l0aXZlIHVpbnRcblx0XHRcdFx0XHRpZiAodmFsdWUgPCAweDIwIHx8ICh2YWx1ZSA8IDB4ODAgJiYgdGhpcy51c2VSZWNvcmRzID09PSBmYWxzZSkgfHwgKHZhbHVlIDwgMHg0MCAmJiAhdGhpcy5yYW5kb21BY2Nlc3NTdHJ1Y3R1cmUpKSB7XG5cdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSB2YWx1ZVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAodmFsdWUgPCAweDEwMCkge1xuXHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhjY1xuXHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gdmFsdWVcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHZhbHVlIDwgMHgxMDAwMCkge1xuXHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhjZFxuXHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gdmFsdWUgPj4gOFxuXHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gdmFsdWUgJiAweGZmXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4Y2Vcblx0XHRcdFx0XHRcdHRhcmdldFZpZXcuc2V0VWludDMyKHBvc2l0aW9uLCB2YWx1ZSlcblx0XHRcdFx0XHRcdHBvc2l0aW9uICs9IDRcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAodmFsdWUgPj4gMCA9PT0gdmFsdWUpIHsgLy8gbmVnYXRpdmUgaW50ZWdlclxuXHRcdFx0XHRcdGlmICh2YWx1ZSA+PSAtMHgyMCkge1xuXHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHgxMDAgKyB2YWx1ZVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAodmFsdWUgPj0gLTB4ODApIHtcblx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDBcblx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IHZhbHVlICsgMHgxMDBcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHZhbHVlID49IC0weDgwMDApIHtcblx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDFcblx0XHRcdFx0XHRcdHRhcmdldFZpZXcuc2V0SW50MTYocG9zaXRpb24sIHZhbHVlKVxuXHRcdFx0XHRcdFx0cG9zaXRpb24gKz0gMlxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQyXG5cdFx0XHRcdFx0XHR0YXJnZXRWaWV3LnNldEludDMyKHBvc2l0aW9uLCB2YWx1ZSlcblx0XHRcdFx0XHRcdHBvc2l0aW9uICs9IDRcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bGV0IHVzZUZsb2F0MzJcblx0XHRcdFx0XHRpZiAoKHVzZUZsb2F0MzIgPSB0aGlzLnVzZUZsb2F0MzIpID4gMCAmJiB2YWx1ZSA8IDB4MTAwMDAwMDAwICYmIHZhbHVlID49IC0weDgwMDAwMDAwKSB7XG5cdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGNhXG5cdFx0XHRcdFx0XHR0YXJnZXRWaWV3LnNldEZsb2F0MzIocG9zaXRpb24sIHZhbHVlKVxuXHRcdFx0XHRcdFx0bGV0IHhTaGlmdGVkXG5cdFx0XHRcdFx0XHRpZiAodXNlRmxvYXQzMiA8IDQgfHxcblx0XHRcdFx0XHRcdFx0XHQvLyB0aGlzIGNoZWNrcyBmb3Igcm91bmRpbmcgb2YgbnVtYmVycyB0aGF0IHdlcmUgZW5jb2RlZCBpbiAzMi1iaXQgZmxvYXQgdG8gbmVhcmVzdCBzaWduaWZpY2FudCBkZWNpbWFsIGRpZ2l0IHRoYXQgY291bGQgYmUgcHJlc2VydmVkXG5cdFx0XHRcdFx0XHRcdFx0KCh4U2hpZnRlZCA9IHZhbHVlICogbXVsdDEwWygodGFyZ2V0W3Bvc2l0aW9uXSAmIDB4N2YpIDw8IDEpIHwgKHRhcmdldFtwb3NpdGlvbiArIDFdID4+IDcpXSkgPj4gMCkgPT09IHhTaGlmdGVkKSB7XG5cdFx0XHRcdFx0XHRcdHBvc2l0aW9uICs9IDRcblx0XHRcdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdFx0XHR9IGVsc2Vcblx0XHRcdFx0XHRcdFx0cG9zaXRpb24tLSAvLyBtb3ZlIGJhY2sgaW50byBwb3NpdGlvbiBmb3Igd3JpdGluZyBhIGRvdWJsZVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGNiXG5cdFx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRGbG9hdDY0KHBvc2l0aW9uLCB2YWx1ZSlcblx0XHRcdFx0XHRwb3NpdGlvbiArPSA4XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRpZiAoIXZhbHVlKVxuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4YzBcblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0aWYgKHJlZmVyZW5jZU1hcCkge1xuXHRcdFx0XHRcdFx0bGV0IHJlZmVyZWUgPSByZWZlcmVuY2VNYXAuZ2V0KHZhbHVlKVxuXHRcdFx0XHRcdFx0aWYgKHJlZmVyZWUpIHtcblx0XHRcdFx0XHRcdFx0aWYgKCFyZWZlcmVlLmlkKSB7XG5cdFx0XHRcdFx0XHRcdFx0bGV0IGlkc1RvSW5zZXJ0ID0gcmVmZXJlbmNlTWFwLmlkc1RvSW5zZXJ0IHx8IChyZWZlcmVuY2VNYXAuaWRzVG9JbnNlcnQgPSBbXSlcblx0XHRcdFx0XHRcdFx0XHRyZWZlcmVlLmlkID0gaWRzVG9JbnNlcnQucHVzaChyZWZlcmVlKVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDYgLy8gZml4ZXh0IDRcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHg3MCAvLyBcInBcIiBmb3IgcG9pbnRlclxuXHRcdFx0XHRcdFx0XHR0YXJnZXRWaWV3LnNldFVpbnQzMihwb3NpdGlvbiwgcmVmZXJlZS5pZClcblx0XHRcdFx0XHRcdFx0cG9zaXRpb24gKz0gNFxuXHRcdFx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0XHRcdH0gZWxzZVxuXHRcdFx0XHRcdFx0XHRyZWZlcmVuY2VNYXAuc2V0KHZhbHVlLCB7IG9mZnNldDogcG9zaXRpb24gLSBzdGFydCB9KVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRsZXQgY29uc3RydWN0b3IgPSB2YWx1ZS5jb25zdHJ1Y3RvclxuXHRcdFx0XHRcdGlmIChjb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG5cdFx0XHRcdFx0XHR3cml0ZU9iamVjdCh2YWx1ZSlcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGNvbnN0cnVjdG9yID09PSBBcnJheSkge1xuXHRcdFx0XHRcdFx0cGFja0FycmF5KHZhbHVlKVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoY29uc3RydWN0b3IgPT09IE1hcCkge1xuXHRcdFx0XHRcdFx0aWYgKHRoaXMubWFwQXNFbXB0eU9iamVjdCkgdGFyZ2V0W3Bvc2l0aW9uKytdID0gMHg4MFxuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGxlbmd0aCA9IHZhbHVlLnNpemVcblx0XHRcdFx0XHRcdFx0aWYgKGxlbmd0aCA8IDB4MTApIHtcblx0XHRcdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweDgwIHwgbGVuZ3RoXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAobGVuZ3RoIDwgMHgxMDAwMCkge1xuXHRcdFx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZGVcblx0XHRcdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSBsZW5ndGggPj4gOFxuXHRcdFx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGxlbmd0aCAmIDB4ZmZcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGRmXG5cdFx0XHRcdFx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRVaW50MzIocG9zaXRpb24sIGxlbmd0aClcblx0XHRcdFx0XHRcdFx0XHRwb3NpdGlvbiArPSA0XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0Zm9yIChsZXQgW2tleSwgZW50cnlWYWx1ZV0gb2YgdmFsdWUpIHtcblx0XHRcdFx0XHRcdFx0XHRwYWNrKGtleSlcblx0XHRcdFx0XHRcdFx0XHRwYWNrKGVudHJ5VmFsdWUpXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBleHRlbnNpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRsZXQgZXh0ZW5zaW9uQ2xhc3MgPSBleHRlbnNpb25DbGFzc2VzW2ldXG5cdFx0XHRcdFx0XHRcdGlmICh2YWx1ZSBpbnN0YW5jZW9mIGV4dGVuc2lvbkNsYXNzKSB7XG5cdFx0XHRcdFx0XHRcdFx0bGV0IGV4dGVuc2lvbiA9IGV4dGVuc2lvbnNbaV1cblx0XHRcdFx0XHRcdFx0XHRpZiAoZXh0ZW5zaW9uLndyaXRlKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoZXh0ZW5zaW9uLnR5cGUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkNCAvLyBvbmUgYnl0ZSBcInRhZ1wiIGV4dGVuc2lvblxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSBleHRlbnNpb24udHlwZVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAwXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRsZXQgd3JpdGVSZXN1bHQgPSBleHRlbnNpb24ud3JpdGUuY2FsbCh0aGlzLCB2YWx1ZSlcblx0XHRcdFx0XHRcdFx0XHRcdGlmICh3cml0ZVJlc3VsdCA9PT0gdmFsdWUpIHsgLy8gYXZvaWQgaW5maW5pdGUgcmVjdXJzaW9uXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBhY2tBcnJheSh2YWx1ZSlcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR3cml0ZU9iamVjdCh2YWx1ZSlcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cGFjayh3cml0ZVJlc3VsdClcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRsZXQgY3VycmVudFRhcmdldCA9IHRhcmdldFxuXHRcdFx0XHRcdFx0XHRcdGxldCBjdXJyZW50VGFyZ2V0VmlldyA9IHRhcmdldFZpZXdcblx0XHRcdFx0XHRcdFx0XHRsZXQgY3VycmVudFBvc2l0aW9uID0gcG9zaXRpb25cblx0XHRcdFx0XHRcdFx0XHR0YXJnZXQgPSBudWxsXG5cdFx0XHRcdFx0XHRcdFx0bGV0IHJlc3VsdFxuXHRcdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXN1bHQgPSBleHRlbnNpb24ucGFjay5jYWxsKHRoaXMsIHZhbHVlLCAoc2l6ZSkgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyByZXN0b3JlIHRhcmdldCBhbmQgdXNlIGl0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRhcmdldCA9IGN1cnJlbnRUYXJnZXRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudFRhcmdldCA9IG51bGxcblx0XHRcdFx0XHRcdFx0XHRcdFx0cG9zaXRpb24gKz0gc2l6ZVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAocG9zaXRpb24gPiBzYWZlRW5kKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1ha2VSb29tKHBvc2l0aW9uKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRhcmdldCwgdGFyZ2V0VmlldywgcG9zaXRpb246IHBvc2l0aW9uIC0gc2l6ZVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LCBwYWNrKVxuXHRcdFx0XHRcdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyByZXN0b3JlIGN1cnJlbnQgdGFyZ2V0IGluZm9ybWF0aW9uICh1bmxlc3MgYWxyZWFkeSByZXN0b3JlZClcblx0XHRcdFx0XHRcdFx0XHRcdGlmIChjdXJyZW50VGFyZ2V0KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRhcmdldCA9IGN1cnJlbnRUYXJnZXRcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0VmlldyA9IGN1cnJlbnRUYXJnZXRWaWV3XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBvc2l0aW9uID0gY3VycmVudFBvc2l0aW9uXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHNhZmVFbmQgPSB0YXJnZXQubGVuZ3RoIC0gMTBcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHJlc3VsdCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKHJlc3VsdC5sZW5ndGggKyBwb3NpdGlvbiA+IHNhZmVFbmQpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG1ha2VSb29tKHJlc3VsdC5sZW5ndGggKyBwb3NpdGlvbilcblx0XHRcdFx0XHRcdFx0XHRcdHBvc2l0aW9uID0gd3JpdGVFeHRlbnNpb25EYXRhKHJlc3VsdCwgdGFyZ2V0LCBwb3NpdGlvbiwgZXh0ZW5zaW9uLnR5cGUpXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvLyBjaGVjayBpc0FycmF5IGFmdGVyIGV4dGVuc2lvbnMsIGJlY2F1c2UgZXh0ZW5zaW9ucyBjYW4gZXh0ZW5kIEFycmF5XG5cdFx0XHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRcdFx0XHRcdFx0cGFja0FycmF5KHZhbHVlKVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gdXNlIHRoaXMgYXMgYW4gYWx0ZXJuYXRlIG1lY2hhbmlzbSBmb3IgZXhwcmVzc2luZyBob3cgdG8gc2VyaWFsaXplXG5cdFx0XHRcdFx0XHRcdGlmICh2YWx1ZS50b0pTT04pIHtcblx0XHRcdFx0XHRcdFx0XHRjb25zdCBqc29uID0gdmFsdWUudG9KU09OKClcblx0XHRcdFx0XHRcdFx0XHQvLyBpZiBmb3Igc29tZSByZWFzb24gdmFsdWUudG9KU09OIHJldHVybnMgaXRzZWxmIGl0J2xsIGxvb3AgZm9yZXZlclxuXHRcdFx0XHRcdFx0XHRcdGlmIChqc29uICE9PSB2YWx1ZSlcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBwYWNrKGpzb24pXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvLyBpZiB0aGVyZSBpcyBhIHdyaXRlRnVuY3Rpb24sIHVzZSBpdCwgb3RoZXJ3aXNlIGp1c3QgZW5jb2RlIGFzIHVuZGVmaW5lZFxuXHRcdFx0XHRcdFx0XHRpZiAodHlwZSA9PT0gJ2Z1bmN0aW9uJylcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcGFjayh0aGlzLndyaXRlRnVuY3Rpb24gJiYgdGhpcy53cml0ZUZ1bmN0aW9uKHZhbHVlKSk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gbm8gZXh0ZW5zaW9uIGZvdW5kLCB3cml0ZSBhcyBwbGFpbiBvYmplY3Rcblx0XHRcdFx0XHRcdFx0d3JpdGVPYmplY3QodmFsdWUpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICdib29sZWFuJykge1xuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSB2YWx1ZSA/IDB4YzMgOiAweGMyXG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICdiaWdpbnQnKSB7XG5cdFx0XHRcdGlmICh2YWx1ZSA8IDB4ODAwMDAwMDAwMDAwMDAwMCAmJiB2YWx1ZSA+PSAtMHg4MDAwMDAwMDAwMDAwMDAwKSB7XG5cdFx0XHRcdFx0Ly8gdXNlIGEgc2lnbmVkIGludCBhcyBsb25nIGFzIGl0IGZpdHNcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQzXG5cdFx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRCaWdJbnQ2NChwb3NpdGlvbiwgdmFsdWUpXG5cdFx0XHRcdH0gZWxzZSBpZiAodmFsdWUgPCAweDEwMDAwMDAwMDAwMDAwMDAwICYmIHZhbHVlID4gMCkge1xuXHRcdFx0XHRcdC8vIGlmIHdlIGNhbiBmaXQgYW4gdW5zaWduZWQgaW50LCB1c2UgdGhhdFxuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4Y2Zcblx0XHRcdFx0XHR0YXJnZXRWaWV3LnNldEJpZ1VpbnQ2NChwb3NpdGlvbiwgdmFsdWUpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gb3ZlcmZsb3dcblx0XHRcdFx0XHRpZiAodGhpcy5sYXJnZUJpZ0ludFRvRmxvYXQpIHtcblx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4Y2Jcblx0XHRcdFx0XHRcdHRhcmdldFZpZXcuc2V0RmxvYXQ2NChwb3NpdGlvbiwgTnVtYmVyKHZhbHVlKSlcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMubGFyZ2VCaWdJbnRUb1N0cmluZykge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHBhY2sodmFsdWUudG9TdHJpbmcoKSk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLnVzZUJpZ0ludEV4dGVuc2lvbiB8fCB0aGlzLm1vcmVUeXBlcykge1xuXHRcdFx0XHRcdFx0bGV0IGVtcHR5ID0gdmFsdWUgPCAwID8gQmlnSW50KC0xKSA6IEJpZ0ludCgwKVxuXG5cdFx0XHRcdFx0XHRsZXQgYXJyYXlcblx0XHRcdFx0XHRcdGlmICh2YWx1ZSA+PiBCaWdJbnQoMHgxMDAwMCkgPT09IGVtcHR5KSB7XG5cdFx0XHRcdFx0XHRcdGxldCBtYXNrID0gQmlnSW50KDB4MTAwMDAwMDAwMDAwMDAwMDApIC0gQmlnSW50KDEpIC8vIGxpdGVyYWwgd291bGQgb3ZlcmZsb3dcblx0XHRcdFx0XHRcdFx0bGV0IGNodW5rcyA9IFtdXG5cdFx0XHRcdFx0XHRcdHdoaWxlICh0cnVlKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2h1bmtzLnB1c2godmFsdWUgJiBtYXNrKVxuXHRcdFx0XHRcdFx0XHRcdGlmICgodmFsdWUgPj4gQmlnSW50KDYzKSkgPT09IGVtcHR5KSBicmVha1xuXHRcdFx0XHRcdFx0XHRcdHZhbHVlID4+PSBCaWdJbnQoNjQpXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRhcnJheSA9IG5ldyBVaW50OEFycmF5KG5ldyBCaWdVaW50NjRBcnJheShjaHVua3MpLmJ1ZmZlcilcblx0XHRcdFx0XHRcdFx0YXJyYXkucmV2ZXJzZSgpXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRsZXQgaW52ZXJ0ID0gdmFsdWUgPCAwXG5cdFx0XHRcdFx0XHRcdGxldCBzdHJpbmcgPSAoaW52ZXJ0ID8gfnZhbHVlIDogdmFsdWUpLnRvU3RyaW5nKDE2KVxuXHRcdFx0XHRcdFx0XHRpZiAoc3RyaW5nLmxlbmd0aCAlIDIpIHtcblx0XHRcdFx0XHRcdFx0XHRzdHJpbmcgPSAnMCcgKyBzdHJpbmdcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChwYXJzZUludChzdHJpbmcuY2hhckF0KDApLCAxNikgPj0gOCkge1xuXHRcdFx0XHRcdFx0XHRcdHN0cmluZyA9ICcwMCcgKyBzdHJpbmdcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGlmIChoYXNOb2RlQnVmZmVyKSB7XG5cdFx0XHRcdFx0XHRcdFx0YXJyYXkgPSBCdWZmZXIuZnJvbShzdHJpbmcsICdoZXgnKVxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoc3RyaW5nLmxlbmd0aCAvIDIpXG5cdFx0XHRcdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdFx0YXJyYXlbaV0gPSBwYXJzZUludChzdHJpbmcuc2xpY2UoaSAqIDIsIGkgKiAyICsgMiksIDE2KVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGlmIChpbnZlcnQpIHtcblx0XHRcdFx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSBhcnJheVtpXSA9IH5hcnJheVtpXVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmIChhcnJheS5sZW5ndGggKyBwb3NpdGlvbiA+IHNhZmVFbmQpXG5cdFx0XHRcdFx0XHRcdG1ha2VSb29tKGFycmF5Lmxlbmd0aCArIHBvc2l0aW9uKVxuXHRcdFx0XHRcdFx0cG9zaXRpb24gPSB3cml0ZUV4dGVuc2lvbkRhdGEoYXJyYXksIHRhcmdldCwgcG9zaXRpb24sIDB4NDIpXG5cdFx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IodmFsdWUgKyAnIHdhcyB0b28gbGFyZ2UgdG8gZml0IGluIE1lc3NhZ2VQYWNrIDY0LWJpdCBpbnRlZ2VyIGZvcm1hdCwgdXNlJyArXG5cdFx0XHRcdFx0XHRcdCcgdXNlQmlnSW50RXh0ZW5zaW9uLCBvciBzZXQgbGFyZ2VCaWdJbnRUb0Zsb2F0IHRvIGNvbnZlcnQgdG8gZmxvYXQtNjQsIG9yIHNldCcgK1xuXHRcdFx0XHRcdFx0XHQnIGxhcmdlQmlnSW50VG9TdHJpbmcgdG8gY29udmVydCB0byBzdHJpbmcnKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRwb3NpdGlvbiArPSA4XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdGlmICh0aGlzLmVuY29kZVVuZGVmaW5lZEFzTmlsKVxuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4YzBcblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkNCAvLyBhIG51bWJlciBvZiBpbXBsZW1lbnRhdGlvbnMgdXNlIGZpeGV4dDEgd2l0aCB0eXBlIDAsIGRhdGEgMCB0byBkZW5vdGUgdW5kZWZpbmVkLCBzbyB3ZSBmb2xsb3cgc3VpdGVcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAwXG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMFxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdHlwZTogJyArIHR5cGUpXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y29uc3Qgd3JpdGVQbGFpbk9iamVjdCA9ICh0aGlzLnZhcmlhYmxlTWFwU2l6ZSB8fCB0aGlzLmNvZXJjaWJsZUtleUFzTnVtYmVyIHx8IHRoaXMuc2tpcFZhbHVlcykgPyAob2JqZWN0KSA9PiB7XG5cdFx0XHQvLyB0aGlzIG1ldGhvZCBpcyBzbGlnaHRseSBzbG93ZXIsIGJ1dCBnZW5lcmF0ZXMgXCJwcmVmZXJyZWQgc2VyaWFsaXphdGlvblwiIChvcHRpbWFsbHkgc21hbGwgZm9yIHNtYWxsZXIgb2JqZWN0cylcblx0XHRcdGxldCBrZXlzO1xuXHRcdFx0aWYgKHRoaXMuc2tpcFZhbHVlcykge1xuXHRcdFx0XHRrZXlzID0gW107XG5cdFx0XHRcdGZvciAobGV0IGtleSBpbiBvYmplY3QpIHtcblx0XHRcdFx0XHRpZiAoKHR5cGVvZiBvYmplY3QuaGFzT3duUHJvcGVydHkgIT09ICdmdW5jdGlvbicgfHwgb2JqZWN0Lmhhc093blByb3BlcnR5KGtleSkpICYmXG5cdFx0XHRcdFx0XHQhdGhpcy5za2lwVmFsdWVzLmluY2x1ZGVzKG9iamVjdFtrZXldKSlcblx0XHRcdFx0XHRcdGtleXMucHVzaChrZXkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KVxuXHRcdFx0fVxuXHRcdFx0bGV0IGxlbmd0aCA9IGtleXMubGVuZ3RoXG5cdFx0XHRpZiAobGVuZ3RoIDwgMHgxMCkge1xuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweDgwIHwgbGVuZ3RoXG5cdFx0XHR9IGVsc2UgaWYgKGxlbmd0aCA8IDB4MTAwMDApIHtcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkZVxuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSBsZW5ndGggPj4gOFxuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSBsZW5ndGggJiAweGZmXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGRmXG5cdFx0XHRcdHRhcmdldFZpZXcuc2V0VWludDMyKHBvc2l0aW9uLCBsZW5ndGgpXG5cdFx0XHRcdHBvc2l0aW9uICs9IDRcblx0XHRcdH1cblx0XHRcdGxldCBrZXlcblx0XHRcdGlmICh0aGlzLmNvZXJjaWJsZUtleUFzTnVtYmVyKSB7XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRrZXkgPSBrZXlzW2ldXG5cdFx0XHRcdFx0bGV0IG51bSA9IE51bWJlcihrZXkpXG5cdFx0XHRcdFx0cGFjayhpc05hTihudW0pID8ga2V5IDogbnVtKVxuXHRcdFx0XHRcdHBhY2sob2JqZWN0W2tleV0pXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHBhY2soa2V5ID0ga2V5c1tpXSlcblx0XHRcdFx0XHRwYWNrKG9iamVjdFtrZXldKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSA6XG5cdFx0KG9iamVjdCkgPT4ge1xuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkZSAvLyBhbHdheXMgdXNpbmcgbWFwIDE2LCBzbyB3ZSBjYW4gcHJlYWxsb2NhdGUgYW5kIHNldCB0aGUgbGVuZ3RoIGFmdGVyd2FyZHNcblx0XHRcdGxldCBvYmplY3RPZmZzZXQgPSBwb3NpdGlvbiAtIHN0YXJ0XG5cdFx0XHRwb3NpdGlvbiArPSAyXG5cdFx0XHRsZXQgc2l6ZSA9IDBcblx0XHRcdGZvciAobGV0IGtleSBpbiBvYmplY3QpIHtcblx0XHRcdFx0aWYgKHR5cGVvZiBvYmplY3QuaGFzT3duUHJvcGVydHkgIT09ICdmdW5jdGlvbicgfHwgb2JqZWN0Lmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdFx0XHRwYWNrKGtleSlcblx0XHRcdFx0XHRwYWNrKG9iamVjdFtrZXldKVxuXHRcdFx0XHRcdHNpemUrK1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoc2l6ZSA+IDB4ZmZmZikge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ09iamVjdCBpcyB0b28gbGFyZ2UgdG8gc2VyaWFsaXplIHdpdGggZmFzdCAxNi1iaXQgbWFwIHNpemUsJyArXG5cdFx0XHRcdCcgdXNlIHRoZSBcInZhcmlhYmxlTWFwU2l6ZVwiIG9wdGlvbiB0byBzZXJpYWxpemUgdGhpcyBvYmplY3QnKTtcblx0XHRcdH1cblx0XHRcdHRhcmdldFtvYmplY3RPZmZzZXQrKyArIHN0YXJ0XSA9IHNpemUgPj4gOFxuXHRcdFx0dGFyZ2V0W29iamVjdE9mZnNldCArIHN0YXJ0XSA9IHNpemUgJiAweGZmXG5cdFx0fVxuXG5cdFx0Y29uc3Qgd3JpdGVSZWNvcmQgPSB0aGlzLnVzZVJlY29yZHMgPT09IGZhbHNlID8gd3JpdGVQbGFpbk9iamVjdCA6XG5cdFx0KG9wdGlvbnMucHJvZ3Jlc3NpdmVSZWNvcmRzICYmICF1c2VUd29CeXRlUmVjb3JkcykgPyAgLy8gdGhpcyBpcyBhYm91dCAyJSBmYXN0ZXIgZm9yIGhpZ2hseSBzdGFibGUgc3RydWN0dXJlcywgc2luY2UgaXQgb25seSByZXF1aXJlcyBvbmUgZm9yLWluIGxvb3AgKGJ1dCBtdWNoIG1vcmUgZXhwZW5zaXZlIHdoZW4gbmV3IHN0cnVjdHVyZSBuZWVkcyB0byBiZSB3cml0dGVuKVxuXHRcdChvYmplY3QpID0+IHtcblx0XHRcdGxldCBuZXh0VHJhbnNpdGlvbiwgdHJhbnNpdGlvbiA9IHN0cnVjdHVyZXMudHJhbnNpdGlvbnMgfHwgKHN0cnVjdHVyZXMudHJhbnNpdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpKVxuXHRcdFx0bGV0IG9iamVjdE9mZnNldCA9IHBvc2l0aW9uKysgLSBzdGFydFxuXHRcdFx0bGV0IHdyb3RlS2V5c1xuXHRcdFx0Zm9yIChsZXQga2V5IGluIG9iamVjdCkge1xuXHRcdFx0XHRpZiAodHlwZW9mIG9iamVjdC5oYXNPd25Qcm9wZXJ0eSAhPT0gJ2Z1bmN0aW9uJyB8fCBvYmplY3QuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0XHRcdG5leHRUcmFuc2l0aW9uID0gdHJhbnNpdGlvbltrZXldXG5cdFx0XHRcdFx0aWYgKG5leHRUcmFuc2l0aW9uKVxuXHRcdFx0XHRcdFx0dHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uXG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyByZWNvcmQgZG9lc24ndCBleGlzdCwgY3JlYXRlIGZ1bGwgbmV3IHJlY29yZCBhbmQgaW5zZXJ0IGl0XG5cdFx0XHRcdFx0XHRsZXQga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdClcblx0XHRcdFx0XHRcdGxldCBsYXN0VHJhbnNpdGlvbiA9IHRyYW5zaXRpb25cblx0XHRcdFx0XHRcdHRyYW5zaXRpb24gPSBzdHJ1Y3R1cmVzLnRyYW5zaXRpb25zXG5cdFx0XHRcdFx0XHRsZXQgbmV3VHJhbnNpdGlvbnMgPSAwXG5cdFx0XHRcdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdGxldCBrZXkgPSBrZXlzW2ldXG5cdFx0XHRcdFx0XHRcdG5leHRUcmFuc2l0aW9uID0gdHJhbnNpdGlvbltrZXldXG5cdFx0XHRcdFx0XHRcdGlmICghbmV4dFRyYW5zaXRpb24pIHtcblx0XHRcdFx0XHRcdFx0XHRuZXh0VHJhbnNpdGlvbiA9IHRyYW5zaXRpb25ba2V5XSA9IE9iamVjdC5jcmVhdGUobnVsbClcblx0XHRcdFx0XHRcdFx0XHRuZXdUcmFuc2l0aW9ucysrXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0dHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAob2JqZWN0T2Zmc2V0ICsgc3RhcnQgKyAxID09IHBvc2l0aW9uKSB7XG5cdFx0XHRcdFx0XHRcdC8vIGZpcnN0IGtleSwgc28gd2UgZG9uJ3QgbmVlZCB0byBpbnNlcnQsIHdlIGNhbiBqdXN0IHdyaXRlIHJlY29yZCBkaXJlY3RseVxuXHRcdFx0XHRcdFx0XHRwb3NpdGlvbi0tXG5cdFx0XHRcdFx0XHRcdG5ld1JlY29yZCh0cmFuc2l0aW9uLCBrZXlzLCBuZXdUcmFuc2l0aW9ucylcblx0XHRcdFx0XHRcdH0gZWxzZSAvLyBvdGhlcndpc2Ugd2UgbmVlZCB0byBpbnNlcnQgdGhlIHJlY29yZCwgbW92aW5nIGV4aXN0aW5nIGRhdGEgYWZ0ZXIgdGhlIHJlY29yZFxuXHRcdFx0XHRcdFx0XHRpbnNlcnROZXdSZWNvcmQodHJhbnNpdGlvbiwga2V5cywgb2JqZWN0T2Zmc2V0LCBuZXdUcmFuc2l0aW9ucylcblx0XHRcdFx0XHRcdHdyb3RlS2V5cyA9IHRydWVcblx0XHRcdFx0XHRcdHRyYW5zaXRpb24gPSBsYXN0VHJhbnNpdGlvbltrZXldXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBhY2sob2JqZWN0W2tleV0pXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICghd3JvdGVLZXlzKSB7XG5cdFx0XHRcdGxldCByZWNvcmRJZCA9IHRyYW5zaXRpb25bUkVDT1JEX1NZTUJPTF1cblx0XHRcdFx0aWYgKHJlY29yZElkKVxuXHRcdFx0XHRcdHRhcmdldFtvYmplY3RPZmZzZXQgKyBzdGFydF0gPSByZWNvcmRJZFxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0aW5zZXJ0TmV3UmVjb3JkKHRyYW5zaXRpb24sIE9iamVjdC5rZXlzKG9iamVjdCksIG9iamVjdE9mZnNldCwgMClcblx0XHRcdH1cblx0XHR9IDpcblx0XHQob2JqZWN0KSA9PiB7XG5cdFx0XHRsZXQgbmV4dFRyYW5zaXRpb24sIHRyYW5zaXRpb24gPSBzdHJ1Y3R1cmVzLnRyYW5zaXRpb25zIHx8IChzdHJ1Y3R1cmVzLnRyYW5zaXRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKSlcblx0XHRcdGxldCBuZXdUcmFuc2l0aW9ucyA9IDBcblx0XHRcdGZvciAobGV0IGtleSBpbiBvYmplY3QpIGlmICh0eXBlb2Ygb2JqZWN0Lmhhc093blByb3BlcnR5ICE9PSAnZnVuY3Rpb24nIHx8IG9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRcdG5leHRUcmFuc2l0aW9uID0gdHJhbnNpdGlvbltrZXldXG5cdFx0XHRcdGlmICghbmV4dFRyYW5zaXRpb24pIHtcblx0XHRcdFx0XHRuZXh0VHJhbnNpdGlvbiA9IHRyYW5zaXRpb25ba2V5XSA9IE9iamVjdC5jcmVhdGUobnVsbClcblx0XHRcdFx0XHRuZXdUcmFuc2l0aW9ucysrXG5cdFx0XHRcdH1cblx0XHRcdFx0dHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uXG5cdFx0XHR9XG5cdFx0XHRsZXQgcmVjb3JkSWQgPSB0cmFuc2l0aW9uW1JFQ09SRF9TWU1CT0xdXG5cdFx0XHRpZiAocmVjb3JkSWQpIHtcblx0XHRcdFx0aWYgKHJlY29yZElkID49IDB4NjAgJiYgdXNlVHdvQnl0ZVJlY29yZHMpIHtcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAoKHJlY29yZElkIC09IDB4NjApICYgMHgxZikgKyAweDYwXG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gcmVjb3JkSWQgPj4gNVxuXHRcdFx0XHR9IGVsc2Vcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSByZWNvcmRJZFxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bmV3UmVjb3JkKHRyYW5zaXRpb24sIHRyYW5zaXRpb24uX19rZXlzX18gfHwgT2JqZWN0LmtleXMob2JqZWN0KSwgbmV3VHJhbnNpdGlvbnMpXG5cdFx0XHR9XG5cdFx0XHQvLyBub3cgd3JpdGUgdGhlIHZhbHVlc1xuXHRcdFx0Zm9yIChsZXQga2V5IGluIG9iamVjdClcblx0XHRcdFx0aWYgKHR5cGVvZiBvYmplY3QuaGFzT3duUHJvcGVydHkgIT09ICdmdW5jdGlvbicgfHwgb2JqZWN0Lmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdFx0XHRwYWNrKG9iamVjdFtrZXldKVxuXHRcdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gY3JlYXRlIHJlZmVyZW5jZSB0byB1c2VSZWNvcmRzIGlmIHVzZVJlY29yZHMgaXMgYSBmdW5jdGlvblxuXHRcdGNvbnN0IGNoZWNrVXNlUmVjb3JkcyA9IHR5cGVvZiB0aGlzLnVzZVJlY29yZHMgPT0gJ2Z1bmN0aW9uJyAmJiB0aGlzLnVzZVJlY29yZHM7XG5cblx0XHRjb25zdCB3cml0ZU9iamVjdCA9IGNoZWNrVXNlUmVjb3JkcyA/IChvYmplY3QpID0+IHtcblx0XHRcdGNoZWNrVXNlUmVjb3JkcyhvYmplY3QpID8gd3JpdGVSZWNvcmQob2JqZWN0KSA6IHdyaXRlUGxhaW5PYmplY3Qob2JqZWN0KVxuXHRcdH0gOiB3cml0ZVJlY29yZFxuXG5cdFx0Y29uc3QgbWFrZVJvb20gPSAoZW5kKSA9PiB7XG5cdFx0XHRsZXQgbmV3U2l6ZVxuXHRcdFx0aWYgKGVuZCA+IDB4MTAwMDAwMCkge1xuXHRcdFx0XHQvLyBzcGVjaWFsIGhhbmRsaW5nIGZvciByZWFsbHkgbGFyZ2UgYnVmZmVyc1xuXHRcdFx0XHRpZiAoKGVuZCAtIHN0YXJ0KSA+IE1BWF9CVUZGRVJfU0laRSlcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1BhY2tlZCBidWZmZXIgd291bGQgYmUgbGFyZ2VyIHRoYW4gbWF4aW11bSBidWZmZXIgc2l6ZScpXG5cdFx0XHRcdG5ld1NpemUgPSBNYXRoLm1pbihNQVhfQlVGRkVSX1NJWkUsXG5cdFx0XHRcdFx0TWF0aC5yb3VuZChNYXRoLm1heCgoZW5kIC0gc3RhcnQpICogKGVuZCA+IDB4NDAwMDAwMCA/IDEuMjUgOiAyKSwgMHg0MDAwMDApIC8gMHgxMDAwKSAqIDB4MTAwMClcblx0XHRcdH0gZWxzZSAvLyBmYXN0ZXIgaGFuZGxpbmcgZm9yIHNtYWxsZXIgYnVmZmVyc1xuXHRcdFx0XHRuZXdTaXplID0gKChNYXRoLm1heCgoZW5kIC0gc3RhcnQpIDw8IDIsIHRhcmdldC5sZW5ndGggLSAxKSA+PiAxMikgKyAxKSA8PCAxMlxuXHRcdFx0bGV0IG5ld0J1ZmZlciA9IG5ldyBCeXRlQXJyYXlBbGxvY2F0ZShuZXdTaXplKVxuXHRcdFx0dGFyZ2V0VmlldyA9IG5ld0J1ZmZlci5kYXRhVmlldyB8fCAobmV3QnVmZmVyLmRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KG5ld0J1ZmZlci5idWZmZXIsIDAsIG5ld1NpemUpKVxuXHRcdFx0ZW5kID0gTWF0aC5taW4oZW5kLCB0YXJnZXQubGVuZ3RoKVxuXHRcdFx0aWYgKHRhcmdldC5jb3B5KVxuXHRcdFx0XHR0YXJnZXQuY29weShuZXdCdWZmZXIsIDAsIHN0YXJ0LCBlbmQpXG5cdFx0XHRlbHNlXG5cdFx0XHRcdG5ld0J1ZmZlci5zZXQodGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpKVxuXHRcdFx0cG9zaXRpb24gLT0gc3RhcnRcblx0XHRcdHN0YXJ0ID0gMFxuXHRcdFx0c2FmZUVuZCA9IG5ld0J1ZmZlci5sZW5ndGggLSAxMFxuXHRcdFx0cmV0dXJuIHRhcmdldCA9IG5ld0J1ZmZlclxuXHRcdH1cblx0XHRjb25zdCBuZXdSZWNvcmQgPSAodHJhbnNpdGlvbiwga2V5cywgbmV3VHJhbnNpdGlvbnMpID0+IHtcblx0XHRcdGxldCByZWNvcmRJZCA9IHN0cnVjdHVyZXMubmV4dElkXG5cdFx0XHRpZiAoIXJlY29yZElkKVxuXHRcdFx0XHRyZWNvcmRJZCA9IDB4NDBcblx0XHRcdGlmIChyZWNvcmRJZCA8IHNoYXJlZExpbWl0SWQgJiYgdGhpcy5zaG91bGRTaGFyZVN0cnVjdHVyZSAmJiAhdGhpcy5zaG91bGRTaGFyZVN0cnVjdHVyZShrZXlzKSkge1xuXHRcdFx0XHRyZWNvcmRJZCA9IHN0cnVjdHVyZXMubmV4dE93bklkXG5cdFx0XHRcdGlmICghKHJlY29yZElkIDwgbWF4U3RydWN0dXJlSWQpKVxuXHRcdFx0XHRcdHJlY29yZElkID0gc2hhcmVkTGltaXRJZFxuXHRcdFx0XHRzdHJ1Y3R1cmVzLm5leHRPd25JZCA9IHJlY29yZElkICsgMVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHJlY29yZElkID49IG1heFN0cnVjdHVyZUlkKS8vIGN5Y2xlIGJhY2sgYXJvdW5kXG5cdFx0XHRcdFx0cmVjb3JkSWQgPSBzaGFyZWRMaW1pdElkXG5cdFx0XHRcdHN0cnVjdHVyZXMubmV4dElkID0gcmVjb3JkSWQgKyAxXG5cdFx0XHR9XG5cdFx0XHRsZXQgaGlnaEJ5dGUgPSBrZXlzLmhpZ2hCeXRlID0gcmVjb3JkSWQgPj0gMHg2MCAmJiB1c2VUd29CeXRlUmVjb3JkcyA/IChyZWNvcmRJZCAtIDB4NjApID4+IDUgOiAtMVxuXHRcdFx0dHJhbnNpdGlvbltSRUNPUkRfU1lNQk9MXSA9IHJlY29yZElkXG5cdFx0XHR0cmFuc2l0aW9uLl9fa2V5c19fID0ga2V5c1xuXHRcdFx0c3RydWN0dXJlc1tyZWNvcmRJZCAtIDB4NDBdID0ga2V5c1xuXG5cdFx0XHRpZiAocmVjb3JkSWQgPCBzaGFyZWRMaW1pdElkKSB7XG5cdFx0XHRcdGtleXMuaXNTaGFyZWQgPSB0cnVlXG5cdFx0XHRcdHN0cnVjdHVyZXMuc2hhcmVkTGVuZ3RoID0gcmVjb3JkSWQgLSAweDNmXG5cdFx0XHRcdGhhc1NoYXJlZFVwZGF0ZSA9IHRydWVcblx0XHRcdFx0aWYgKGhpZ2hCeXRlID49IDApIHtcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAocmVjb3JkSWQgJiAweDFmKSArIDB4NjBcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSBoaWdoQnl0ZVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IHJlY29yZElkXG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChoaWdoQnl0ZSA+PSAwKSB7XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkNSAvLyBmaXhleHQgMlxuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4NzIgLy8gXCJyXCIgcmVjb3JkIGRlZmludGlvbiBleHRlbnNpb24gdHlwZVxuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IChyZWNvcmRJZCAmIDB4MWYpICsgMHg2MFxuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGhpZ2hCeXRlXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkNCAvLyBmaXhleHQgMVxuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4NzIgLy8gXCJyXCIgcmVjb3JkIGRlZmludGlvbiBleHRlbnNpb24gdHlwZVxuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IHJlY29yZElkXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAobmV3VHJhbnNpdGlvbnMpXG5cdFx0XHRcdFx0dHJhbnNpdGlvbnNDb3VudCArPSBzZXJpYWxpemF0aW9uc1NpbmNlVHJhbnNpdGlvblJlYnVpbGQgKiBuZXdUcmFuc2l0aW9uc1xuXHRcdFx0XHQvLyByZWNvcmQgdGhlIHJlbW92YWwgb2YgdGhlIGlkLCB3ZSBjYW4gbWFpbnRhaW4gb3VyIHNoYXJlZCBzdHJ1Y3R1cmVcblx0XHRcdFx0aWYgKHJlY29yZElkc1RvUmVtb3ZlLmxlbmd0aCA+PSBtYXhPd25TdHJ1Y3R1cmVzKVxuXHRcdFx0XHRcdHJlY29yZElkc1RvUmVtb3ZlLnNoaWZ0KClbUkVDT1JEX1NZTUJPTF0gPSAwIC8vIHdlIGFyZSBjeWNsaW5nIGJhY2sgdGhyb3VnaCwgYW5kIGhhdmUgdG8gcmVtb3ZlIG9sZCBvbmVzXG5cdFx0XHRcdHJlY29yZElkc1RvUmVtb3ZlLnB1c2godHJhbnNpdGlvbilcblx0XHRcdFx0cGFjayhrZXlzKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRjb25zdCBpbnNlcnROZXdSZWNvcmQgPSAodHJhbnNpdGlvbiwga2V5cywgaW5zZXJ0aW9uT2Zmc2V0LCBuZXdUcmFuc2l0aW9ucykgPT4ge1xuXHRcdFx0bGV0IG1haW5UYXJnZXQgPSB0YXJnZXRcblx0XHRcdGxldCBtYWluUG9zaXRpb24gPSBwb3NpdGlvblxuXHRcdFx0bGV0IG1haW5TYWZlRW5kID0gc2FmZUVuZFxuXHRcdFx0bGV0IG1haW5TdGFydCA9IHN0YXJ0XG5cdFx0XHR0YXJnZXQgPSBrZXlzVGFyZ2V0XG5cdFx0XHRwb3NpdGlvbiA9IDBcblx0XHRcdHN0YXJ0ID0gMFxuXHRcdFx0aWYgKCF0YXJnZXQpXG5cdFx0XHRcdGtleXNUYXJnZXQgPSB0YXJnZXQgPSBuZXcgQnl0ZUFycmF5QWxsb2NhdGUoODE5Milcblx0XHRcdHNhZmVFbmQgPSB0YXJnZXQubGVuZ3RoIC0gMTBcblx0XHRcdG5ld1JlY29yZCh0cmFuc2l0aW9uLCBrZXlzLCBuZXdUcmFuc2l0aW9ucylcblx0XHRcdGtleXNUYXJnZXQgPSB0YXJnZXRcblx0XHRcdGxldCBrZXlzUG9zaXRpb24gPSBwb3NpdGlvblxuXHRcdFx0dGFyZ2V0ID0gbWFpblRhcmdldFxuXHRcdFx0cG9zaXRpb24gPSBtYWluUG9zaXRpb25cblx0XHRcdHNhZmVFbmQgPSBtYWluU2FmZUVuZFxuXHRcdFx0c3RhcnQgPSBtYWluU3RhcnRcblx0XHRcdGlmIChrZXlzUG9zaXRpb24gPiAxKSB7XG5cdFx0XHRcdGxldCBuZXdFbmQgPSBwb3NpdGlvbiArIGtleXNQb3NpdGlvbiAtIDFcblx0XHRcdFx0aWYgKG5ld0VuZCA+IHNhZmVFbmQpXG5cdFx0XHRcdFx0bWFrZVJvb20obmV3RW5kKVxuXHRcdFx0XHRsZXQgaW5zZXJ0aW9uUG9zaXRpb24gPSBpbnNlcnRpb25PZmZzZXQgKyBzdGFydFxuXHRcdFx0XHR0YXJnZXQuY29weVdpdGhpbihpbnNlcnRpb25Qb3NpdGlvbiArIGtleXNQb3NpdGlvbiwgaW5zZXJ0aW9uUG9zaXRpb24gKyAxLCBwb3NpdGlvbilcblx0XHRcdFx0dGFyZ2V0LnNldChrZXlzVGFyZ2V0LnNsaWNlKDAsIGtleXNQb3NpdGlvbiksIGluc2VydGlvblBvc2l0aW9uKVxuXHRcdFx0XHRwb3NpdGlvbiA9IG5ld0VuZFxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGFyZ2V0W2luc2VydGlvbk9mZnNldCArIHN0YXJ0XSA9IGtleXNUYXJnZXRbMF1cblx0XHRcdH1cblx0XHR9XG5cdFx0Y29uc3Qgd3JpdGVTdHJ1Y3QgPSAob2JqZWN0KSA9PiB7XG5cdFx0XHRsZXQgbmV3UG9zaXRpb24gPSB3cml0ZVN0cnVjdFNsb3RzKG9iamVjdCwgdGFyZ2V0LCBzdGFydCwgcG9zaXRpb24sIHN0cnVjdHVyZXMsIG1ha2VSb29tLCAodmFsdWUsIG5ld1Bvc2l0aW9uLCBub3RpZnlTaGFyZWRVcGRhdGUpID0+IHtcblx0XHRcdFx0aWYgKG5vdGlmeVNoYXJlZFVwZGF0ZSlcblx0XHRcdFx0XHRyZXR1cm4gaGFzU2hhcmVkVXBkYXRlID0gdHJ1ZTtcblx0XHRcdFx0cG9zaXRpb24gPSBuZXdQb3NpdGlvbjtcblx0XHRcdFx0bGV0IHN0YXJ0VGFyZ2V0ID0gdGFyZ2V0O1xuXHRcdFx0XHRwYWNrKHZhbHVlKTtcblx0XHRcdFx0cmVzZXRTdHJ1Y3R1cmVzKCk7XG5cdFx0XHRcdGlmIChzdGFydFRhcmdldCAhPT0gdGFyZ2V0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIHsgcG9zaXRpb24sIHRhcmdldFZpZXcsIHRhcmdldCB9OyAvLyBpbmRpY2F0ZSB0aGUgYnVmZmVyIHdhcyByZS1hbGxvY2F0ZWRcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcG9zaXRpb247XG5cdFx0XHR9LCB0aGlzKTtcblx0XHRcdGlmIChuZXdQb3NpdGlvbiA9PT0gMCkgLy8gYmFpbCBhbmQgZ28gdG8gYSBtc2dwYWNrIG9iamVjdFxuXHRcdFx0XHRyZXR1cm4gd3JpdGVPYmplY3Qob2JqZWN0KTtcblx0XHRcdHBvc2l0aW9uID0gbmV3UG9zaXRpb247XG5cdFx0fVxuXHR9XG5cdHVzZUJ1ZmZlcihidWZmZXIpIHtcblx0XHQvLyB0aGlzIG1lYW5zIHdlIGFyZSBmaW5pc2hlZCB1c2luZyBvdXIgb3duIGJ1ZmZlciBhbmQgd2UgY2FuIHdyaXRlIG92ZXIgaXQgc2FmZWx5XG5cdFx0dGFyZ2V0ID0gYnVmZmVyXG5cdFx0dGFyZ2V0LmRhdGFWaWV3IHx8ICh0YXJnZXQuZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcodGFyZ2V0LmJ1ZmZlciwgdGFyZ2V0LmJ5dGVPZmZzZXQsIHRhcmdldC5ieXRlTGVuZ3RoKSlcblx0XHR0YXJnZXRWaWV3ID0gdGFyZ2V0LmRhdGFWaWV3O1xuXHRcdHBvc2l0aW9uID0gMFxuXHR9XG5cdHNldCBwb3NpdGlvbiAodmFsdWUpIHtcblx0XHRwb3NpdGlvbiA9IHZhbHVlO1xuXHR9XG5cdGdldCBwb3NpdGlvbigpIHtcblx0XHRyZXR1cm4gcG9zaXRpb247XG5cdH1cblx0Y2xlYXJTaGFyZWREYXRhKCkge1xuXHRcdGlmICh0aGlzLnN0cnVjdHVyZXMpXG5cdFx0XHR0aGlzLnN0cnVjdHVyZXMgPSBbXVxuXHRcdGlmICh0aGlzLnR5cGVkU3RydWN0cylcblx0XHRcdHRoaXMudHlwZWRTdHJ1Y3RzID0gW11cblx0fVxufVxuXG5leHRlbnNpb25DbGFzc2VzID0gWyBEYXRlLCBTZXQsIEVycm9yLCBSZWdFeHAsIEFycmF5QnVmZmVyLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVWludDhBcnJheS5wcm90b3R5cGUpLmNvbnN0cnVjdG9yIC8qVHlwZWRBcnJheSovLCBEYXRhVmlldywgQzFUeXBlIF1cbmV4dGVuc2lvbnMgPSBbe1xuXHRwYWNrKGRhdGUsIGFsbG9jYXRlRm9yV3JpdGUsIHBhY2spIHtcblx0XHRsZXQgc2Vjb25kcyA9IGRhdGUuZ2V0VGltZSgpIC8gMTAwMFxuXHRcdGlmICgodGhpcy51c2VUaW1lc3RhbXAzMiB8fCBkYXRlLmdldE1pbGxpc2Vjb25kcygpID09PSAwKSAmJiBzZWNvbmRzID49IDAgJiYgc2Vjb25kcyA8IDB4MTAwMDAwMDAwKSB7XG5cdFx0XHQvLyBUaW1lc3RhbXAgMzJcblx0XHRcdGxldCB7IHRhcmdldCwgdGFyZ2V0VmlldywgcG9zaXRpb259ID0gYWxsb2NhdGVGb3JXcml0ZSg2KVxuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkNlxuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhmZlxuXHRcdFx0dGFyZ2V0Vmlldy5zZXRVaW50MzIocG9zaXRpb24sIHNlY29uZHMpXG5cdFx0fSBlbHNlIGlmIChzZWNvbmRzID4gMCAmJiBzZWNvbmRzIDwgMHgxMDAwMDAwMDApIHtcblx0XHRcdC8vIFRpbWVzdGFtcCA2NFxuXHRcdFx0bGV0IHsgdGFyZ2V0LCB0YXJnZXRWaWV3LCBwb3NpdGlvbn0gPSBhbGxvY2F0ZUZvcldyaXRlKDEwKVxuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkN1xuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhmZlxuXHRcdFx0dGFyZ2V0Vmlldy5zZXRVaW50MzIocG9zaXRpb24sIGRhdGUuZ2V0TWlsbGlzZWNvbmRzKCkgKiA0MDAwMDAwICsgKChzZWNvbmRzIC8gMTAwMCAvIDB4MTAwMDAwMDAwKSA+PiAwKSlcblx0XHRcdHRhcmdldFZpZXcuc2V0VWludDMyKHBvc2l0aW9uICsgNCwgc2Vjb25kcylcblx0XHR9IGVsc2UgaWYgKGlzTmFOKHNlY29uZHMpKSB7XG5cdFx0XHRpZiAodGhpcy5vbkludmFsaWREYXRlKSB7XG5cdFx0XHRcdGFsbG9jYXRlRm9yV3JpdGUoMClcblx0XHRcdFx0cmV0dXJuIHBhY2sodGhpcy5vbkludmFsaWREYXRlKCkpXG5cdFx0XHR9XG5cdFx0XHQvLyBJbnRlbnRpb25hbGx5IGludmFsaWQgdGltZXN0YW1wXG5cdFx0XHRsZXQgeyB0YXJnZXQsIHRhcmdldFZpZXcsIHBvc2l0aW9ufSA9IGFsbG9jYXRlRm9yV3JpdGUoMylcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDRcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZmZcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZmZcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gVGltZXN0YW1wIDk2XG5cdFx0XHRsZXQgeyB0YXJnZXQsIHRhcmdldFZpZXcsIHBvc2l0aW9ufSA9IGFsbG9jYXRlRm9yV3JpdGUoMTUpXG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGM3XG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAxMlxuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhmZlxuXHRcdFx0dGFyZ2V0Vmlldy5zZXRVaW50MzIocG9zaXRpb24sIGRhdGUuZ2V0TWlsbGlzZWNvbmRzKCkgKiAxMDAwMDAwKVxuXHRcdFx0dGFyZ2V0Vmlldy5zZXRCaWdJbnQ2NChwb3NpdGlvbiArIDQsIEJpZ0ludChNYXRoLmZsb29yKHNlY29uZHMpKSlcblx0XHR9XG5cdH1cbn0sIHtcblx0cGFjayhzZXQsIGFsbG9jYXRlRm9yV3JpdGUsIHBhY2spIHtcblx0XHRpZiAodGhpcy5zZXRBc0VtcHR5T2JqZWN0KSB7XG5cdFx0XHRhbGxvY2F0ZUZvcldyaXRlKDApO1xuXHRcdFx0cmV0dXJuIHBhY2soe30pXG5cdFx0fVxuXHRcdGxldCBhcnJheSA9IEFycmF5LmZyb20oc2V0KVxuXHRcdGxldCB7IHRhcmdldCwgcG9zaXRpb259ID0gYWxsb2NhdGVGb3JXcml0ZSh0aGlzLm1vcmVUeXBlcyA/IDMgOiAwKVxuXHRcdGlmICh0aGlzLm1vcmVUeXBlcykge1xuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkNFxuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHg3MyAvLyAncycgZm9yIFNldFxuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMFxuXHRcdH1cblx0XHRwYWNrKGFycmF5KVxuXHR9XG59LCB7XG5cdHBhY2soZXJyb3IsIGFsbG9jYXRlRm9yV3JpdGUsIHBhY2spIHtcblx0XHRsZXQgeyB0YXJnZXQsIHBvc2l0aW9ufSA9IGFsbG9jYXRlRm9yV3JpdGUodGhpcy5tb3JlVHlwZXMgPyAzIDogMClcblx0XHRpZiAodGhpcy5tb3JlVHlwZXMpIHtcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDRcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4NjUgLy8gJ2UnIGZvciBlcnJvclxuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMFxuXHRcdH1cblx0XHRwYWNrKFsgZXJyb3IubmFtZSwgZXJyb3IubWVzc2FnZSwgZXJyb3IuY2F1c2UgXSlcblx0fVxufSwge1xuXHRwYWNrKHJlZ2V4LCBhbGxvY2F0ZUZvcldyaXRlLCBwYWNrKSB7XG5cdFx0bGV0IHsgdGFyZ2V0LCBwb3NpdGlvbn0gPSBhbGxvY2F0ZUZvcldyaXRlKHRoaXMubW9yZVR5cGVzID8gMyA6IDApXG5cdFx0aWYgKHRoaXMubW9yZVR5cGVzKSB7XG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQ0XG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweDc4IC8vICd4JyBmb3IgcmVnZVhwXG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAwXG5cdFx0fVxuXHRcdHBhY2soWyByZWdleC5zb3VyY2UsIHJlZ2V4LmZsYWdzIF0pXG5cdH1cbn0sIHtcblx0cGFjayhhcnJheUJ1ZmZlciwgYWxsb2NhdGVGb3JXcml0ZSkge1xuXHRcdGlmICh0aGlzLm1vcmVUeXBlcylcblx0XHRcdHdyaXRlRXh0QnVmZmVyKGFycmF5QnVmZmVyLCAweDEwLCBhbGxvY2F0ZUZvcldyaXRlKVxuXHRcdGVsc2Vcblx0XHRcdHdyaXRlQnVmZmVyKGhhc05vZGVCdWZmZXIgPyBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlcikgOiBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlciksIGFsbG9jYXRlRm9yV3JpdGUpXG5cdH1cbn0sIHtcblx0cGFjayh0eXBlZEFycmF5LCBhbGxvY2F0ZUZvcldyaXRlKSB7XG5cdFx0bGV0IGNvbnN0cnVjdG9yID0gdHlwZWRBcnJheS5jb25zdHJ1Y3RvclxuXHRcdGlmIChjb25zdHJ1Y3RvciAhPT0gQnl0ZUFycmF5ICYmIHRoaXMubW9yZVR5cGVzKVxuXHRcdFx0d3JpdGVFeHRCdWZmZXIodHlwZWRBcnJheSwgdHlwZWRBcnJheXMuaW5kZXhPZihjb25zdHJ1Y3Rvci5uYW1lKSwgYWxsb2NhdGVGb3JXcml0ZSlcblx0XHRlbHNlXG5cdFx0XHR3cml0ZUJ1ZmZlcih0eXBlZEFycmF5LCBhbGxvY2F0ZUZvcldyaXRlKVxuXHR9XG59LCB7XG5cdHBhY2soYXJyYXlCdWZmZXIsIGFsbG9jYXRlRm9yV3JpdGUpIHtcblx0XHRpZiAodGhpcy5tb3JlVHlwZXMpXG5cdFx0XHR3cml0ZUV4dEJ1ZmZlcihhcnJheUJ1ZmZlciwgMHgxMSwgYWxsb2NhdGVGb3JXcml0ZSlcblx0XHRlbHNlXG5cdFx0XHR3cml0ZUJ1ZmZlcihoYXNOb2RlQnVmZmVyID8gQnVmZmVyLmZyb20oYXJyYXlCdWZmZXIpIDogbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpLCBhbGxvY2F0ZUZvcldyaXRlKVxuXHR9XG59LCB7XG5cdHBhY2soYzEsIGFsbG9jYXRlRm9yV3JpdGUpIHsgLy8gc3BlY2lmaWMgMHhDMSBvYmplY3Rcblx0XHRsZXQgeyB0YXJnZXQsIHBvc2l0aW9ufSA9IGFsbG9jYXRlRm9yV3JpdGUoMSlcblx0XHR0YXJnZXRbcG9zaXRpb25dID0gMHhjMVxuXHR9XG59XVxuXG5mdW5jdGlvbiB3cml0ZUV4dEJ1ZmZlcih0eXBlZEFycmF5LCB0eXBlLCBhbGxvY2F0ZUZvcldyaXRlLCBlbmNvZGUpIHtcblx0bGV0IGxlbmd0aCA9IHR5cGVkQXJyYXkuYnl0ZUxlbmd0aFxuXHRpZiAobGVuZ3RoICsgMSA8IDB4MTAwKSB7XG5cdFx0dmFyIHsgdGFyZ2V0LCBwb3NpdGlvbiB9ID0gYWxsb2NhdGVGb3JXcml0ZSg0ICsgbGVuZ3RoKVxuXHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4Yzdcblx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSBsZW5ndGggKyAxXG5cdH0gZWxzZSBpZiAobGVuZ3RoICsgMSA8IDB4MTAwMDApIHtcblx0XHR2YXIgeyB0YXJnZXQsIHBvc2l0aW9uIH0gPSBhbGxvY2F0ZUZvcldyaXRlKDUgKyBsZW5ndGgpXG5cdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhjOFxuXHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IChsZW5ndGggKyAxKSA+PiA4XG5cdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gKGxlbmd0aCArIDEpICYgMHhmZlxuXHR9IGVsc2Uge1xuXHRcdHZhciB7IHRhcmdldCwgcG9zaXRpb24sIHRhcmdldFZpZXcgfSA9IGFsbG9jYXRlRm9yV3JpdGUoNyArIGxlbmd0aClcblx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGM5XG5cdFx0dGFyZ2V0Vmlldy5zZXRVaW50MzIocG9zaXRpb24sIGxlbmd0aCArIDEpIC8vIHBsdXMgb25lIGZvciB0aGUgdHlwZSBieXRlXG5cdFx0cG9zaXRpb24gKz0gNFxuXHR9XG5cdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4NzQgLy8gXCJ0XCIgZm9yIHR5cGVkIGFycmF5XG5cdHRhcmdldFtwb3NpdGlvbisrXSA9IHR5cGVcblx0aWYgKCF0eXBlZEFycmF5LmJ1ZmZlcikgdHlwZWRBcnJheSA9IG5ldyBVaW50OEFycmF5KHR5cGVkQXJyYXkpXG5cdHRhcmdldC5zZXQobmV3IFVpbnQ4QXJyYXkodHlwZWRBcnJheS5idWZmZXIsIHR5cGVkQXJyYXkuYnl0ZU9mZnNldCwgdHlwZWRBcnJheS5ieXRlTGVuZ3RoKSwgcG9zaXRpb24pXG59XG5mdW5jdGlvbiB3cml0ZUJ1ZmZlcihidWZmZXIsIGFsbG9jYXRlRm9yV3JpdGUpIHtcblx0bGV0IGxlbmd0aCA9IGJ1ZmZlci5ieXRlTGVuZ3RoXG5cdHZhciB0YXJnZXQsIHBvc2l0aW9uXG5cdGlmIChsZW5ndGggPCAweDEwMCkge1xuXHRcdHZhciB7IHRhcmdldCwgcG9zaXRpb24gfSA9IGFsbG9jYXRlRm9yV3JpdGUobGVuZ3RoICsgMilcblx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGM0XG5cdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoXG5cdH0gZWxzZSBpZiAobGVuZ3RoIDwgMHgxMDAwMCkge1xuXHRcdHZhciB7IHRhcmdldCwgcG9zaXRpb24gfSA9IGFsbG9jYXRlRm9yV3JpdGUobGVuZ3RoICsgMylcblx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGM1XG5cdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoID4+IDhcblx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSBsZW5ndGggJiAweGZmXG5cdH0gZWxzZSB7XG5cdFx0dmFyIHsgdGFyZ2V0LCBwb3NpdGlvbiwgdGFyZ2V0VmlldyB9ID0gYWxsb2NhdGVGb3JXcml0ZShsZW5ndGggKyA1KVxuXHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4YzZcblx0XHR0YXJnZXRWaWV3LnNldFVpbnQzMihwb3NpdGlvbiwgbGVuZ3RoKVxuXHRcdHBvc2l0aW9uICs9IDRcblx0fVxuXHR0YXJnZXQuc2V0KGJ1ZmZlciwgcG9zaXRpb24pXG59XG5cbmZ1bmN0aW9uIHdyaXRlRXh0ZW5zaW9uRGF0YShyZXN1bHQsIHRhcmdldCwgcG9zaXRpb24sIHR5cGUpIHtcblx0bGV0IGxlbmd0aCA9IHJlc3VsdC5sZW5ndGhcblx0c3dpdGNoIChsZW5ndGgpIHtcblx0XHRjYXNlIDE6XG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQ0XG5cdFx0XHRicmVha1xuXHRcdGNhc2UgMjpcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDVcblx0XHRcdGJyZWFrXG5cdFx0Y2FzZSA0OlxuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkNlxuXHRcdFx0YnJlYWtcblx0XHRjYXNlIDg6XG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQ3XG5cdFx0XHRicmVha1xuXHRcdGNhc2UgMTY6XG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQ4XG5cdFx0XHRicmVha1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHRpZiAobGVuZ3RoIDwgMHgxMDApIHtcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhjN1xuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSBsZW5ndGhcblx0XHRcdH0gZWxzZSBpZiAobGVuZ3RoIDwgMHgxMDAwMCkge1xuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGM4XG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGxlbmd0aCA+PiA4XG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGxlbmd0aCAmIDB4ZmZcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4Yzlcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoID4+IDI0XG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IChsZW5ndGggPj4gMTYpICYgMHhmZlxuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAobGVuZ3RoID4+IDgpICYgMHhmZlxuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSBsZW5ndGggJiAweGZmXG5cdFx0XHR9XG5cdH1cblx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gdHlwZVxuXHR0YXJnZXQuc2V0KHJlc3VsdCwgcG9zaXRpb24pXG5cdHBvc2l0aW9uICs9IGxlbmd0aFxuXHRyZXR1cm4gcG9zaXRpb25cbn1cblxuZnVuY3Rpb24gaW5zZXJ0SWRzKHNlcmlhbGl6ZWQsIGlkc1RvSW5zZXJ0KSB7XG5cdC8vIGluc2VydCB0aGUgaWRzIHRoYXQgbmVlZCB0byBiZSByZWZlcmVuY2VkIGZvciBzdHJ1Y3R1cmVkIGNsb25lc1xuXHRsZXQgbmV4dElkXG5cdGxldCBkaXN0YW5jZVRvTW92ZSA9IGlkc1RvSW5zZXJ0Lmxlbmd0aCAqIDZcblx0bGV0IGxhc3RFbmQgPSBzZXJpYWxpemVkLmxlbmd0aCAtIGRpc3RhbmNlVG9Nb3ZlXG5cdHdoaWxlIChuZXh0SWQgPSBpZHNUb0luc2VydC5wb3AoKSkge1xuXHRcdGxldCBvZmZzZXQgPSBuZXh0SWQub2Zmc2V0XG5cdFx0bGV0IGlkID0gbmV4dElkLmlkXG5cdFx0c2VyaWFsaXplZC5jb3B5V2l0aGluKG9mZnNldCArIGRpc3RhbmNlVG9Nb3ZlLCBvZmZzZXQsIGxhc3RFbmQpXG5cdFx0ZGlzdGFuY2VUb01vdmUgLT0gNlxuXHRcdGxldCBwb3NpdGlvbiA9IG9mZnNldCArIGRpc3RhbmNlVG9Nb3ZlXG5cdFx0c2VyaWFsaXplZFtwb3NpdGlvbisrXSA9IDB4ZDZcblx0XHRzZXJpYWxpemVkW3Bvc2l0aW9uKytdID0gMHg2OSAvLyAnaSdcblx0XHRzZXJpYWxpemVkW3Bvc2l0aW9uKytdID0gaWQgPj4gMjRcblx0XHRzZXJpYWxpemVkW3Bvc2l0aW9uKytdID0gKGlkID4+IDE2KSAmIDB4ZmZcblx0XHRzZXJpYWxpemVkW3Bvc2l0aW9uKytdID0gKGlkID4+IDgpICYgMHhmZlxuXHRcdHNlcmlhbGl6ZWRbcG9zaXRpb24rK10gPSBpZCAmIDB4ZmZcblx0XHRsYXN0RW5kID0gb2Zmc2V0XG5cdH1cblx0cmV0dXJuIHNlcmlhbGl6ZWRcbn1cblxuZnVuY3Rpb24gd3JpdGVCdW5kbGVzKHN0YXJ0LCBwYWNrLCBpbmNyZW1lbnRQb3NpdGlvbikge1xuXHRpZiAoYnVuZGxlZFN0cmluZ3MubGVuZ3RoID4gMCkge1xuXHRcdHRhcmdldFZpZXcuc2V0VWludDMyKGJ1bmRsZWRTdHJpbmdzLnBvc2l0aW9uICsgc3RhcnQsIHBvc2l0aW9uICsgaW5jcmVtZW50UG9zaXRpb24gLSBidW5kbGVkU3RyaW5ncy5wb3NpdGlvbiAtIHN0YXJ0KVxuXHRcdGJ1bmRsZWRTdHJpbmdzLnN0cmluZ3NQb3NpdGlvbiA9IHBvc2l0aW9uIC0gc3RhcnQ7XG5cdFx0bGV0IHdyaXRlU3RyaW5ncyA9IGJ1bmRsZWRTdHJpbmdzXG5cdFx0YnVuZGxlZFN0cmluZ3MgPSBudWxsXG5cdFx0cGFjayh3cml0ZVN0cmluZ3NbMF0pXG5cdFx0cGFjayh3cml0ZVN0cmluZ3NbMV0pXG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZEV4dGVuc2lvbihleHRlbnNpb24pIHtcblx0aWYgKGV4dGVuc2lvbi5DbGFzcykge1xuXHRcdGlmICghZXh0ZW5zaW9uLnBhY2sgJiYgIWV4dGVuc2lvbi53cml0ZSlcblx0XHRcdHRocm93IG5ldyBFcnJvcignRXh0ZW5zaW9uIGhhcyBubyBwYWNrIG9yIHdyaXRlIGZ1bmN0aW9uJylcblx0XHRpZiAoZXh0ZW5zaW9uLnBhY2sgJiYgIWV4dGVuc2lvbi50eXBlKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdFeHRlbnNpb24gaGFzIG5vIHR5cGUgKG51bWVyaWMgY29kZSB0byBpZGVudGlmeSB0aGUgZXh0ZW5zaW9uKScpXG5cdFx0ZXh0ZW5zaW9uQ2xhc3Nlcy51bnNoaWZ0KGV4dGVuc2lvbi5DbGFzcylcblx0XHRleHRlbnNpb25zLnVuc2hpZnQoZXh0ZW5zaW9uKVxuXHR9XG5cdHVucGFja0FkZEV4dGVuc2lvbihleHRlbnNpb24pXG59XG5mdW5jdGlvbiBwcmVwYXJlU3RydWN0dXJlcyhzdHJ1Y3R1cmVzLCBwYWNrcikge1xuXHRzdHJ1Y3R1cmVzLmlzQ29tcGF0aWJsZSA9IChleGlzdGluZ1N0cnVjdHVyZXMpID0+IHtcblx0XHRsZXQgY29tcGF0aWJsZSA9ICFleGlzdGluZ1N0cnVjdHVyZXMgfHwgKChwYWNrci5sYXN0TmFtZWRTdHJ1Y3R1cmVzTGVuZ3RoIHx8IDApID09PSBleGlzdGluZ1N0cnVjdHVyZXMubGVuZ3RoKVxuXHRcdGlmICghY29tcGF0aWJsZSkgLy8gd2Ugd2FudCB0byBtZXJnZSB0aGVzZSBleGlzdGluZyBzdHJ1Y3R1cmVzIGltbWVkaWF0ZWx5IHNpbmNlIHdlIGFscmVhZHkgaGF2ZSBpdCBhbmQgd2UgYXJlIGluIHRoZSByaWdodCB0cmFuc2FjdGlvblxuXHRcdFx0cGFja3IuX21lcmdlU3RydWN0dXJlcyhleGlzdGluZ1N0cnVjdHVyZXMpO1xuXHRcdHJldHVybiBjb21wYXRpYmxlO1xuXHR9XG5cdHJldHVybiBzdHJ1Y3R1cmVzXG59XG5leHBvcnQgZnVuY3Rpb24gc2V0V3JpdGVTdHJ1Y3RTbG90cyh3cml0ZVNsb3RzLCBtYWtlU3RydWN0dXJlcykge1xuXHR3cml0ZVN0cnVjdFNsb3RzID0gd3JpdGVTbG90cztcblx0cHJlcGFyZVN0cnVjdHVyZXMgPSBtYWtlU3RydWN0dXJlcztcbn1cblxubGV0IGRlZmF1bHRQYWNrciA9IG5ldyBQYWNrcih7IHVzZVJlY29yZHM6IGZhbHNlIH0pXG5leHBvcnQgY29uc3QgcGFjayA9IGRlZmF1bHRQYWNrci5wYWNrXG5leHBvcnQgY29uc3QgZW5jb2RlID0gZGVmYXVsdFBhY2tyLnBhY2tcbmV4cG9ydCBjb25zdCBFbmNvZGVyID0gUGFja3JcbmV4cG9ydCB7IEZMT0FUMzJfT1BUSU9OUyB9IGZyb20gJy4vdW5wYWNrLmpzJ1xuaW1wb3J0IHsgRkxPQVQzMl9PUFRJT05TIH0gZnJvbSAnLi91bnBhY2suanMnXG5leHBvcnQgY29uc3QgeyBORVZFUiwgQUxXQVlTLCBERUNJTUFMX1JPVU5ELCBERUNJTUFMX0ZJVCB9ID0gRkxPQVQzMl9PUFRJT05TXG5leHBvcnQgY29uc3QgUkVVU0VfQlVGRkVSX01PREUgPSA1MTJcbmV4cG9ydCBjb25zdCBSRVNFVF9CVUZGRVJfTU9ERSA9IDEwMjRcbmV4cG9ydCBjb25zdCBSRVNFUlZFX1NUQVJUX1NQQUNFID0gMjA0OFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../../node_modules/msgpackr/pack.js\n");

/***/ }),

/***/ "(action-browser)/../../node_modules/msgpackr/stream.js":
/*!*********************************************!*\
  !*** ../../node_modules/msgpackr/stream.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PackrStream: () => (/* binding */ PackrStream),\n/* harmony export */   UnpackrStream: () => (/* binding */ UnpackrStream)\n/* harmony export */ });\n/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! stream */ \"stream\");\n/* harmony import */ var _pack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pack.js */ \"(action-browser)/../../node_modules/msgpackr/pack.js\");\n/* harmony import */ var _unpack_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./unpack.js */ \"(action-browser)/../../node_modules/msgpackr/unpack.js\");\n\n\n\nvar DEFAULT_OPTIONS = {objectMode: true}\n\nclass PackrStream extends stream__WEBPACK_IMPORTED_MODULE_0__.Transform {\n\tconstructor(options) {\n\t\tif (!options)\n\t\t\toptions = {}\n\t\toptions.writableObjectMode = true\n\t\tsuper(options)\n\t\toptions.sequential = true\n\t\tthis.packr = options.packr || new _pack_js__WEBPACK_IMPORTED_MODULE_1__.Packr(options)\n\t}\n\t_transform(value, encoding, callback) {\n\t\tthis.push(this.packr.pack(value))\n\t\tcallback()\n\t}\n}\n\nclass UnpackrStream extends stream__WEBPACK_IMPORTED_MODULE_0__.Transform {\n\tconstructor(options) {\n\t\tif (!options)\n\t\t\toptions = {}\n\t\toptions.objectMode = true\n\t\tsuper(options)\n\t\toptions.structures = []\n\t\tthis.unpackr = options.unpackr || new _unpack_js__WEBPACK_IMPORTED_MODULE_2__.Unpackr(options)\n\t}\n\t_transform(chunk, encoding, callback) {\n\t\tif (this.incompleteBuffer) {\n\t\t\tchunk = Buffer.concat([this.incompleteBuffer, chunk])\n\t\t\tthis.incompleteBuffer = null\n\t\t}\n\t\tlet values\n\t\ttry {\n\t\t\tvalues = this.unpackr.unpackMultiple(chunk)\n\t\t} catch(error) {\n\t\t\tif (error.incomplete) {\n\t\t\t\tthis.incompleteBuffer = chunk.slice(error.lastPosition)\n\t\t\t\tvalues = error.values\n\t\t\t}\n\t\t\telse\n\t\t\t\tthrow error\n\t\t} finally {\n\t\t\tfor (let value of values || []) {\n\t\t\t\tif (value === null)\n\t\t\t\t\tvalue = this.getNullValue()\n\t\t\t\tthis.push(value)\n\t\t\t}\n\t\t}\n\t\tif (callback) callback()\n\t}\n\tgetNullValue() {\n\t\treturn Symbol.for(null)\n\t}\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvbXNncGFja3Ivc3RyZWFtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQWtDO0FBQ0Q7QUFDSTtBQUNyQyx1QkFBdUI7O0FBRWhCLDBCQUEwQiw2Q0FBUztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsMkNBQUs7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPLDRCQUE0Qiw2Q0FBUztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsK0NBQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWxhbi9EZXNrdG9wL0FwcHMvYmV0dGVyLWF1dGgvbm9kZV9tb2R1bGVzL21zZ3BhY2tyL3N0cmVhbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUcmFuc2Zvcm0gfSBmcm9tICdzdHJlYW0nXG5pbXBvcnQgeyBQYWNrciB9IGZyb20gJy4vcGFjay5qcydcbmltcG9ydCB7IFVucGFja3IgfSBmcm9tICcuL3VucGFjay5qcydcbnZhciBERUZBVUxUX09QVElPTlMgPSB7b2JqZWN0TW9kZTogdHJ1ZX1cblxuZXhwb3J0IGNsYXNzIFBhY2tyU3RyZWFtIGV4dGVuZHMgVHJhbnNmb3JtIHtcblx0Y29uc3RydWN0b3Iob3B0aW9ucykge1xuXHRcdGlmICghb3B0aW9ucylcblx0XHRcdG9wdGlvbnMgPSB7fVxuXHRcdG9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlID0gdHJ1ZVxuXHRcdHN1cGVyKG9wdGlvbnMpXG5cdFx0b3B0aW9ucy5zZXF1ZW50aWFsID0gdHJ1ZVxuXHRcdHRoaXMucGFja3IgPSBvcHRpb25zLnBhY2tyIHx8IG5ldyBQYWNrcihvcHRpb25zKVxuXHR9XG5cdF90cmFuc2Zvcm0odmFsdWUsIGVuY29kaW5nLCBjYWxsYmFjaykge1xuXHRcdHRoaXMucHVzaCh0aGlzLnBhY2tyLnBhY2sodmFsdWUpKVxuXHRcdGNhbGxiYWNrKClcblx0fVxufVxuXG5leHBvcnQgY2xhc3MgVW5wYWNrclN0cmVhbSBleHRlbmRzIFRyYW5zZm9ybSB7XG5cdGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcblx0XHRpZiAoIW9wdGlvbnMpXG5cdFx0XHRvcHRpb25zID0ge31cblx0XHRvcHRpb25zLm9iamVjdE1vZGUgPSB0cnVlXG5cdFx0c3VwZXIob3B0aW9ucylcblx0XHRvcHRpb25zLnN0cnVjdHVyZXMgPSBbXVxuXHRcdHRoaXMudW5wYWNrciA9IG9wdGlvbnMudW5wYWNrciB8fCBuZXcgVW5wYWNrcihvcHRpb25zKVxuXHR9XG5cdF90cmFuc2Zvcm0oY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuXHRcdGlmICh0aGlzLmluY29tcGxldGVCdWZmZXIpIHtcblx0XHRcdGNodW5rID0gQnVmZmVyLmNvbmNhdChbdGhpcy5pbmNvbXBsZXRlQnVmZmVyLCBjaHVua10pXG5cdFx0XHR0aGlzLmluY29tcGxldGVCdWZmZXIgPSBudWxsXG5cdFx0fVxuXHRcdGxldCB2YWx1ZXNcblx0XHR0cnkge1xuXHRcdFx0dmFsdWVzID0gdGhpcy51bnBhY2tyLnVucGFja011bHRpcGxlKGNodW5rKVxuXHRcdH0gY2F0Y2goZXJyb3IpIHtcblx0XHRcdGlmIChlcnJvci5pbmNvbXBsZXRlKSB7XG5cdFx0XHRcdHRoaXMuaW5jb21wbGV0ZUJ1ZmZlciA9IGNodW5rLnNsaWNlKGVycm9yLmxhc3RQb3NpdGlvbilcblx0XHRcdFx0dmFsdWVzID0gZXJyb3IudmFsdWVzXG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHRcdHRocm93IGVycm9yXG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdGZvciAobGV0IHZhbHVlIG9mIHZhbHVlcyB8fCBbXSkge1xuXHRcdFx0XHRpZiAodmFsdWUgPT09IG51bGwpXG5cdFx0XHRcdFx0dmFsdWUgPSB0aGlzLmdldE51bGxWYWx1ZSgpXG5cdFx0XHRcdHRoaXMucHVzaCh2YWx1ZSlcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKGNhbGxiYWNrKSBjYWxsYmFjaygpXG5cdH1cblx0Z2V0TnVsbFZhbHVlKCkge1xuXHRcdHJldHVybiBTeW1ib2wuZm9yKG51bGwpXG5cdH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/../../node_modules/msgpackr/stream.js\n");

/***/ }),

/***/ "(action-browser)/../../node_modules/msgpackr/struct.js":
/*!*********************************************!*\
  !*** ../../node_modules/msgpackr/struct.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _pack_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pack.js */ \"(action-browser)/../../node_modules/msgpackr/pack.js\");\n/* harmony import */ var _unpack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./unpack.js */ \"(action-browser)/../../node_modules/msgpackr/unpack.js\");\n\n/*\n\nFor \"any-data\":\n32-55 - record with record ids (-32)\n56 - 8-bit record ids\n57 - 16-bit record ids\n58 - 24-bit record ids\n59 - 32-bit record ids\n250-255 - followed by typed fixed width values\n64-250 msgpackr/cbor/paired data\narrays and strings within arrays are handled by paired encoding\n\nStructure encoding:\n(type - string (using paired encoding))+\n\nType encoding\nencoding byte - fixed width byte - next reference+\n\nEncoding byte:\nfirst bit:\n\t0 - inline\n\t1 - reference\nsecond bit:\n\t0 - data or number\n\t1 - string\n\nremaining bits:\n\tcharacter encoding - ISO-8859-x\n\n\nnull (0xff)+ 0xf6\nnull (0xff)+ 0xf7\n\n*/\n\n\n\n\nconst ASCII = 3; // the MIBenum from https://www.iana.org/assignments/character-sets/character-sets.xhtml (and other character encodings could be referenced by MIBenum)\nconst NUMBER = 0;\nconst UTF8 = 2;\nconst OBJECT_DATA = 1;\nconst DATE = 16;\nconst TYPE_NAMES = ['num', 'object', 'string', 'ascii'];\nTYPE_NAMES[DATE] = 'date';\nconst float32Headers = [false, true, true, false, false, true, true, false];\nlet evalSupported;\ntry {\n\tnew Function('');\n\tevalSupported = true;\n} catch(error) {\n\t// if eval variants are not supported, do not create inline object readers ever\n}\n\nlet updatedPosition;\nconst hasNodeBuffer = typeof Buffer !== 'undefined'\nlet textEncoder, currentSource;\ntry {\n\ttextEncoder = new TextEncoder()\n} catch (error) {}\nconst encodeUtf8 = hasNodeBuffer ? function(target, string, position) {\n\treturn target.utf8Write(string, position, target.byteLength - position)\n} : (textEncoder && textEncoder.encodeInto) ?\n\tfunction(target, string, position) {\n\t\treturn textEncoder.encodeInto(string, target.subarray(position)).written\n\t} : false\n\nconst TYPE = Symbol('type');\nconst PARENT = Symbol('parent');\n(0,_pack_js__WEBPACK_IMPORTED_MODULE_0__.setWriteStructSlots)(writeStruct, prepareStructures);\nfunction writeStruct(object, target, encodingStart, position, structures, makeRoom, pack, packr) {\n\tlet typedStructs = packr.typedStructs || (packr.typedStructs = []);\n\t// note that we rely on pack.js to load stored structures before we get to this point\n\tlet targetView = target.dataView;\n\tlet refsStartPosition = (typedStructs.lastStringStart || 100) + position;\n\tlet safeEnd = target.length - 10;\n\tlet start = position;\n\tif (position > safeEnd) {\n\t\ttarget = makeRoom(position);\n\t\ttargetView = target.dataView;\n\t\tposition -= encodingStart;\n\t\tstart -= encodingStart;\n\t\trefsStartPosition -= encodingStart;\n\t\tencodingStart = 0;\n\t\tsafeEnd = target.length - 10;\n\t}\n\n\tlet refOffset, refPosition = refsStartPosition;\n\n\tlet transition = typedStructs.transitions || (typedStructs.transitions = Object.create(null));\n\tlet nextId = typedStructs.nextId || typedStructs.length;\n\tlet headerSize =\n\t\tnextId < 0xf ? 1 :\n\t\t\tnextId < 0xf0 ? 2 :\n\t\t\t\tnextId < 0xf000 ? 3 :\n\t\t\t\t\tnextId < 0xf00000 ? 4 : 0;\n\tif (headerSize === 0)\n\t\treturn 0;\n\tposition += headerSize;\n\tlet queuedReferences = [];\n\tlet usedAscii0;\n\tlet keyIndex = 0;\n\tfor (let key in object) {\n\t\tlet value = object[key];\n\t\tlet nextTransition = transition[key];\n\t\tif (!nextTransition) {\n\t\t\ttransition[key] = nextTransition = {\n\t\t\t\tkey,\n\t\t\t\tparent: transition,\n\t\t\t\tenumerationOffset: 0,\n\t\t\t\tascii0: null,\n\t\t\t\tascii8: null,\n\t\t\t\tnum8: null,\n\t\t\t\tstring16: null,\n\t\t\t\tobject16: null,\n\t\t\t\tnum32: null,\n\t\t\t\tfloat64: null,\n\t\t\t\tdate64: null\n\t\t\t};\n\t\t}\n\t\tif (position > safeEnd) {\n\t\t\ttarget = makeRoom(position);\n\t\t\ttargetView = target.dataView;\n\t\t\tposition -= encodingStart;\n\t\t\tstart -= encodingStart;\n\t\t\trefsStartPosition -= encodingStart;\n\t\t\trefPosition -= encodingStart;\n\t\t\tencodingStart = 0;\n\t\t\tsafeEnd = target.length - 10\n\t\t}\n\t\tswitch (typeof value) {\n\t\t\tcase 'number':\n\t\t\t\tlet number = value;\n\t\t\t\t// first check to see if we are using a lot of ids and should default to wide/common format\n\t\t\t\tif (nextId < 200 || !nextTransition.num64) {\n\t\t\t\t\tif (number >> 0 === number && number < 0x20000000 && number > -0x1f000000) {\n\t\t\t\t\t\tif (number < 0xf6 && number >= 0 && (nextTransition.num8 && !(nextId > 200 && nextTransition.num32) || number < 0x20 && !nextTransition.num32)) {\n\t\t\t\t\t\t\ttransition = nextTransition.num8 || createTypeTransition(nextTransition, NUMBER, 1);\n\t\t\t\t\t\t\ttarget[position++] = number;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttransition = nextTransition.num32 || createTypeTransition(nextTransition, NUMBER, 4);\n\t\t\t\t\t\t\ttargetView.setUint32(position, number, true);\n\t\t\t\t\t\t\tposition += 4;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (number < 0x100000000 && number >= -0x80000000) {\n\t\t\t\t\t\ttargetView.setFloat32(position, number, true);\n\t\t\t\t\t\tif (float32Headers[target[position + 3] >>> 5]) {\n\t\t\t\t\t\t\tlet xShifted\n\t\t\t\t\t\t\t// this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\t\tif (((xShifted = number * _unpack_js__WEBPACK_IMPORTED_MODULE_1__.mult10[((target[position + 3] & 0x7f) << 1) | (target[position + 2] >> 7)]) >> 0) === xShifted) {\n\t\t\t\t\t\t\t\ttransition = nextTransition.num32 || createTypeTransition(nextTransition, NUMBER, 4);\n\t\t\t\t\t\t\t\tposition += 4;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttransition = nextTransition.num64 || createTypeTransition(nextTransition, NUMBER, 8);\n\t\t\t\ttargetView.setFloat64(position, number, true);\n\t\t\t\tposition += 8;\n\t\t\t\tbreak;\n\t\t\tcase 'string':\n\t\t\t\tlet strLength = value.length;\n\t\t\t\trefOffset = refPosition - refsStartPosition;\n\t\t\t\tif ((strLength << 2) + refPosition > safeEnd) {\n\t\t\t\t\ttarget = makeRoom((strLength << 2) + refPosition);\n\t\t\t\t\ttargetView = target.dataView;\n\t\t\t\t\tposition -= encodingStart;\n\t\t\t\t\tstart -= encodingStart;\n\t\t\t\t\trefsStartPosition -= encodingStart;\n\t\t\t\t\trefPosition -= encodingStart;\n\t\t\t\t\tencodingStart = 0;\n\t\t\t\t\tsafeEnd = target.length - 10\n\t\t\t\t}\n\t\t\t\tif (strLength > ((0xff00 + refOffset) >> 2)) {\n\t\t\t\t\tqueuedReferences.push(key, value, position - start);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlet isNotAscii\n\t\t\t\tlet strStart = refPosition;\n\t\t\t\tif (strLength < 0x40) {\n\t\t\t\t\tlet i, c1, c2;\n\t\t\t\t\tfor (i = 0; i < strLength; i++) {\n\t\t\t\t\t\tc1 = value.charCodeAt(i)\n\t\t\t\t\t\tif (c1 < 0x80) {\n\t\t\t\t\t\t\ttarget[refPosition++] = c1\n\t\t\t\t\t\t} else if (c1 < 0x800) {\n\t\t\t\t\t\t\tisNotAscii = true;\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 >> 6 | 0xc0\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t(c1 & 0xfc00) === 0xd800 &&\n\t\t\t\t\t\t\t((c2 = value.charCodeAt(i + 1)) & 0xfc00) === 0xdc00\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tisNotAscii = true;\n\t\t\t\t\t\t\tc1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff)\n\t\t\t\t\t\t\ti++\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 >> 18 | 0xf0\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 >> 12 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tisNotAscii = true;\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 >> 12 | 0xe0\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\trefPosition += encodeUtf8(target, value, refPosition);\n\t\t\t\t\tisNotAscii = refPosition - strStart > strLength;\n\t\t\t\t}\n\t\t\t\tif (refOffset < 0xa0 || (refOffset < 0xf6 && (nextTransition.ascii8 || nextTransition.string8))) {\n\t\t\t\t\t// short strings\n\t\t\t\t\tif (isNotAscii) {\n\t\t\t\t\t\tif (!(transition = nextTransition.string8)) {\n\t\t\t\t\t\t\tif (typedStructs.length > 10 && (transition = nextTransition.ascii8)) {\n\t\t\t\t\t\t\t\t// we can safely change ascii to utf8 in place since they are compatible\n\t\t\t\t\t\t\t\ttransition.__type = UTF8;\n\t\t\t\t\t\t\t\tnextTransition.ascii8 = null;\n\t\t\t\t\t\t\t\tnextTransition.string8 = transition;\n\t\t\t\t\t\t\t\tpack(null, 0, true); // special call to notify that structures have been updated\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttransition = createTypeTransition(nextTransition, UTF8, 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (refOffset === 0 && !usedAscii0) {\n\t\t\t\t\t\tusedAscii0 = true;\n\t\t\t\t\t\ttransition = nextTransition.ascii0 || createTypeTransition(nextTransition, ASCII, 0);\n\t\t\t\t\t\tbreak; // don't increment position\n\t\t\t\t\t}// else ascii:\n\t\t\t\t\telse if (!(transition = nextTransition.ascii8) && !(typedStructs.length > 10 && (transition = nextTransition.string8)))\n\t\t\t\t\t\ttransition = createTypeTransition(nextTransition, ASCII, 1);\n\t\t\t\t\ttarget[position++] = refOffset;\n\t\t\t\t} else {\n\t\t\t\t\t// TODO: Enable ascii16 at some point, but get the logic right\n\t\t\t\t\t//if (isNotAscii)\n\t\t\t\t\t\ttransition = nextTransition.string16 || createTypeTransition(nextTransition, UTF8, 2);\n\t\t\t\t\t//else\n\t\t\t\t\t\t//transition = nextTransition.ascii16 || createTypeTransition(nextTransition, ASCII, 2);\n\t\t\t\t\ttargetView.setUint16(position, refOffset, true);\n\t\t\t\t\tposition += 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'object':\n\t\t\t\tif (value) {\n\t\t\t\t\tif (value.constructor === Date) {\n\t\t\t\t\t\ttransition = nextTransition.date64 || createTypeTransition(nextTransition, DATE, 8);\n\t\t\t\t\t\ttargetView.setFloat64(position, value.getTime(), true);\n\t\t\t\t\t\tposition += 8;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tqueuedReferences.push(key, value, keyIndex);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t} else { // null\n\t\t\t\t\tnextTransition = anyType(nextTransition, position, targetView, -10); // match CBOR with this\n\t\t\t\t\tif (nextTransition) {\n\t\t\t\t\t\ttransition = nextTransition;\n\t\t\t\t\t\tposition = updatedPosition;\n\t\t\t\t\t} else queuedReferences.push(key, value, keyIndex);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'boolean':\n\t\t\t\ttransition = nextTransition.num8 || nextTransition.ascii8 || createTypeTransition(nextTransition, NUMBER, 1);\n\t\t\t\ttarget[position++] = value ? 0xf9 : 0xf8; // match CBOR with these\n\t\t\t\tbreak;\n\t\t\tcase 'undefined':\n\t\t\t\tnextTransition = anyType(nextTransition, position, targetView, -9); // match CBOR with this\n\t\t\t\tif (nextTransition) {\n\t\t\t\t\ttransition = nextTransition;\n\t\t\t\t\tposition = updatedPosition;\n\t\t\t\t} else queuedReferences.push(key, value, keyIndex);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tqueuedReferences.push(key, value, keyIndex);\n\t\t}\n\t\tkeyIndex++;\n\t}\n\n\tfor (let i = 0, l = queuedReferences.length; i < l;) {\n\t\tlet key = queuedReferences[i++];\n\t\tlet value = queuedReferences[i++];\n\t\tlet propertyIndex = queuedReferences[i++];\n\t\tlet nextTransition = transition[key];\n\t\tif (!nextTransition) {\n\t\t\ttransition[key] = nextTransition = {\n\t\t\t\tkey,\n\t\t\t\tparent: transition,\n\t\t\t\tenumerationOffset: propertyIndex - keyIndex,\n\t\t\t\tascii0: null,\n\t\t\t\tascii8: null,\n\t\t\t\tnum8: null,\n\t\t\t\tstring16: null,\n\t\t\t\tobject16: null,\n\t\t\t\tnum32: null,\n\t\t\t\tfloat64: null\n\t\t\t};\n\t\t}\n\t\tlet newPosition;\n\t\tif (value) {\n\t\t\t/*if (typeof value === 'string') { // TODO: we could re-enable long strings\n\t\t\t\tif (position + value.length * 3 > safeEnd) {\n\t\t\t\t\ttarget = makeRoom(position + value.length * 3);\n\t\t\t\t\tposition -= start;\n\t\t\t\t\ttargetView = target.dataView;\n\t\t\t\t\tstart = 0;\n\t\t\t\t}\n\t\t\t\tnewPosition = position + target.utf8Write(value, position, 0xffffffff);\n\t\t\t} else { */\n\t\t\tlet size;\n\t\t\trefOffset = refPosition - refsStartPosition;\n\t\t\tif (refOffset < 0xff00) {\n\t\t\t\ttransition = nextTransition.object16;\n\t\t\t\tif (transition)\n\t\t\t\t\tsize = 2;\n\t\t\t\telse if ((transition = nextTransition.object32))\n\t\t\t\t\tsize = 4;\n\t\t\t\telse {\n\t\t\t\t\ttransition = createTypeTransition(nextTransition, OBJECT_DATA, 2);\n\t\t\t\t\tsize = 2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttransition = nextTransition.object32 || createTypeTransition(nextTransition, OBJECT_DATA, 4);\n\t\t\t\tsize = 4;\n\t\t\t}\n\t\t\tnewPosition = pack(value, refPosition);\n\t\t\t//}\n\t\t\tif (typeof newPosition === 'object') {\n\t\t\t\t// re-allocated\n\t\t\t\trefPosition = newPosition.position;\n\t\t\t\ttargetView = newPosition.targetView;\n\t\t\t\ttarget = newPosition.target;\n\t\t\t\trefsStartPosition -= encodingStart;\n\t\t\t\tposition -= encodingStart;\n\t\t\t\tstart -= encodingStart;\n\t\t\t\tencodingStart = 0;\n\t\t\t} else\n\t\t\t\trefPosition = newPosition;\n\t\t\tif (size === 2) {\n\t\t\t\ttargetView.setUint16(position, refOffset, true);\n\t\t\t\tposition += 2;\n\t\t\t} else {\n\t\t\t\ttargetView.setUint32(position, refOffset, true);\n\t\t\t\tposition += 4;\n\t\t\t}\n\t\t} else { // null or undefined\n\t\t\ttransition = nextTransition.object16 || createTypeTransition(nextTransition, OBJECT_DATA, 2);\n\t\t\ttargetView.setInt16(position, value === null ? -10 : -9, true);\n\t\t\tposition += 2;\n\t\t}\n\t\tkeyIndex++;\n\t}\n\n\n\tlet recordId = transition[_pack_js__WEBPACK_IMPORTED_MODULE_0__.RECORD_SYMBOL];\n\tif (recordId == null) {\n\t\trecordId = packr.typedStructs.length;\n\t\tlet structure = [];\n\t\tlet nextTransition = transition;\n\t\tlet key, type;\n\t\twhile ((type = nextTransition.__type) !== undefined) {\n\t\t\tlet size = nextTransition.__size;\n\t\t\tnextTransition = nextTransition.__parent;\n\t\t\tkey = nextTransition.key;\n\t\t\tlet property = [type, size, key];\n\t\t\tif (nextTransition.enumerationOffset)\n\t\t\t\tproperty.push(nextTransition.enumerationOffset);\n\t\t\tstructure.push(property);\n\t\t\tnextTransition = nextTransition.parent;\n\t\t}\n\t\tstructure.reverse();\n\t\ttransition[_pack_js__WEBPACK_IMPORTED_MODULE_0__.RECORD_SYMBOL] = recordId;\n\t\tpackr.typedStructs[recordId] = structure;\n\t\tpack(null, 0, true); // special call to notify that structures have been updated\n\t}\n\n\n\tswitch (headerSize) {\n\t\tcase 1:\n\t\t\tif (recordId >= 0x10) return 0;\n\t\t\ttarget[start] = recordId + 0x20;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (recordId >= 0x100) return 0;\n\t\t\ttarget[start] = 0x38;\n\t\t\ttarget[start + 1] = recordId;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (recordId >= 0x10000) return 0;\n\t\t\ttarget[start] = 0x39;\n\t\t\ttargetView.setUint16(start + 1, recordId, true);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tif (recordId >= 0x1000000) return 0;\n\t\t\ttargetView.setUint32(start, (recordId << 8) + 0x3a, true);\n\t\t\tbreak;\n\t}\n\n\tif (position < refsStartPosition) {\n\t\tif (refsStartPosition === refPosition)\n\t\t\treturn position; // no refs\n\t\t// adjust positioning\n\t\ttarget.copyWithin(position, refsStartPosition, refPosition);\n\t\trefPosition += position - refsStartPosition;\n\t\ttypedStructs.lastStringStart = position - start;\n\t} else if (position > refsStartPosition) {\n\t\tif (refsStartPosition === refPosition)\n\t\t\treturn position; // no refs\n\t\ttypedStructs.lastStringStart = position - start;\n\t\treturn writeStruct(object, target, encodingStart, start, structures, makeRoom, pack, packr);\n\t}\n\treturn refPosition;\n}\nfunction anyType(transition, position, targetView, value) {\n\tlet nextTransition;\n\tif ((nextTransition = transition.ascii8 || transition.num8)) {\n\t\ttargetView.setInt8(position, value, true);\n\t\tupdatedPosition = position + 1;\n\t\treturn nextTransition;\n\t}\n\tif ((nextTransition = transition.string16 || transition.object16)) {\n\t\ttargetView.setInt16(position, value, true);\n\t\tupdatedPosition = position + 2;\n\t\treturn nextTransition;\n\t}\n\tif (nextTransition = transition.num32) {\n\t\ttargetView.setUint32(position, 0xe0000100 + value, true);\n\t\tupdatedPosition = position + 4;\n\t\treturn nextTransition;\n\t}\n\t// transition.float64\n\tif (nextTransition = transition.num64) {\n\t\ttargetView.setFloat64(position, NaN, true);\n\t\ttargetView.setInt8(position, value);\n\t\tupdatedPosition = position + 8;\n\t\treturn nextTransition;\n\t}\n\tupdatedPosition = position;\n\t// TODO: can we do an \"any\" type where we defer the decision?\n\treturn;\n}\nfunction createTypeTransition(transition, type, size) {\n\tlet typeName = TYPE_NAMES[type] + (size << 3);\n\tlet newTransition = transition[typeName] || (transition[typeName] = Object.create(null));\n\tnewTransition.__type = type;\n\tnewTransition.__size = size;\n\tnewTransition.__parent = transition;\n\treturn newTransition;\n}\nfunction onLoadedStructures(sharedData) {\n\tif (!(sharedData instanceof Map))\n\t\treturn sharedData;\n\tlet typed = sharedData.get('typed') || [];\n\tif (Object.isFrozen(typed))\n\t\ttyped = typed.map(structure => structure.slice(0));\n\tlet named = sharedData.get('named');\n\tlet transitions = Object.create(null);\n\tfor (let i = 0, l = typed.length; i < l; i++) {\n\t\tlet structure = typed[i];\n\t\tlet transition = transitions;\n\t\tfor (let [type, size, key] of structure) {\n\t\t\tlet nextTransition = transition[key];\n\t\t\tif (!nextTransition) {\n\t\t\t\ttransition[key] = nextTransition = {\n\t\t\t\t\tkey,\n\t\t\t\t\tparent: transition,\n\t\t\t\t\tenumerationOffset: 0,\n\t\t\t\t\tascii0: null,\n\t\t\t\t\tascii8: null,\n\t\t\t\t\tnum8: null,\n\t\t\t\t\tstring16: null,\n\t\t\t\t\tobject16: null,\n\t\t\t\t\tnum32: null,\n\t\t\t\t\tfloat64: null,\n\t\t\t\t\tdate64: null,\n\t\t\t\t};\n\t\t\t}\n\t\t\ttransition = createTypeTransition(nextTransition, type, size);\n\t\t}\n\t\ttransition[_pack_js__WEBPACK_IMPORTED_MODULE_0__.RECORD_SYMBOL] = i;\n\t}\n\ttyped.transitions = transitions;\n\tthis.typedStructs = typed;\n\tthis.lastTypedStructuresLength = typed.length;\n\treturn named;\n}\nvar sourceSymbol = Symbol.for('source')\nfunction readStruct(src, position, srcEnd, unpackr) {\n\tlet recordId = src[position++] - 0x20;\n\tif (recordId >= 24) {\n\t\tswitch(recordId) {\n\t\t\tcase 24: recordId = src[position++]; break;\n\t\t\t// little endian:\n\t\t\tcase 25: recordId = src[position++] + (src[position++] << 8); break;\n\t\t\tcase 26: recordId = src[position++] + (src[position++] << 8) + (src[position++] << 16); break;\n\t\t\tcase 27: recordId = src[position++] + (src[position++] << 8) + (src[position++] << 16) + (src[position++] << 24); break;\n\t\t}\n\t}\n\tlet structure = unpackr.typedStructs && unpackr.typedStructs[recordId];\n\tif (!structure) {\n\t\t// copy src buffer because getStructures will override it\n\t\tsrc = Uint8Array.prototype.slice.call(src, position, srcEnd);\n\t\tsrcEnd -= position;\n\t\tposition = 0;\n\t\tif (!unpackr.getStructures)\n\t\t\tthrow new Error(`Reference to shared structure ${recordId} without getStructures method`);\n\t\tunpackr._mergeStructures(unpackr.getStructures());\n\t\tif (!unpackr.typedStructs)\n\t\t\tthrow new Error('Could not find any shared typed structures');\n\t\tunpackr.lastTypedStructuresLength = unpackr.typedStructs.length;\n\t\tstructure = unpackr.typedStructs[recordId];\n\t\tif (!structure)\n\t\t\tthrow new Error('Could not find typed structure ' + recordId);\n\t}\n\tvar construct = structure.construct;\n\tvar fullConstruct = structure.fullConstruct;\n\tif (!construct) {\n\t\tconstruct = structure.construct = function LazyObject() {\n\t\t}\n\t\tfullConstruct = structure.fullConstruct = function LoadedObject() {\n\t\t}\n\t\tfullConstruct.prototype = unpackr.structPrototype || {};\n\t\tvar prototype = construct.prototype = unpackr.structPrototype ? Object.create(unpackr.structPrototype) : {};\n\t\tlet properties = [];\n\t\tlet currentOffset = 0;\n\t\tlet lastRefProperty;\n\t\tfor (let i = 0, l = structure.length; i < l; i++) {\n\t\t\tlet definition = structure[i];\n\t\t\tlet [ type, size, key, enumerationOffset ] = definition;\n\t\t\tif (key === '__proto__')\n\t\t\t\tkey = '__proto_';\n\t\t\tlet property = {\n\t\t\t\tkey,\n\t\t\t\toffset: currentOffset,\n\t\t\t}\n\t\t\tif (enumerationOffset)\n\t\t\t\tproperties.splice(i + enumerationOffset, 0, property);\n\t\t\telse\n\t\t\t\tproperties.push(property);\n\t\t\tlet getRef;\n\t\t\tswitch(size) { // TODO: Move into a separate function\n\t\t\t\tcase 0: getRef = () => 0; break;\n\t\t\t\tcase 1:\n\t\t\t\t\tgetRef = (source, position) => {\n\t\t\t\t\t\tlet ref = source.bytes[position + property.offset];\n\t\t\t\t\t\treturn ref >= 0xf6 ? toConstant(ref) : ref;\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tgetRef = (source, position) => {\n\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\tlet dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n\t\t\t\t\t\tlet ref = dataView.getUint16(position + property.offset, true);\n\t\t\t\t\t\treturn ref >= 0xff00 ? toConstant(ref & 0xff) : ref;\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tgetRef = (source, position) => {\n\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\tlet dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n\t\t\t\t\t\tlet ref = dataView.getUint32(position + property.offset, true);\n\t\t\t\t\t\treturn ref >= 0xffffff00 ? toConstant(ref & 0xff) : ref;\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tproperty.getRef = getRef;\n\t\t\tcurrentOffset += size;\n\t\t\tlet get;\n\t\t\tswitch(type) {\n\t\t\t\tcase ASCII:\n\t\t\t\t\tif (lastRefProperty && !lastRefProperty.next)\n\t\t\t\t\t\tlastRefProperty.next = property;\n\t\t\t\t\tlastRefProperty = property;\n\t\t\t\t\tproperty.multiGetCount = 0;\n\t\t\t\t\tget = function(source) {\n\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\tlet position = source.position;\n\t\t\t\t\t\tlet refStart = currentOffset + position;\n\t\t\t\t\t\tlet ref = getRef(source, position);\n\t\t\t\t\t\tif (typeof ref !== 'number') return ref;\n\n\t\t\t\t\t\tlet end, next = property.next;\n\t\t\t\t\t\twhile(next) {\n\t\t\t\t\t\t\tend = next.getRef(source, position);\n\t\t\t\t\t\t\tif (typeof end === 'number')\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tend = null;\n\t\t\t\t\t\t\tnext = next.next;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (end == null)\n\t\t\t\t\t\t\tend = source.bytesEnd - refStart;\n\t\t\t\t\t\tif (source.srcString) {\n\t\t\t\t\t\t\treturn source.srcString.slice(ref, end);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/*if (property.multiGetCount > 0) {\n\t\t\t\t\t\t\tlet asciiEnd;\n\t\t\t\t\t\t\tnext = firstRefProperty;\n\t\t\t\t\t\t\tlet dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\tasciiEnd = dataView.getUint16(source.position + next.offset, true);\n\t\t\t\t\t\t\t\tif (asciiEnd < 0xff00)\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tasciiEnd = null;\n\t\t\t\t\t\t\t} while((next = next.next));\n\t\t\t\t\t\t\tif (asciiEnd == null)\n\t\t\t\t\t\t\t\tasciiEnd = source.bytesEnd - refStart\n\t\t\t\t\t\t\tsource.srcString = src.toString('latin1', refStart, refStart + asciiEnd);\n\t\t\t\t\t\t\treturn source.srcString.slice(ref, end);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (source.prevStringGet) {\n\t\t\t\t\t\t\tsource.prevStringGet.multiGetCount += 2;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsource.prevStringGet = property;\n\t\t\t\t\t\t\tproperty.multiGetCount--;\n\t\t\t\t\t\t}*/\n\t\t\t\t\t\treturn (0,_unpack_js__WEBPACK_IMPORTED_MODULE_1__.readString)(src, ref + refStart, end - ref);\n\t\t\t\t\t\t//return src.toString('latin1', ref + refStart, end + refStart);\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\t\t\tcase UTF8: case OBJECT_DATA:\n\t\t\t\t\tif (lastRefProperty && !lastRefProperty.next)\n\t\t\t\t\t\tlastRefProperty.next = property;\n\t\t\t\t\tlastRefProperty = property;\n\t\t\t\t\tget = function(source) {\n\t\t\t\t\t\tlet position = source.position;\n\t\t\t\t\t\tlet refStart = currentOffset + position;\n\t\t\t\t\t\tlet ref = getRef(source, position);\n\t\t\t\t\t\tif (typeof ref !== 'number') return ref;\n\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\tlet end, next = property.next;\n\t\t\t\t\t\twhile(next) {\n\t\t\t\t\t\t\tend = next.getRef(source, position);\n\t\t\t\t\t\t\tif (typeof end === 'number')\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tend = null;\n\t\t\t\t\t\t\tnext = next.next;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (end == null)\n\t\t\t\t\t\t\tend = source.bytesEnd - refStart;\n\t\t\t\t\t\tif (type === UTF8) {\n\t\t\t\t\t\t\treturn src.toString('utf8', ref + refStart, end + refStart);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcurrentSource = source;\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\treturn unpackr.unpack(src, { start: ref + refStart, end: end + refStart });\n\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\tcurrentSource = null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\t\t\tcase NUMBER:\n\t\t\t\t\tswitch(size) {\n\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\tget = function (source) {\n\t\t\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\t\t\tlet dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n\t\t\t\t\t\t\t\tlet position = source.position + property.offset;\n\t\t\t\t\t\t\t\tlet value = dataView.getInt32(position, true)\n\t\t\t\t\t\t\t\tif (value < 0x20000000) {\n\t\t\t\t\t\t\t\t\tif (value > -0x1f000000)\n\t\t\t\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t\t\t\tif (value > -0x20000000)\n\t\t\t\t\t\t\t\t\t\treturn toConstant(value & 0xff);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlet fValue = dataView.getFloat32(position, true);\n\t\t\t\t\t\t\t\t// this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\t\t\tlet multiplier = _unpack_js__WEBPACK_IMPORTED_MODULE_1__.mult10[((src[position + 3] & 0x7f) << 1) | (src[position + 2] >> 7)]\n\t\t\t\t\t\t\t\treturn ((multiplier * fValue + (fValue > 0 ? 0.5 : -0.5)) >> 0) / multiplier;\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 8:\n\t\t\t\t\t\t\tget = function (source) {\n\t\t\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\t\t\tlet dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n\t\t\t\t\t\t\t\tlet value = dataView.getFloat64(source.position + property.offset, true);\n\t\t\t\t\t\t\t\tif (isNaN(value)) {\n\t\t\t\t\t\t\t\t\tlet byte = src[source.position + property.offset];\n\t\t\t\t\t\t\t\t\tif (byte >= 0xf6)\n\t\t\t\t\t\t\t\t\t\treturn toConstant(byte);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tget = function (source) {\n\t\t\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\t\t\tlet value = src[source.position + property.offset];\n\t\t\t\t\t\t\t\treturn value < 0xf6 ? value : toConstant(value);\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase DATE:\n\t\t\t\t\tget = function (source) {\n\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\tlet dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n\t\t\t\t\t\treturn new Date(dataView.getFloat64(source.position + property.offset, true));\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\t\t\tproperty.get = get;\n\t\t}\n\t\t// TODO: load the srcString for faster string decoding on toJSON\n\t\tif (evalSupported) {\n\t\t\tlet objectLiteralProperties = [];\n\t\t\tlet args = [];\n\t\t\tlet i = 0;\n\t\t\tlet hasInheritedProperties;\n\t\t\tfor (let property of properties) { // assign in enumeration order\n\t\t\t\tif (unpackr.alwaysLazyProperty && unpackr.alwaysLazyProperty(property.key)) {\n\t\t\t\t\t// these properties are not eagerly evaluated and this can be used for creating properties\n\t\t\t\t\t// that are not serialized as JSON\n\t\t\t\t\thasInheritedProperties = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tObject.defineProperty(prototype, property.key, { get: withSource(property.get), enumerable: true });\n\t\t\t\tlet valueFunction = 'v' + i++;\n\t\t\t\targs.push(valueFunction);\n\t\t\t\tobjectLiteralProperties.push('o[' + JSON.stringify(property.key) + ']=' + valueFunction + '(s)');\n\t\t\t}\n\t\t\tif (hasInheritedProperties) {\n\t\t\t\tobjectLiteralProperties.push('__proto__:this');\n\t\t\t}\n\t\t\tlet toObject = (new Function(...args, 'var c=this;return function(s){var o=new c();' + objectLiteralProperties.join(';') + ';return o;}')).apply(fullConstruct, properties.map(prop => prop.get));\n\t\t\tObject.defineProperty(prototype, 'toJSON', {\n\t\t\t\tvalue(omitUnderscoredProperties) {\n\t\t\t\t\treturn toObject.call(this, this[sourceSymbol]);\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tObject.defineProperty(prototype, 'toJSON', {\n\t\t\t\tvalue(omitUnderscoredProperties) {\n\t\t\t\t\t// return an enumerable object with own properties to JSON stringify\n\t\t\t\t\tlet resolved = {};\n\t\t\t\t\tfor (let i = 0, l = properties.length; i < l; i++) {\n\t\t\t\t\t\t// TODO: check alwaysLazyProperty\n\t\t\t\t\t\tlet key = properties[i].key;\n\n\t\t\t\t\t\tresolved[key] = this[key];\n\t\t\t\t\t}\n\t\t\t\t\treturn resolved;\n\t\t\t\t},\n\t\t\t\t// not enumerable or anything\n\t\t\t});\n\t\t}\n\t}\n\tvar instance = new construct();\n\tinstance[sourceSymbol] = {\n\t\tbytes: src,\n\t\tposition,\n\t\tsrcString: '',\n\t\tbytesEnd: srcEnd\n\t}\n\treturn instance;\n}\nfunction toConstant(code) {\n\tswitch(code) {\n\t\tcase 0xf6: return null;\n\t\tcase 0xf7: return undefined;\n\t\tcase 0xf8: return false;\n\t\tcase 0xf9: return true;\n\t}\n\tthrow new Error('Unknown constant');\n}\nfunction withSource(get) {\n\treturn function() {\n\t\treturn get(this[sourceSymbol]);\n\t}\n}\n\nfunction saveState() {\n\tif (currentSource) {\n\t\tcurrentSource.bytes = Uint8Array.prototype.slice.call(currentSource.bytes, currentSource.position, currentSource.bytesEnd);\n\t\tcurrentSource.position = 0;\n\t\tcurrentSource.bytesEnd = currentSource.bytes.length;\n\t}\n}\nfunction prepareStructures(structures, packr) {\n\tif (packr.typedStructs) {\n\t\tlet structMap = new Map();\n\t\tstructMap.set('named', structures);\n\t\tstructMap.set('typed', packr.typedStructs);\n\t\tstructures = structMap;\n\t}\n\tlet lastTypedStructuresLength = packr.lastTypedStructuresLength || 0;\n\tstructures.isCompatible = existing => {\n\t\tlet compatible = true;\n\t\tif (existing instanceof Map) {\n\t\t\tlet named = existing.get('named') || [];\n\t\t\tif (named.length !== (packr.lastNamedStructuresLength || 0))\n\t\t\t\tcompatible = false;\n\t\t\tlet typed = existing.get('typed') || [];\n\t\t\tif (typed.length !== lastTypedStructuresLength)\n\t\t\t\tcompatible = false;\n\t\t} else if (existing instanceof Array || Array.isArray(existing)) {\n\t\t\tif (existing.length !== (packr.lastNamedStructuresLength || 0))\n\t\t\t\tcompatible = false;\n\t\t}\n\t\tif (!compatible)\n\t\t\tpackr._mergeStructures(existing);\n\t\treturn compatible;\n\t};\n\tpackr.lastTypedStructuresLength = packr.typedStructs && packr.typedStructs.length;\n\treturn structures;\n}\n\n(0,_unpack_js__WEBPACK_IMPORTED_MODULE_1__.setReadStruct)(readStruct, onLoadedStructures, saveState);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvbXNncGFja3Ivc3RydWN0LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7OztBQUcwRTtBQUNaO0FBQzlELGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSw2REFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDhDQUFNO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZUFBZTtBQUNoQztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsYUFBYTtBQUNiLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE1BQU0sT0FBTztBQUNiLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDQUE4QyxNQUFNO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLE9BQU87QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxJQUFJLE9BQU87QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLDJCQUEyQixtREFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbURBQWE7QUFDMUI7QUFDQSx1QkFBdUI7QUFDdkI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbURBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBLGlFQUFpRTtBQUNqRSwyRkFBMkY7QUFDM0YscUhBQXFIO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxVQUFVO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQiw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE9BQU87QUFDUCxhQUFhLHNEQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLHFDQUFxQyw0Q0FBNEM7QUFDakYsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw4Q0FBTTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsaURBQWlEO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELG1CQUFtQixjQUFjLG1DQUFtQyxPQUFPLFVBQVU7QUFDMUk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLE9BQU87QUFDbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlEQUFhIiwic291cmNlcyI6WyIvVXNlcnMvbWlsYW4vRGVza3RvcC9BcHBzL2JldHRlci1hdXRoL25vZGVfbW9kdWxlcy9tc2dwYWNrci9zdHJ1Y3QuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuXG5Gb3IgXCJhbnktZGF0YVwiOlxuMzItNTUgLSByZWNvcmQgd2l0aCByZWNvcmQgaWRzICgtMzIpXG41NiAtIDgtYml0IHJlY29yZCBpZHNcbjU3IC0gMTYtYml0IHJlY29yZCBpZHNcbjU4IC0gMjQtYml0IHJlY29yZCBpZHNcbjU5IC0gMzItYml0IHJlY29yZCBpZHNcbjI1MC0yNTUgLSBmb2xsb3dlZCBieSB0eXBlZCBmaXhlZCB3aWR0aCB2YWx1ZXNcbjY0LTI1MCBtc2dwYWNrci9jYm9yL3BhaXJlZCBkYXRhXG5hcnJheXMgYW5kIHN0cmluZ3Mgd2l0aGluIGFycmF5cyBhcmUgaGFuZGxlZCBieSBwYWlyZWQgZW5jb2RpbmdcblxuU3RydWN0dXJlIGVuY29kaW5nOlxuKHR5cGUgLSBzdHJpbmcgKHVzaW5nIHBhaXJlZCBlbmNvZGluZykpK1xuXG5UeXBlIGVuY29kaW5nXG5lbmNvZGluZyBieXRlIC0gZml4ZWQgd2lkdGggYnl0ZSAtIG5leHQgcmVmZXJlbmNlK1xuXG5FbmNvZGluZyBieXRlOlxuZmlyc3QgYml0OlxuXHQwIC0gaW5saW5lXG5cdDEgLSByZWZlcmVuY2VcbnNlY29uZCBiaXQ6XG5cdDAgLSBkYXRhIG9yIG51bWJlclxuXHQxIC0gc3RyaW5nXG5cbnJlbWFpbmluZyBiaXRzOlxuXHRjaGFyYWN0ZXIgZW5jb2RpbmcgLSBJU08tODg1OS14XG5cblxubnVsbCAoMHhmZikrIDB4ZjZcbm51bGwgKDB4ZmYpKyAweGY3XG5cbiovXG5cblxuaW1wb3J0IHtzZXRXcml0ZVN0cnVjdFNsb3RzLCBSRUNPUkRfU1lNQk9MLCBhZGRFeHRlbnNpb259IGZyb20gJy4vcGFjay5qcydcbmltcG9ydCB7c2V0UmVhZFN0cnVjdCwgbXVsdDEwLCByZWFkU3RyaW5nfSBmcm9tICcuL3VucGFjay5qcyc7XG5jb25zdCBBU0NJSSA9IDM7IC8vIHRoZSBNSUJlbnVtIGZyb20gaHR0cHM6Ly93d3cuaWFuYS5vcmcvYXNzaWdubWVudHMvY2hhcmFjdGVyLXNldHMvY2hhcmFjdGVyLXNldHMueGh0bWwgKGFuZCBvdGhlciBjaGFyYWN0ZXIgZW5jb2RpbmdzIGNvdWxkIGJlIHJlZmVyZW5jZWQgYnkgTUlCZW51bSlcbmNvbnN0IE5VTUJFUiA9IDA7XG5jb25zdCBVVEY4ID0gMjtcbmNvbnN0IE9CSkVDVF9EQVRBID0gMTtcbmNvbnN0IERBVEUgPSAxNjtcbmNvbnN0IFRZUEVfTkFNRVMgPSBbJ251bScsICdvYmplY3QnLCAnc3RyaW5nJywgJ2FzY2lpJ107XG5UWVBFX05BTUVTW0RBVEVdID0gJ2RhdGUnO1xuY29uc3QgZmxvYXQzMkhlYWRlcnMgPSBbZmFsc2UsIHRydWUsIHRydWUsIGZhbHNlLCBmYWxzZSwgdHJ1ZSwgdHJ1ZSwgZmFsc2VdO1xubGV0IGV2YWxTdXBwb3J0ZWQ7XG50cnkge1xuXHRuZXcgRnVuY3Rpb24oJycpO1xuXHRldmFsU3VwcG9ydGVkID0gdHJ1ZTtcbn0gY2F0Y2goZXJyb3IpIHtcblx0Ly8gaWYgZXZhbCB2YXJpYW50cyBhcmUgbm90IHN1cHBvcnRlZCwgZG8gbm90IGNyZWF0ZSBpbmxpbmUgb2JqZWN0IHJlYWRlcnMgZXZlclxufVxuXG5sZXQgdXBkYXRlZFBvc2l0aW9uO1xuY29uc3QgaGFzTm9kZUJ1ZmZlciA9IHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnXG5sZXQgdGV4dEVuY29kZXIsIGN1cnJlbnRTb3VyY2U7XG50cnkge1xuXHR0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpXG59IGNhdGNoIChlcnJvcikge31cbmNvbnN0IGVuY29kZVV0ZjggPSBoYXNOb2RlQnVmZmVyID8gZnVuY3Rpb24odGFyZ2V0LCBzdHJpbmcsIHBvc2l0aW9uKSB7XG5cdHJldHVybiB0YXJnZXQudXRmOFdyaXRlKHN0cmluZywgcG9zaXRpb24sIHRhcmdldC5ieXRlTGVuZ3RoIC0gcG9zaXRpb24pXG59IDogKHRleHRFbmNvZGVyICYmIHRleHRFbmNvZGVyLmVuY29kZUludG8pID9cblx0ZnVuY3Rpb24odGFyZ2V0LCBzdHJpbmcsIHBvc2l0aW9uKSB7XG5cdFx0cmV0dXJuIHRleHRFbmNvZGVyLmVuY29kZUludG8oc3RyaW5nLCB0YXJnZXQuc3ViYXJyYXkocG9zaXRpb24pKS53cml0dGVuXG5cdH0gOiBmYWxzZVxuXG5jb25zdCBUWVBFID0gU3ltYm9sKCd0eXBlJyk7XG5jb25zdCBQQVJFTlQgPSBTeW1ib2woJ3BhcmVudCcpO1xuc2V0V3JpdGVTdHJ1Y3RTbG90cyh3cml0ZVN0cnVjdCwgcHJlcGFyZVN0cnVjdHVyZXMpO1xuZnVuY3Rpb24gd3JpdGVTdHJ1Y3Qob2JqZWN0LCB0YXJnZXQsIGVuY29kaW5nU3RhcnQsIHBvc2l0aW9uLCBzdHJ1Y3R1cmVzLCBtYWtlUm9vbSwgcGFjaywgcGFja3IpIHtcblx0bGV0IHR5cGVkU3RydWN0cyA9IHBhY2tyLnR5cGVkU3RydWN0cyB8fCAocGFja3IudHlwZWRTdHJ1Y3RzID0gW10pO1xuXHQvLyBub3RlIHRoYXQgd2UgcmVseSBvbiBwYWNrLmpzIHRvIGxvYWQgc3RvcmVkIHN0cnVjdHVyZXMgYmVmb3JlIHdlIGdldCB0byB0aGlzIHBvaW50XG5cdGxldCB0YXJnZXRWaWV3ID0gdGFyZ2V0LmRhdGFWaWV3O1xuXHRsZXQgcmVmc1N0YXJ0UG9zaXRpb24gPSAodHlwZWRTdHJ1Y3RzLmxhc3RTdHJpbmdTdGFydCB8fCAxMDApICsgcG9zaXRpb247XG5cdGxldCBzYWZlRW5kID0gdGFyZ2V0Lmxlbmd0aCAtIDEwO1xuXHRsZXQgc3RhcnQgPSBwb3NpdGlvbjtcblx0aWYgKHBvc2l0aW9uID4gc2FmZUVuZCkge1xuXHRcdHRhcmdldCA9IG1ha2VSb29tKHBvc2l0aW9uKTtcblx0XHR0YXJnZXRWaWV3ID0gdGFyZ2V0LmRhdGFWaWV3O1xuXHRcdHBvc2l0aW9uIC09IGVuY29kaW5nU3RhcnQ7XG5cdFx0c3RhcnQgLT0gZW5jb2RpbmdTdGFydDtcblx0XHRyZWZzU3RhcnRQb3NpdGlvbiAtPSBlbmNvZGluZ1N0YXJ0O1xuXHRcdGVuY29kaW5nU3RhcnQgPSAwO1xuXHRcdHNhZmVFbmQgPSB0YXJnZXQubGVuZ3RoIC0gMTA7XG5cdH1cblxuXHRsZXQgcmVmT2Zmc2V0LCByZWZQb3NpdGlvbiA9IHJlZnNTdGFydFBvc2l0aW9uO1xuXG5cdGxldCB0cmFuc2l0aW9uID0gdHlwZWRTdHJ1Y3RzLnRyYW5zaXRpb25zIHx8ICh0eXBlZFN0cnVjdHMudHJhbnNpdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpKTtcblx0bGV0IG5leHRJZCA9IHR5cGVkU3RydWN0cy5uZXh0SWQgfHwgdHlwZWRTdHJ1Y3RzLmxlbmd0aDtcblx0bGV0IGhlYWRlclNpemUgPVxuXHRcdG5leHRJZCA8IDB4ZiA/IDEgOlxuXHRcdFx0bmV4dElkIDwgMHhmMCA/IDIgOlxuXHRcdFx0XHRuZXh0SWQgPCAweGYwMDAgPyAzIDpcblx0XHRcdFx0XHRuZXh0SWQgPCAweGYwMDAwMCA/IDQgOiAwO1xuXHRpZiAoaGVhZGVyU2l6ZSA9PT0gMClcblx0XHRyZXR1cm4gMDtcblx0cG9zaXRpb24gKz0gaGVhZGVyU2l6ZTtcblx0bGV0IHF1ZXVlZFJlZmVyZW5jZXMgPSBbXTtcblx0bGV0IHVzZWRBc2NpaTA7XG5cdGxldCBrZXlJbmRleCA9IDA7XG5cdGZvciAobGV0IGtleSBpbiBvYmplY3QpIHtcblx0XHRsZXQgdmFsdWUgPSBvYmplY3Rba2V5XTtcblx0XHRsZXQgbmV4dFRyYW5zaXRpb24gPSB0cmFuc2l0aW9uW2tleV07XG5cdFx0aWYgKCFuZXh0VHJhbnNpdGlvbikge1xuXHRcdFx0dHJhbnNpdGlvbltrZXldID0gbmV4dFRyYW5zaXRpb24gPSB7XG5cdFx0XHRcdGtleSxcblx0XHRcdFx0cGFyZW50OiB0cmFuc2l0aW9uLFxuXHRcdFx0XHRlbnVtZXJhdGlvbk9mZnNldDogMCxcblx0XHRcdFx0YXNjaWkwOiBudWxsLFxuXHRcdFx0XHRhc2NpaTg6IG51bGwsXG5cdFx0XHRcdG51bTg6IG51bGwsXG5cdFx0XHRcdHN0cmluZzE2OiBudWxsLFxuXHRcdFx0XHRvYmplY3QxNjogbnVsbCxcblx0XHRcdFx0bnVtMzI6IG51bGwsXG5cdFx0XHRcdGZsb2F0NjQ6IG51bGwsXG5cdFx0XHRcdGRhdGU2NDogbnVsbFxuXHRcdFx0fTtcblx0XHR9XG5cdFx0aWYgKHBvc2l0aW9uID4gc2FmZUVuZCkge1xuXHRcdFx0dGFyZ2V0ID0gbWFrZVJvb20ocG9zaXRpb24pO1xuXHRcdFx0dGFyZ2V0VmlldyA9IHRhcmdldC5kYXRhVmlldztcblx0XHRcdHBvc2l0aW9uIC09IGVuY29kaW5nU3RhcnQ7XG5cdFx0XHRzdGFydCAtPSBlbmNvZGluZ1N0YXJ0O1xuXHRcdFx0cmVmc1N0YXJ0UG9zaXRpb24gLT0gZW5jb2RpbmdTdGFydDtcblx0XHRcdHJlZlBvc2l0aW9uIC09IGVuY29kaW5nU3RhcnQ7XG5cdFx0XHRlbmNvZGluZ1N0YXJ0ID0gMDtcblx0XHRcdHNhZmVFbmQgPSB0YXJnZXQubGVuZ3RoIC0gMTBcblx0XHR9XG5cdFx0c3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcblx0XHRcdGNhc2UgJ251bWJlcic6XG5cdFx0XHRcdGxldCBudW1iZXIgPSB2YWx1ZTtcblx0XHRcdFx0Ly8gZmlyc3QgY2hlY2sgdG8gc2VlIGlmIHdlIGFyZSB1c2luZyBhIGxvdCBvZiBpZHMgYW5kIHNob3VsZCBkZWZhdWx0IHRvIHdpZGUvY29tbW9uIGZvcm1hdFxuXHRcdFx0XHRpZiAobmV4dElkIDwgMjAwIHx8ICFuZXh0VHJhbnNpdGlvbi5udW02NCkge1xuXHRcdFx0XHRcdGlmIChudW1iZXIgPj4gMCA9PT0gbnVtYmVyICYmIG51bWJlciA8IDB4MjAwMDAwMDAgJiYgbnVtYmVyID4gLTB4MWYwMDAwMDApIHtcblx0XHRcdFx0XHRcdGlmIChudW1iZXIgPCAweGY2ICYmIG51bWJlciA+PSAwICYmIChuZXh0VHJhbnNpdGlvbi5udW04ICYmICEobmV4dElkID4gMjAwICYmIG5leHRUcmFuc2l0aW9uLm51bTMyKSB8fCBudW1iZXIgPCAweDIwICYmICFuZXh0VHJhbnNpdGlvbi5udW0zMikpIHtcblx0XHRcdFx0XHRcdFx0dHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uLm51bTggfHwgY3JlYXRlVHlwZVRyYW5zaXRpb24obmV4dFRyYW5zaXRpb24sIE5VTUJFUiwgMSk7XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IG51bWJlcjtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvbi5udW0zMiB8fCBjcmVhdGVUeXBlVHJhbnNpdGlvbihuZXh0VHJhbnNpdGlvbiwgTlVNQkVSLCA0KTtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRVaW50MzIocG9zaXRpb24sIG51bWJlciwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRcdHBvc2l0aW9uICs9IDQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9IGVsc2UgaWYgKG51bWJlciA8IDB4MTAwMDAwMDAwICYmIG51bWJlciA+PSAtMHg4MDAwMDAwMCkge1xuXHRcdFx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRGbG9hdDMyKHBvc2l0aW9uLCBudW1iZXIsIHRydWUpO1xuXHRcdFx0XHRcdFx0aWYgKGZsb2F0MzJIZWFkZXJzW3RhcmdldFtwb3NpdGlvbiArIDNdID4+PiA1XSkge1xuXHRcdFx0XHRcdFx0XHRsZXQgeFNoaWZ0ZWRcblx0XHRcdFx0XHRcdFx0Ly8gdGhpcyBjaGVja3MgZm9yIHJvdW5kaW5nIG9mIG51bWJlcnMgdGhhdCB3ZXJlIGVuY29kZWQgaW4gMzItYml0IGZsb2F0IHRvIG5lYXJlc3Qgc2lnbmlmaWNhbnQgZGVjaW1hbCBkaWdpdCB0aGF0IGNvdWxkIGJlIHByZXNlcnZlZFxuXHRcdFx0XHRcdFx0XHRpZiAoKCh4U2hpZnRlZCA9IG51bWJlciAqIG11bHQxMFsoKHRhcmdldFtwb3NpdGlvbiArIDNdICYgMHg3ZikgPDwgMSkgfCAodGFyZ2V0W3Bvc2l0aW9uICsgMl0gPj4gNyldKSA+PiAwKSA9PT0geFNoaWZ0ZWQpIHtcblx0XHRcdFx0XHRcdFx0XHR0cmFuc2l0aW9uID0gbmV4dFRyYW5zaXRpb24ubnVtMzIgfHwgY3JlYXRlVHlwZVRyYW5zaXRpb24obmV4dFRyYW5zaXRpb24sIE5VTUJFUiwgNCk7XG5cdFx0XHRcdFx0XHRcdFx0cG9zaXRpb24gKz0gNDtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR0cmFuc2l0aW9uID0gbmV4dFRyYW5zaXRpb24ubnVtNjQgfHwgY3JlYXRlVHlwZVRyYW5zaXRpb24obmV4dFRyYW5zaXRpb24sIE5VTUJFUiwgOCk7XG5cdFx0XHRcdHRhcmdldFZpZXcuc2V0RmxvYXQ2NChwb3NpdGlvbiwgbnVtYmVyLCB0cnVlKTtcblx0XHRcdFx0cG9zaXRpb24gKz0gODtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdzdHJpbmcnOlxuXHRcdFx0XHRsZXQgc3RyTGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuXHRcdFx0XHRyZWZPZmZzZXQgPSByZWZQb3NpdGlvbiAtIHJlZnNTdGFydFBvc2l0aW9uO1xuXHRcdFx0XHRpZiAoKHN0ckxlbmd0aCA8PCAyKSArIHJlZlBvc2l0aW9uID4gc2FmZUVuZCkge1xuXHRcdFx0XHRcdHRhcmdldCA9IG1ha2VSb29tKChzdHJMZW5ndGggPDwgMikgKyByZWZQb3NpdGlvbik7XG5cdFx0XHRcdFx0dGFyZ2V0VmlldyA9IHRhcmdldC5kYXRhVmlldztcblx0XHRcdFx0XHRwb3NpdGlvbiAtPSBlbmNvZGluZ1N0YXJ0O1xuXHRcdFx0XHRcdHN0YXJ0IC09IGVuY29kaW5nU3RhcnQ7XG5cdFx0XHRcdFx0cmVmc1N0YXJ0UG9zaXRpb24gLT0gZW5jb2RpbmdTdGFydDtcblx0XHRcdFx0XHRyZWZQb3NpdGlvbiAtPSBlbmNvZGluZ1N0YXJ0O1xuXHRcdFx0XHRcdGVuY29kaW5nU3RhcnQgPSAwO1xuXHRcdFx0XHRcdHNhZmVFbmQgPSB0YXJnZXQubGVuZ3RoIC0gMTBcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoc3RyTGVuZ3RoID4gKCgweGZmMDAgKyByZWZPZmZzZXQpID4+IDIpKSB7XG5cdFx0XHRcdFx0cXVldWVkUmVmZXJlbmNlcy5wdXNoKGtleSwgdmFsdWUsIHBvc2l0aW9uIC0gc3RhcnQpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxldCBpc05vdEFzY2lpXG5cdFx0XHRcdGxldCBzdHJTdGFydCA9IHJlZlBvc2l0aW9uO1xuXHRcdFx0XHRpZiAoc3RyTGVuZ3RoIDwgMHg0MCkge1xuXHRcdFx0XHRcdGxldCBpLCBjMSwgYzI7XG5cdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IHN0ckxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRjMSA9IHZhbHVlLmNoYXJDb2RlQXQoaSlcblx0XHRcdFx0XHRcdGlmIChjMSA8IDB4ODApIHtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3JlZlBvc2l0aW9uKytdID0gYzFcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoYzEgPCAweDgwMCkge1xuXHRcdFx0XHRcdFx0XHRpc05vdEFzY2lpID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3JlZlBvc2l0aW9uKytdID0gYzEgPj4gNiB8IDB4YzBcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3JlZlBvc2l0aW9uKytdID0gYzEgJiAweDNmIHwgMHg4MFxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChcblx0XHRcdFx0XHRcdFx0KGMxICYgMHhmYzAwKSA9PT0gMHhkODAwICYmXG5cdFx0XHRcdFx0XHRcdCgoYzIgPSB2YWx1ZS5jaGFyQ29kZUF0KGkgKyAxKSkgJiAweGZjMDApID09PSAweGRjMDBcblx0XHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0XHRpc05vdEFzY2lpID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0YzEgPSAweDEwMDAwICsgKChjMSAmIDB4MDNmZikgPDwgMTApICsgKGMyICYgMHgwM2ZmKVxuXHRcdFx0XHRcdFx0XHRpKytcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3JlZlBvc2l0aW9uKytdID0gYzEgPj4gMTggfCAweGYwXG5cdFx0XHRcdFx0XHRcdHRhcmdldFtyZWZQb3NpdGlvbisrXSA9IGMxID4+IDEyICYgMHgzZiB8IDB4ODBcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3JlZlBvc2l0aW9uKytdID0gYzEgPj4gNiAmIDB4M2YgfCAweDgwXG5cdFx0XHRcdFx0XHRcdHRhcmdldFtyZWZQb3NpdGlvbisrXSA9IGMxICYgMHgzZiB8IDB4ODBcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGlzTm90QXNjaWkgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRbcmVmUG9zaXRpb24rK10gPSBjMSA+PiAxMiB8IDB4ZTBcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3JlZlBvc2l0aW9uKytdID0gYzEgPj4gNiAmIDB4M2YgfCAweDgwXG5cdFx0XHRcdFx0XHRcdHRhcmdldFtyZWZQb3NpdGlvbisrXSA9IGMxICYgMHgzZiB8IDB4ODBcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmVmUG9zaXRpb24gKz0gZW5jb2RlVXRmOCh0YXJnZXQsIHZhbHVlLCByZWZQb3NpdGlvbik7XG5cdFx0XHRcdFx0aXNOb3RBc2NpaSA9IHJlZlBvc2l0aW9uIC0gc3RyU3RhcnQgPiBzdHJMZW5ndGg7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHJlZk9mZnNldCA8IDB4YTAgfHwgKHJlZk9mZnNldCA8IDB4ZjYgJiYgKG5leHRUcmFuc2l0aW9uLmFzY2lpOCB8fCBuZXh0VHJhbnNpdGlvbi5zdHJpbmc4KSkpIHtcblx0XHRcdFx0XHQvLyBzaG9ydCBzdHJpbmdzXG5cdFx0XHRcdFx0aWYgKGlzTm90QXNjaWkpIHtcblx0XHRcdFx0XHRcdGlmICghKHRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvbi5zdHJpbmc4KSkge1xuXHRcdFx0XHRcdFx0XHRpZiAodHlwZWRTdHJ1Y3RzLmxlbmd0aCA+IDEwICYmICh0cmFuc2l0aW9uID0gbmV4dFRyYW5zaXRpb24uYXNjaWk4KSkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIHdlIGNhbiBzYWZlbHkgY2hhbmdlIGFzY2lpIHRvIHV0ZjggaW4gcGxhY2Ugc2luY2UgdGhleSBhcmUgY29tcGF0aWJsZVxuXHRcdFx0XHRcdFx0XHRcdHRyYW5zaXRpb24uX190eXBlID0gVVRGODtcblx0XHRcdFx0XHRcdFx0XHRuZXh0VHJhbnNpdGlvbi5hc2NpaTggPSBudWxsO1xuXHRcdFx0XHRcdFx0XHRcdG5leHRUcmFuc2l0aW9uLnN0cmluZzggPSB0cmFuc2l0aW9uO1xuXHRcdFx0XHRcdFx0XHRcdHBhY2sobnVsbCwgMCwgdHJ1ZSk7IC8vIHNwZWNpYWwgY2FsbCB0byBub3RpZnkgdGhhdCBzdHJ1Y3R1cmVzIGhhdmUgYmVlbiB1cGRhdGVkXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dHJhbnNpdGlvbiA9IGNyZWF0ZVR5cGVUcmFuc2l0aW9uKG5leHRUcmFuc2l0aW9uLCBVVEY4LCAxKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAocmVmT2Zmc2V0ID09PSAwICYmICF1c2VkQXNjaWkwKSB7XG5cdFx0XHRcdFx0XHR1c2VkQXNjaWkwID0gdHJ1ZTtcblx0XHRcdFx0XHRcdHRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvbi5hc2NpaTAgfHwgY3JlYXRlVHlwZVRyYW5zaXRpb24obmV4dFRyYW5zaXRpb24sIEFTQ0lJLCAwKTtcblx0XHRcdFx0XHRcdGJyZWFrOyAvLyBkb24ndCBpbmNyZW1lbnQgcG9zaXRpb25cblx0XHRcdFx0XHR9Ly8gZWxzZSBhc2NpaTpcblx0XHRcdFx0XHRlbHNlIGlmICghKHRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvbi5hc2NpaTgpICYmICEodHlwZWRTdHJ1Y3RzLmxlbmd0aCA+IDEwICYmICh0cmFuc2l0aW9uID0gbmV4dFRyYW5zaXRpb24uc3RyaW5nOCkpKVxuXHRcdFx0XHRcdFx0dHJhbnNpdGlvbiA9IGNyZWF0ZVR5cGVUcmFuc2l0aW9uKG5leHRUcmFuc2l0aW9uLCBBU0NJSSwgMSk7XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gcmVmT2Zmc2V0O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIFRPRE86IEVuYWJsZSBhc2NpaTE2IGF0IHNvbWUgcG9pbnQsIGJ1dCBnZXQgdGhlIGxvZ2ljIHJpZ2h0XG5cdFx0XHRcdFx0Ly9pZiAoaXNOb3RBc2NpaSlcblx0XHRcdFx0XHRcdHRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvbi5zdHJpbmcxNiB8fCBjcmVhdGVUeXBlVHJhbnNpdGlvbihuZXh0VHJhbnNpdGlvbiwgVVRGOCwgMik7XG5cdFx0XHRcdFx0Ly9lbHNlXG5cdFx0XHRcdFx0XHQvL3RyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvbi5hc2NpaTE2IHx8IGNyZWF0ZVR5cGVUcmFuc2l0aW9uKG5leHRUcmFuc2l0aW9uLCBBU0NJSSwgMik7XG5cdFx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRVaW50MTYocG9zaXRpb24sIHJlZk9mZnNldCwgdHJ1ZSk7XG5cdFx0XHRcdFx0cG9zaXRpb24gKz0gMjtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ29iamVjdCc6XG5cdFx0XHRcdGlmICh2YWx1ZSkge1xuXHRcdFx0XHRcdGlmICh2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gRGF0ZSkge1xuXHRcdFx0XHRcdFx0dHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uLmRhdGU2NCB8fCBjcmVhdGVUeXBlVHJhbnNpdGlvbihuZXh0VHJhbnNpdGlvbiwgREFURSwgOCk7XG5cdFx0XHRcdFx0XHR0YXJnZXRWaWV3LnNldEZsb2F0NjQocG9zaXRpb24sIHZhbHVlLmdldFRpbWUoKSwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRwb3NpdGlvbiArPSA4O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRxdWV1ZWRSZWZlcmVuY2VzLnB1c2goa2V5LCB2YWx1ZSwga2V5SW5kZXgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fSBlbHNlIHsgLy8gbnVsbFxuXHRcdFx0XHRcdG5leHRUcmFuc2l0aW9uID0gYW55VHlwZShuZXh0VHJhbnNpdGlvbiwgcG9zaXRpb24sIHRhcmdldFZpZXcsIC0xMCk7IC8vIG1hdGNoIENCT1Igd2l0aCB0aGlzXG5cdFx0XHRcdFx0aWYgKG5leHRUcmFuc2l0aW9uKSB7XG5cdFx0XHRcdFx0XHR0cmFuc2l0aW9uID0gbmV4dFRyYW5zaXRpb247XG5cdFx0XHRcdFx0XHRwb3NpdGlvbiA9IHVwZGF0ZWRQb3NpdGlvbjtcblx0XHRcdFx0XHR9IGVsc2UgcXVldWVkUmVmZXJlbmNlcy5wdXNoKGtleSwgdmFsdWUsIGtleUluZGV4KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ2Jvb2xlYW4nOlxuXHRcdFx0XHR0cmFuc2l0aW9uID0gbmV4dFRyYW5zaXRpb24ubnVtOCB8fCBuZXh0VHJhbnNpdGlvbi5hc2NpaTggfHwgY3JlYXRlVHlwZVRyYW5zaXRpb24obmV4dFRyYW5zaXRpb24sIE5VTUJFUiwgMSk7XG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IHZhbHVlID8gMHhmOSA6IDB4Zjg7IC8vIG1hdGNoIENCT1Igd2l0aCB0aGVzZVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3VuZGVmaW5lZCc6XG5cdFx0XHRcdG5leHRUcmFuc2l0aW9uID0gYW55VHlwZShuZXh0VHJhbnNpdGlvbiwgcG9zaXRpb24sIHRhcmdldFZpZXcsIC05KTsgLy8gbWF0Y2ggQ0JPUiB3aXRoIHRoaXNcblx0XHRcdFx0aWYgKG5leHRUcmFuc2l0aW9uKSB7XG5cdFx0XHRcdFx0dHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uO1xuXHRcdFx0XHRcdHBvc2l0aW9uID0gdXBkYXRlZFBvc2l0aW9uO1xuXHRcdFx0XHR9IGVsc2UgcXVldWVkUmVmZXJlbmNlcy5wdXNoKGtleSwgdmFsdWUsIGtleUluZGV4KTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRxdWV1ZWRSZWZlcmVuY2VzLnB1c2goa2V5LCB2YWx1ZSwga2V5SW5kZXgpO1xuXHRcdH1cblx0XHRrZXlJbmRleCsrO1xuXHR9XG5cblx0Zm9yIChsZXQgaSA9IDAsIGwgPSBxdWV1ZWRSZWZlcmVuY2VzLmxlbmd0aDsgaSA8IGw7KSB7XG5cdFx0bGV0IGtleSA9IHF1ZXVlZFJlZmVyZW5jZXNbaSsrXTtcblx0XHRsZXQgdmFsdWUgPSBxdWV1ZWRSZWZlcmVuY2VzW2krK107XG5cdFx0bGV0IHByb3BlcnR5SW5kZXggPSBxdWV1ZWRSZWZlcmVuY2VzW2krK107XG5cdFx0bGV0IG5leHRUcmFuc2l0aW9uID0gdHJhbnNpdGlvbltrZXldO1xuXHRcdGlmICghbmV4dFRyYW5zaXRpb24pIHtcblx0XHRcdHRyYW5zaXRpb25ba2V5XSA9IG5leHRUcmFuc2l0aW9uID0ge1xuXHRcdFx0XHRrZXksXG5cdFx0XHRcdHBhcmVudDogdHJhbnNpdGlvbixcblx0XHRcdFx0ZW51bWVyYXRpb25PZmZzZXQ6IHByb3BlcnR5SW5kZXggLSBrZXlJbmRleCxcblx0XHRcdFx0YXNjaWkwOiBudWxsLFxuXHRcdFx0XHRhc2NpaTg6IG51bGwsXG5cdFx0XHRcdG51bTg6IG51bGwsXG5cdFx0XHRcdHN0cmluZzE2OiBudWxsLFxuXHRcdFx0XHRvYmplY3QxNjogbnVsbCxcblx0XHRcdFx0bnVtMzI6IG51bGwsXG5cdFx0XHRcdGZsb2F0NjQ6IG51bGxcblx0XHRcdH07XG5cdFx0fVxuXHRcdGxldCBuZXdQb3NpdGlvbjtcblx0XHRpZiAodmFsdWUpIHtcblx0XHRcdC8qaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHsgLy8gVE9ETzogd2UgY291bGQgcmUtZW5hYmxlIGxvbmcgc3RyaW5nc1xuXHRcdFx0XHRpZiAocG9zaXRpb24gKyB2YWx1ZS5sZW5ndGggKiAzID4gc2FmZUVuZCkge1xuXHRcdFx0XHRcdHRhcmdldCA9IG1ha2VSb29tKHBvc2l0aW9uICsgdmFsdWUubGVuZ3RoICogMyk7XG5cdFx0XHRcdFx0cG9zaXRpb24gLT0gc3RhcnQ7XG5cdFx0XHRcdFx0dGFyZ2V0VmlldyA9IHRhcmdldC5kYXRhVmlldztcblx0XHRcdFx0XHRzdGFydCA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0bmV3UG9zaXRpb24gPSBwb3NpdGlvbiArIHRhcmdldC51dGY4V3JpdGUodmFsdWUsIHBvc2l0aW9uLCAweGZmZmZmZmZmKTtcblx0XHRcdH0gZWxzZSB7ICovXG5cdFx0XHRsZXQgc2l6ZTtcblx0XHRcdHJlZk9mZnNldCA9IHJlZlBvc2l0aW9uIC0gcmVmc1N0YXJ0UG9zaXRpb247XG5cdFx0XHRpZiAocmVmT2Zmc2V0IDwgMHhmZjAwKSB7XG5cdFx0XHRcdHRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvbi5vYmplY3QxNjtcblx0XHRcdFx0aWYgKHRyYW5zaXRpb24pXG5cdFx0XHRcdFx0c2l6ZSA9IDI7XG5cdFx0XHRcdGVsc2UgaWYgKCh0cmFuc2l0aW9uID0gbmV4dFRyYW5zaXRpb24ub2JqZWN0MzIpKVxuXHRcdFx0XHRcdHNpemUgPSA0O1xuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHR0cmFuc2l0aW9uID0gY3JlYXRlVHlwZVRyYW5zaXRpb24obmV4dFRyYW5zaXRpb24sIE9CSkVDVF9EQVRBLCAyKTtcblx0XHRcdFx0XHRzaXplID0gMjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uLm9iamVjdDMyIHx8IGNyZWF0ZVR5cGVUcmFuc2l0aW9uKG5leHRUcmFuc2l0aW9uLCBPQkpFQ1RfREFUQSwgNCk7XG5cdFx0XHRcdHNpemUgPSA0O1xuXHRcdFx0fVxuXHRcdFx0bmV3UG9zaXRpb24gPSBwYWNrKHZhbHVlLCByZWZQb3NpdGlvbik7XG5cdFx0XHQvL31cblx0XHRcdGlmICh0eXBlb2YgbmV3UG9zaXRpb24gPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdC8vIHJlLWFsbG9jYXRlZFxuXHRcdFx0XHRyZWZQb3NpdGlvbiA9IG5ld1Bvc2l0aW9uLnBvc2l0aW9uO1xuXHRcdFx0XHR0YXJnZXRWaWV3ID0gbmV3UG9zaXRpb24udGFyZ2V0Vmlldztcblx0XHRcdFx0dGFyZ2V0ID0gbmV3UG9zaXRpb24udGFyZ2V0O1xuXHRcdFx0XHRyZWZzU3RhcnRQb3NpdGlvbiAtPSBlbmNvZGluZ1N0YXJ0O1xuXHRcdFx0XHRwb3NpdGlvbiAtPSBlbmNvZGluZ1N0YXJ0O1xuXHRcdFx0XHRzdGFydCAtPSBlbmNvZGluZ1N0YXJ0O1xuXHRcdFx0XHRlbmNvZGluZ1N0YXJ0ID0gMDtcblx0XHRcdH0gZWxzZVxuXHRcdFx0XHRyZWZQb3NpdGlvbiA9IG5ld1Bvc2l0aW9uO1xuXHRcdFx0aWYgKHNpemUgPT09IDIpIHtcblx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRVaW50MTYocG9zaXRpb24sIHJlZk9mZnNldCwgdHJ1ZSk7XG5cdFx0XHRcdHBvc2l0aW9uICs9IDI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0YXJnZXRWaWV3LnNldFVpbnQzMihwb3NpdGlvbiwgcmVmT2Zmc2V0LCB0cnVlKTtcblx0XHRcdFx0cG9zaXRpb24gKz0gNDtcblx0XHRcdH1cblx0XHR9IGVsc2UgeyAvLyBudWxsIG9yIHVuZGVmaW5lZFxuXHRcdFx0dHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uLm9iamVjdDE2IHx8IGNyZWF0ZVR5cGVUcmFuc2l0aW9uKG5leHRUcmFuc2l0aW9uLCBPQkpFQ1RfREFUQSwgMik7XG5cdFx0XHR0YXJnZXRWaWV3LnNldEludDE2KHBvc2l0aW9uLCB2YWx1ZSA9PT0gbnVsbCA/IC0xMCA6IC05LCB0cnVlKTtcblx0XHRcdHBvc2l0aW9uICs9IDI7XG5cdFx0fVxuXHRcdGtleUluZGV4Kys7XG5cdH1cblxuXG5cdGxldCByZWNvcmRJZCA9IHRyYW5zaXRpb25bUkVDT1JEX1NZTUJPTF07XG5cdGlmIChyZWNvcmRJZCA9PSBudWxsKSB7XG5cdFx0cmVjb3JkSWQgPSBwYWNrci50eXBlZFN0cnVjdHMubGVuZ3RoO1xuXHRcdGxldCBzdHJ1Y3R1cmUgPSBbXTtcblx0XHRsZXQgbmV4dFRyYW5zaXRpb24gPSB0cmFuc2l0aW9uO1xuXHRcdGxldCBrZXksIHR5cGU7XG5cdFx0d2hpbGUgKCh0eXBlID0gbmV4dFRyYW5zaXRpb24uX190eXBlKSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRsZXQgc2l6ZSA9IG5leHRUcmFuc2l0aW9uLl9fc2l6ZTtcblx0XHRcdG5leHRUcmFuc2l0aW9uID0gbmV4dFRyYW5zaXRpb24uX19wYXJlbnQ7XG5cdFx0XHRrZXkgPSBuZXh0VHJhbnNpdGlvbi5rZXk7XG5cdFx0XHRsZXQgcHJvcGVydHkgPSBbdHlwZSwgc2l6ZSwga2V5XTtcblx0XHRcdGlmIChuZXh0VHJhbnNpdGlvbi5lbnVtZXJhdGlvbk9mZnNldClcblx0XHRcdFx0cHJvcGVydHkucHVzaChuZXh0VHJhbnNpdGlvbi5lbnVtZXJhdGlvbk9mZnNldCk7XG5cdFx0XHRzdHJ1Y3R1cmUucHVzaChwcm9wZXJ0eSk7XG5cdFx0XHRuZXh0VHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uLnBhcmVudDtcblx0XHR9XG5cdFx0c3RydWN0dXJlLnJldmVyc2UoKTtcblx0XHR0cmFuc2l0aW9uW1JFQ09SRF9TWU1CT0xdID0gcmVjb3JkSWQ7XG5cdFx0cGFja3IudHlwZWRTdHJ1Y3RzW3JlY29yZElkXSA9IHN0cnVjdHVyZTtcblx0XHRwYWNrKG51bGwsIDAsIHRydWUpOyAvLyBzcGVjaWFsIGNhbGwgdG8gbm90aWZ5IHRoYXQgc3RydWN0dXJlcyBoYXZlIGJlZW4gdXBkYXRlZFxuXHR9XG5cblxuXHRzd2l0Y2ggKGhlYWRlclNpemUpIHtcblx0XHRjYXNlIDE6XG5cdFx0XHRpZiAocmVjb3JkSWQgPj0gMHgxMCkgcmV0dXJuIDA7XG5cdFx0XHR0YXJnZXRbc3RhcnRdID0gcmVjb3JkSWQgKyAweDIwO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAyOlxuXHRcdFx0aWYgKHJlY29yZElkID49IDB4MTAwKSByZXR1cm4gMDtcblx0XHRcdHRhcmdldFtzdGFydF0gPSAweDM4O1xuXHRcdFx0dGFyZ2V0W3N0YXJ0ICsgMV0gPSByZWNvcmRJZDtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgMzpcblx0XHRcdGlmIChyZWNvcmRJZCA+PSAweDEwMDAwKSByZXR1cm4gMDtcblx0XHRcdHRhcmdldFtzdGFydF0gPSAweDM5O1xuXHRcdFx0dGFyZ2V0Vmlldy5zZXRVaW50MTYoc3RhcnQgKyAxLCByZWNvcmRJZCwgdHJ1ZSk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIDQ6XG5cdFx0XHRpZiAocmVjb3JkSWQgPj0gMHgxMDAwMDAwKSByZXR1cm4gMDtcblx0XHRcdHRhcmdldFZpZXcuc2V0VWludDMyKHN0YXJ0LCAocmVjb3JkSWQgPDwgOCkgKyAweDNhLCB0cnVlKTtcblx0XHRcdGJyZWFrO1xuXHR9XG5cblx0aWYgKHBvc2l0aW9uIDwgcmVmc1N0YXJ0UG9zaXRpb24pIHtcblx0XHRpZiAocmVmc1N0YXJ0UG9zaXRpb24gPT09IHJlZlBvc2l0aW9uKVxuXHRcdFx0cmV0dXJuIHBvc2l0aW9uOyAvLyBubyByZWZzXG5cdFx0Ly8gYWRqdXN0IHBvc2l0aW9uaW5nXG5cdFx0dGFyZ2V0LmNvcHlXaXRoaW4ocG9zaXRpb24sIHJlZnNTdGFydFBvc2l0aW9uLCByZWZQb3NpdGlvbik7XG5cdFx0cmVmUG9zaXRpb24gKz0gcG9zaXRpb24gLSByZWZzU3RhcnRQb3NpdGlvbjtcblx0XHR0eXBlZFN0cnVjdHMubGFzdFN0cmluZ1N0YXJ0ID0gcG9zaXRpb24gLSBzdGFydDtcblx0fSBlbHNlIGlmIChwb3NpdGlvbiA+IHJlZnNTdGFydFBvc2l0aW9uKSB7XG5cdFx0aWYgKHJlZnNTdGFydFBvc2l0aW9uID09PSByZWZQb3NpdGlvbilcblx0XHRcdHJldHVybiBwb3NpdGlvbjsgLy8gbm8gcmVmc1xuXHRcdHR5cGVkU3RydWN0cy5sYXN0U3RyaW5nU3RhcnQgPSBwb3NpdGlvbiAtIHN0YXJ0O1xuXHRcdHJldHVybiB3cml0ZVN0cnVjdChvYmplY3QsIHRhcmdldCwgZW5jb2RpbmdTdGFydCwgc3RhcnQsIHN0cnVjdHVyZXMsIG1ha2VSb29tLCBwYWNrLCBwYWNrcik7XG5cdH1cblx0cmV0dXJuIHJlZlBvc2l0aW9uO1xufVxuZnVuY3Rpb24gYW55VHlwZSh0cmFuc2l0aW9uLCBwb3NpdGlvbiwgdGFyZ2V0VmlldywgdmFsdWUpIHtcblx0bGV0IG5leHRUcmFuc2l0aW9uO1xuXHRpZiAoKG5leHRUcmFuc2l0aW9uID0gdHJhbnNpdGlvbi5hc2NpaTggfHwgdHJhbnNpdGlvbi5udW04KSkge1xuXHRcdHRhcmdldFZpZXcuc2V0SW50OChwb3NpdGlvbiwgdmFsdWUsIHRydWUpO1xuXHRcdHVwZGF0ZWRQb3NpdGlvbiA9IHBvc2l0aW9uICsgMTtcblx0XHRyZXR1cm4gbmV4dFRyYW5zaXRpb247XG5cdH1cblx0aWYgKChuZXh0VHJhbnNpdGlvbiA9IHRyYW5zaXRpb24uc3RyaW5nMTYgfHwgdHJhbnNpdGlvbi5vYmplY3QxNikpIHtcblx0XHR0YXJnZXRWaWV3LnNldEludDE2KHBvc2l0aW9uLCB2YWx1ZSwgdHJ1ZSk7XG5cdFx0dXBkYXRlZFBvc2l0aW9uID0gcG9zaXRpb24gKyAyO1xuXHRcdHJldHVybiBuZXh0VHJhbnNpdGlvbjtcblx0fVxuXHRpZiAobmV4dFRyYW5zaXRpb24gPSB0cmFuc2l0aW9uLm51bTMyKSB7XG5cdFx0dGFyZ2V0Vmlldy5zZXRVaW50MzIocG9zaXRpb24sIDB4ZTAwMDAxMDAgKyB2YWx1ZSwgdHJ1ZSk7XG5cdFx0dXBkYXRlZFBvc2l0aW9uID0gcG9zaXRpb24gKyA0O1xuXHRcdHJldHVybiBuZXh0VHJhbnNpdGlvbjtcblx0fVxuXHQvLyB0cmFuc2l0aW9uLmZsb2F0NjRcblx0aWYgKG5leHRUcmFuc2l0aW9uID0gdHJhbnNpdGlvbi5udW02NCkge1xuXHRcdHRhcmdldFZpZXcuc2V0RmxvYXQ2NChwb3NpdGlvbiwgTmFOLCB0cnVlKTtcblx0XHR0YXJnZXRWaWV3LnNldEludDgocG9zaXRpb24sIHZhbHVlKTtcblx0XHR1cGRhdGVkUG9zaXRpb24gPSBwb3NpdGlvbiArIDg7XG5cdFx0cmV0dXJuIG5leHRUcmFuc2l0aW9uO1xuXHR9XG5cdHVwZGF0ZWRQb3NpdGlvbiA9IHBvc2l0aW9uO1xuXHQvLyBUT0RPOiBjYW4gd2UgZG8gYW4gXCJhbnlcIiB0eXBlIHdoZXJlIHdlIGRlZmVyIHRoZSBkZWNpc2lvbj9cblx0cmV0dXJuO1xufVxuZnVuY3Rpb24gY3JlYXRlVHlwZVRyYW5zaXRpb24odHJhbnNpdGlvbiwgdHlwZSwgc2l6ZSkge1xuXHRsZXQgdHlwZU5hbWUgPSBUWVBFX05BTUVTW3R5cGVdICsgKHNpemUgPDwgMyk7XG5cdGxldCBuZXdUcmFuc2l0aW9uID0gdHJhbnNpdGlvblt0eXBlTmFtZV0gfHwgKHRyYW5zaXRpb25bdHlwZU5hbWVdID0gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG5cdG5ld1RyYW5zaXRpb24uX190eXBlID0gdHlwZTtcblx0bmV3VHJhbnNpdGlvbi5fX3NpemUgPSBzaXplO1xuXHRuZXdUcmFuc2l0aW9uLl9fcGFyZW50ID0gdHJhbnNpdGlvbjtcblx0cmV0dXJuIG5ld1RyYW5zaXRpb247XG59XG5mdW5jdGlvbiBvbkxvYWRlZFN0cnVjdHVyZXMoc2hhcmVkRGF0YSkge1xuXHRpZiAoIShzaGFyZWREYXRhIGluc3RhbmNlb2YgTWFwKSlcblx0XHRyZXR1cm4gc2hhcmVkRGF0YTtcblx0bGV0IHR5cGVkID0gc2hhcmVkRGF0YS5nZXQoJ3R5cGVkJykgfHwgW107XG5cdGlmIChPYmplY3QuaXNGcm96ZW4odHlwZWQpKVxuXHRcdHR5cGVkID0gdHlwZWQubWFwKHN0cnVjdHVyZSA9PiBzdHJ1Y3R1cmUuc2xpY2UoMCkpO1xuXHRsZXQgbmFtZWQgPSBzaGFyZWREYXRhLmdldCgnbmFtZWQnKTtcblx0bGV0IHRyYW5zaXRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0Zm9yIChsZXQgaSA9IDAsIGwgPSB0eXBlZC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRsZXQgc3RydWN0dXJlID0gdHlwZWRbaV07XG5cdFx0bGV0IHRyYW5zaXRpb24gPSB0cmFuc2l0aW9ucztcblx0XHRmb3IgKGxldCBbdHlwZSwgc2l6ZSwga2V5XSBvZiBzdHJ1Y3R1cmUpIHtcblx0XHRcdGxldCBuZXh0VHJhbnNpdGlvbiA9IHRyYW5zaXRpb25ba2V5XTtcblx0XHRcdGlmICghbmV4dFRyYW5zaXRpb24pIHtcblx0XHRcdFx0dHJhbnNpdGlvbltrZXldID0gbmV4dFRyYW5zaXRpb24gPSB7XG5cdFx0XHRcdFx0a2V5LFxuXHRcdFx0XHRcdHBhcmVudDogdHJhbnNpdGlvbixcblx0XHRcdFx0XHRlbnVtZXJhdGlvbk9mZnNldDogMCxcblx0XHRcdFx0XHRhc2NpaTA6IG51bGwsXG5cdFx0XHRcdFx0YXNjaWk4OiBudWxsLFxuXHRcdFx0XHRcdG51bTg6IG51bGwsXG5cdFx0XHRcdFx0c3RyaW5nMTY6IG51bGwsXG5cdFx0XHRcdFx0b2JqZWN0MTY6IG51bGwsXG5cdFx0XHRcdFx0bnVtMzI6IG51bGwsXG5cdFx0XHRcdFx0ZmxvYXQ2NDogbnVsbCxcblx0XHRcdFx0XHRkYXRlNjQ6IG51bGwsXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHR0cmFuc2l0aW9uID0gY3JlYXRlVHlwZVRyYW5zaXRpb24obmV4dFRyYW5zaXRpb24sIHR5cGUsIHNpemUpO1xuXHRcdH1cblx0XHR0cmFuc2l0aW9uW1JFQ09SRF9TWU1CT0xdID0gaTtcblx0fVxuXHR0eXBlZC50cmFuc2l0aW9ucyA9IHRyYW5zaXRpb25zO1xuXHR0aGlzLnR5cGVkU3RydWN0cyA9IHR5cGVkO1xuXHR0aGlzLmxhc3RUeXBlZFN0cnVjdHVyZXNMZW5ndGggPSB0eXBlZC5sZW5ndGg7XG5cdHJldHVybiBuYW1lZDtcbn1cbnZhciBzb3VyY2VTeW1ib2wgPSBTeW1ib2wuZm9yKCdzb3VyY2UnKVxuZnVuY3Rpb24gcmVhZFN0cnVjdChzcmMsIHBvc2l0aW9uLCBzcmNFbmQsIHVucGFja3IpIHtcblx0bGV0IHJlY29yZElkID0gc3JjW3Bvc2l0aW9uKytdIC0gMHgyMDtcblx0aWYgKHJlY29yZElkID49IDI0KSB7XG5cdFx0c3dpdGNoKHJlY29yZElkKSB7XG5cdFx0XHRjYXNlIDI0OiByZWNvcmRJZCA9IHNyY1twb3NpdGlvbisrXTsgYnJlYWs7XG5cdFx0XHQvLyBsaXR0bGUgZW5kaWFuOlxuXHRcdFx0Y2FzZSAyNTogcmVjb3JkSWQgPSBzcmNbcG9zaXRpb24rK10gKyAoc3JjW3Bvc2l0aW9uKytdIDw8IDgpOyBicmVhaztcblx0XHRcdGNhc2UgMjY6IHJlY29yZElkID0gc3JjW3Bvc2l0aW9uKytdICsgKHNyY1twb3NpdGlvbisrXSA8PCA4KSArIChzcmNbcG9zaXRpb24rK10gPDwgMTYpOyBicmVhaztcblx0XHRcdGNhc2UgMjc6IHJlY29yZElkID0gc3JjW3Bvc2l0aW9uKytdICsgKHNyY1twb3NpdGlvbisrXSA8PCA4KSArIChzcmNbcG9zaXRpb24rK10gPDwgMTYpICsgKHNyY1twb3NpdGlvbisrXSA8PCAyNCk7IGJyZWFrO1xuXHRcdH1cblx0fVxuXHRsZXQgc3RydWN0dXJlID0gdW5wYWNrci50eXBlZFN0cnVjdHMgJiYgdW5wYWNrci50eXBlZFN0cnVjdHNbcmVjb3JkSWRdO1xuXHRpZiAoIXN0cnVjdHVyZSkge1xuXHRcdC8vIGNvcHkgc3JjIGJ1ZmZlciBiZWNhdXNlIGdldFN0cnVjdHVyZXMgd2lsbCBvdmVycmlkZSBpdFxuXHRcdHNyYyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoc3JjLCBwb3NpdGlvbiwgc3JjRW5kKTtcblx0XHRzcmNFbmQgLT0gcG9zaXRpb247XG5cdFx0cG9zaXRpb24gPSAwO1xuXHRcdGlmICghdW5wYWNrci5nZXRTdHJ1Y3R1cmVzKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGBSZWZlcmVuY2UgdG8gc2hhcmVkIHN0cnVjdHVyZSAke3JlY29yZElkfSB3aXRob3V0IGdldFN0cnVjdHVyZXMgbWV0aG9kYCk7XG5cdFx0dW5wYWNrci5fbWVyZ2VTdHJ1Y3R1cmVzKHVucGFja3IuZ2V0U3RydWN0dXJlcygpKTtcblx0XHRpZiAoIXVucGFja3IudHlwZWRTdHJ1Y3RzKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCBhbnkgc2hhcmVkIHR5cGVkIHN0cnVjdHVyZXMnKTtcblx0XHR1bnBhY2tyLmxhc3RUeXBlZFN0cnVjdHVyZXNMZW5ndGggPSB1bnBhY2tyLnR5cGVkU3RydWN0cy5sZW5ndGg7XG5cdFx0c3RydWN0dXJlID0gdW5wYWNrci50eXBlZFN0cnVjdHNbcmVjb3JkSWRdO1xuXHRcdGlmICghc3RydWN0dXJlKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCB0eXBlZCBzdHJ1Y3R1cmUgJyArIHJlY29yZElkKTtcblx0fVxuXHR2YXIgY29uc3RydWN0ID0gc3RydWN0dXJlLmNvbnN0cnVjdDtcblx0dmFyIGZ1bGxDb25zdHJ1Y3QgPSBzdHJ1Y3R1cmUuZnVsbENvbnN0cnVjdDtcblx0aWYgKCFjb25zdHJ1Y3QpIHtcblx0XHRjb25zdHJ1Y3QgPSBzdHJ1Y3R1cmUuY29uc3RydWN0ID0gZnVuY3Rpb24gTGF6eU9iamVjdCgpIHtcblx0XHR9XG5cdFx0ZnVsbENvbnN0cnVjdCA9IHN0cnVjdHVyZS5mdWxsQ29uc3RydWN0ID0gZnVuY3Rpb24gTG9hZGVkT2JqZWN0KCkge1xuXHRcdH1cblx0XHRmdWxsQ29uc3RydWN0LnByb3RvdHlwZSA9IHVucGFja3Iuc3RydWN0UHJvdG90eXBlIHx8IHt9O1xuXHRcdHZhciBwcm90b3R5cGUgPSBjb25zdHJ1Y3QucHJvdG90eXBlID0gdW5wYWNrci5zdHJ1Y3RQcm90b3R5cGUgPyBPYmplY3QuY3JlYXRlKHVucGFja3Iuc3RydWN0UHJvdG90eXBlKSA6IHt9O1xuXHRcdGxldCBwcm9wZXJ0aWVzID0gW107XG5cdFx0bGV0IGN1cnJlbnRPZmZzZXQgPSAwO1xuXHRcdGxldCBsYXN0UmVmUHJvcGVydHk7XG5cdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBzdHJ1Y3R1cmUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRsZXQgZGVmaW5pdGlvbiA9IHN0cnVjdHVyZVtpXTtcblx0XHRcdGxldCBbIHR5cGUsIHNpemUsIGtleSwgZW51bWVyYXRpb25PZmZzZXQgXSA9IGRlZmluaXRpb247XG5cdFx0XHRpZiAoa2V5ID09PSAnX19wcm90b19fJylcblx0XHRcdFx0a2V5ID0gJ19fcHJvdG9fJztcblx0XHRcdGxldCBwcm9wZXJ0eSA9IHtcblx0XHRcdFx0a2V5LFxuXHRcdFx0XHRvZmZzZXQ6IGN1cnJlbnRPZmZzZXQsXG5cdFx0XHR9XG5cdFx0XHRpZiAoZW51bWVyYXRpb25PZmZzZXQpXG5cdFx0XHRcdHByb3BlcnRpZXMuc3BsaWNlKGkgKyBlbnVtZXJhdGlvbk9mZnNldCwgMCwgcHJvcGVydHkpO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRwcm9wZXJ0aWVzLnB1c2gocHJvcGVydHkpO1xuXHRcdFx0bGV0IGdldFJlZjtcblx0XHRcdHN3aXRjaChzaXplKSB7IC8vIFRPRE86IE1vdmUgaW50byBhIHNlcGFyYXRlIGZ1bmN0aW9uXG5cdFx0XHRcdGNhc2UgMDogZ2V0UmVmID0gKCkgPT4gMDsgYnJlYWs7XG5cdFx0XHRcdGNhc2UgMTpcblx0XHRcdFx0XHRnZXRSZWYgPSAoc291cmNlLCBwb3NpdGlvbikgPT4ge1xuXHRcdFx0XHRcdFx0bGV0IHJlZiA9IHNvdXJjZS5ieXRlc1twb3NpdGlvbiArIHByb3BlcnR5Lm9mZnNldF07XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVmID49IDB4ZjYgPyB0b0NvbnN0YW50KHJlZikgOiByZWY7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHRcdGdldFJlZiA9IChzb3VyY2UsIHBvc2l0aW9uKSA9PiB7XG5cdFx0XHRcdFx0XHRsZXQgc3JjID0gc291cmNlLmJ5dGVzO1xuXHRcdFx0XHRcdFx0bGV0IGRhdGFWaWV3ID0gc3JjLmRhdGFWaWV3IHx8IChzcmMuZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoc3JjLmJ1ZmZlciwgc3JjLmJ5dGVPZmZzZXQsIHNyYy5ieXRlTGVuZ3RoKSk7XG5cdFx0XHRcdFx0XHRsZXQgcmVmID0gZGF0YVZpZXcuZ2V0VWludDE2KHBvc2l0aW9uICsgcHJvcGVydHkub2Zmc2V0LCB0cnVlKTtcblx0XHRcdFx0XHRcdHJldHVybiByZWYgPj0gMHhmZjAwID8gdG9Db25zdGFudChyZWYgJiAweGZmKSA6IHJlZjtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIDQ6XG5cdFx0XHRcdFx0Z2V0UmVmID0gKHNvdXJjZSwgcG9zaXRpb24pID0+IHtcblx0XHRcdFx0XHRcdGxldCBzcmMgPSBzb3VyY2UuYnl0ZXM7XG5cdFx0XHRcdFx0XHRsZXQgZGF0YVZpZXcgPSBzcmMuZGF0YVZpZXcgfHwgKHNyYy5kYXRhVmlldyA9IG5ldyBEYXRhVmlldyhzcmMuYnVmZmVyLCBzcmMuYnl0ZU9mZnNldCwgc3JjLmJ5dGVMZW5ndGgpKTtcblx0XHRcdFx0XHRcdGxldCByZWYgPSBkYXRhVmlldy5nZXRVaW50MzIocG9zaXRpb24gKyBwcm9wZXJ0eS5vZmZzZXQsIHRydWUpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlZiA+PSAweGZmZmZmZjAwID8gdG9Db25zdGFudChyZWYgJiAweGZmKSA6IHJlZjtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0cHJvcGVydHkuZ2V0UmVmID0gZ2V0UmVmO1xuXHRcdFx0Y3VycmVudE9mZnNldCArPSBzaXplO1xuXHRcdFx0bGV0IGdldDtcblx0XHRcdHN3aXRjaCh0eXBlKSB7XG5cdFx0XHRcdGNhc2UgQVNDSUk6XG5cdFx0XHRcdFx0aWYgKGxhc3RSZWZQcm9wZXJ0eSAmJiAhbGFzdFJlZlByb3BlcnR5Lm5leHQpXG5cdFx0XHRcdFx0XHRsYXN0UmVmUHJvcGVydHkubmV4dCA9IHByb3BlcnR5O1xuXHRcdFx0XHRcdGxhc3RSZWZQcm9wZXJ0eSA9IHByb3BlcnR5O1xuXHRcdFx0XHRcdHByb3BlcnR5Lm11bHRpR2V0Q291bnQgPSAwO1xuXHRcdFx0XHRcdGdldCA9IGZ1bmN0aW9uKHNvdXJjZSkge1xuXHRcdFx0XHRcdFx0bGV0IHNyYyA9IHNvdXJjZS5ieXRlcztcblx0XHRcdFx0XHRcdGxldCBwb3NpdGlvbiA9IHNvdXJjZS5wb3NpdGlvbjtcblx0XHRcdFx0XHRcdGxldCByZWZTdGFydCA9IGN1cnJlbnRPZmZzZXQgKyBwb3NpdGlvbjtcblx0XHRcdFx0XHRcdGxldCByZWYgPSBnZXRSZWYoc291cmNlLCBwb3NpdGlvbik7XG5cdFx0XHRcdFx0XHRpZiAodHlwZW9mIHJlZiAhPT0gJ251bWJlcicpIHJldHVybiByZWY7XG5cblx0XHRcdFx0XHRcdGxldCBlbmQsIG5leHQgPSBwcm9wZXJ0eS5uZXh0O1xuXHRcdFx0XHRcdFx0d2hpbGUobmV4dCkge1xuXHRcdFx0XHRcdFx0XHRlbmQgPSBuZXh0LmdldFJlZihzb3VyY2UsIHBvc2l0aW9uKTtcblx0XHRcdFx0XHRcdFx0aWYgKHR5cGVvZiBlbmQgPT09ICdudW1iZXInKVxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRcdFx0ZW5kID0gbnVsbDtcblx0XHRcdFx0XHRcdFx0bmV4dCA9IG5leHQubmV4dDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChlbmQgPT0gbnVsbClcblx0XHRcdFx0XHRcdFx0ZW5kID0gc291cmNlLmJ5dGVzRW5kIC0gcmVmU3RhcnQ7XG5cdFx0XHRcdFx0XHRpZiAoc291cmNlLnNyY1N0cmluZykge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gc291cmNlLnNyY1N0cmluZy5zbGljZShyZWYsIGVuZCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvKmlmIChwcm9wZXJ0eS5tdWx0aUdldENvdW50ID4gMCkge1xuXHRcdFx0XHRcdFx0XHRsZXQgYXNjaWlFbmQ7XG5cdFx0XHRcdFx0XHRcdG5leHQgPSBmaXJzdFJlZlByb3BlcnR5O1xuXHRcdFx0XHRcdFx0XHRsZXQgZGF0YVZpZXcgPSBzcmMuZGF0YVZpZXcgfHwgKHNyYy5kYXRhVmlldyA9IG5ldyBEYXRhVmlldyhzcmMuYnVmZmVyLCBzcmMuYnl0ZU9mZnNldCwgc3JjLmJ5dGVMZW5ndGgpKTtcblx0XHRcdFx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdFx0XHRcdGFzY2lpRW5kID0gZGF0YVZpZXcuZ2V0VWludDE2KHNvdXJjZS5wb3NpdGlvbiArIG5leHQub2Zmc2V0LCB0cnVlKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoYXNjaWlFbmQgPCAweGZmMDApXG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRcdFx0XHRhc2NpaUVuZCA9IG51bGw7XG5cdFx0XHRcdFx0XHRcdH0gd2hpbGUoKG5leHQgPSBuZXh0Lm5leHQpKTtcblx0XHRcdFx0XHRcdFx0aWYgKGFzY2lpRW5kID09IG51bGwpXG5cdFx0XHRcdFx0XHRcdFx0YXNjaWlFbmQgPSBzb3VyY2UuYnl0ZXNFbmQgLSByZWZTdGFydFxuXHRcdFx0XHRcdFx0XHRzb3VyY2Uuc3JjU3RyaW5nID0gc3JjLnRvU3RyaW5nKCdsYXRpbjEnLCByZWZTdGFydCwgcmVmU3RhcnQgKyBhc2NpaUVuZCk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBzb3VyY2Uuc3JjU3RyaW5nLnNsaWNlKHJlZiwgZW5kKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChzb3VyY2UucHJldlN0cmluZ0dldCkge1xuXHRcdFx0XHRcdFx0XHRzb3VyY2UucHJldlN0cmluZ0dldC5tdWx0aUdldENvdW50ICs9IDI7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRzb3VyY2UucHJldlN0cmluZ0dldCA9IHByb3BlcnR5O1xuXHRcdFx0XHRcdFx0XHRwcm9wZXJ0eS5tdWx0aUdldENvdW50LS07XG5cdFx0XHRcdFx0XHR9Ki9cblx0XHRcdFx0XHRcdHJldHVybiByZWFkU3RyaW5nKHNyYywgcmVmICsgcmVmU3RhcnQsIGVuZCAtIHJlZik7XG5cdFx0XHRcdFx0XHQvL3JldHVybiBzcmMudG9TdHJpbmcoJ2xhdGluMScsIHJlZiArIHJlZlN0YXJ0LCBlbmQgKyByZWZTdGFydCk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBVVEY4OiBjYXNlIE9CSkVDVF9EQVRBOlxuXHRcdFx0XHRcdGlmIChsYXN0UmVmUHJvcGVydHkgJiYgIWxhc3RSZWZQcm9wZXJ0eS5uZXh0KVxuXHRcdFx0XHRcdFx0bGFzdFJlZlByb3BlcnR5Lm5leHQgPSBwcm9wZXJ0eTtcblx0XHRcdFx0XHRsYXN0UmVmUHJvcGVydHkgPSBwcm9wZXJ0eTtcblx0XHRcdFx0XHRnZXQgPSBmdW5jdGlvbihzb3VyY2UpIHtcblx0XHRcdFx0XHRcdGxldCBwb3NpdGlvbiA9IHNvdXJjZS5wb3NpdGlvbjtcblx0XHRcdFx0XHRcdGxldCByZWZTdGFydCA9IGN1cnJlbnRPZmZzZXQgKyBwb3NpdGlvbjtcblx0XHRcdFx0XHRcdGxldCByZWYgPSBnZXRSZWYoc291cmNlLCBwb3NpdGlvbik7XG5cdFx0XHRcdFx0XHRpZiAodHlwZW9mIHJlZiAhPT0gJ251bWJlcicpIHJldHVybiByZWY7XG5cdFx0XHRcdFx0XHRsZXQgc3JjID0gc291cmNlLmJ5dGVzO1xuXHRcdFx0XHRcdFx0bGV0IGVuZCwgbmV4dCA9IHByb3BlcnR5Lm5leHQ7XG5cdFx0XHRcdFx0XHR3aGlsZShuZXh0KSB7XG5cdFx0XHRcdFx0XHRcdGVuZCA9IG5leHQuZ2V0UmVmKHNvdXJjZSwgcG9zaXRpb24pO1xuXHRcdFx0XHRcdFx0XHRpZiAodHlwZW9mIGVuZCA9PT0gJ251bWJlcicpXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdFx0XHRlbmQgPSBudWxsO1xuXHRcdFx0XHRcdFx0XHRuZXh0ID0gbmV4dC5uZXh0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKGVuZCA9PSBudWxsKVxuXHRcdFx0XHRcdFx0XHRlbmQgPSBzb3VyY2UuYnl0ZXNFbmQgLSByZWZTdGFydDtcblx0XHRcdFx0XHRcdGlmICh0eXBlID09PSBVVEY4KSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBzcmMudG9TdHJpbmcoJ3V0ZjgnLCByZWYgKyByZWZTdGFydCwgZW5kICsgcmVmU3RhcnQpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Y3VycmVudFNvdXJjZSA9IHNvdXJjZTtcblx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdW5wYWNrci51bnBhY2soc3JjLCB7IHN0YXJ0OiByZWYgKyByZWZTdGFydCwgZW5kOiBlbmQgKyByZWZTdGFydCB9KTtcblx0XHRcdFx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRcdFx0XHRjdXJyZW50U291cmNlID0gbnVsbDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgTlVNQkVSOlxuXHRcdFx0XHRcdHN3aXRjaChzaXplKSB7XG5cdFx0XHRcdFx0XHRjYXNlIDQ6XG5cdFx0XHRcdFx0XHRcdGdldCA9IGZ1bmN0aW9uIChzb3VyY2UpIHtcblx0XHRcdFx0XHRcdFx0XHRsZXQgc3JjID0gc291cmNlLmJ5dGVzO1xuXHRcdFx0XHRcdFx0XHRcdGxldCBkYXRhVmlldyA9IHNyYy5kYXRhVmlldyB8fCAoc3JjLmRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KHNyYy5idWZmZXIsIHNyYy5ieXRlT2Zmc2V0LCBzcmMuYnl0ZUxlbmd0aCkpO1xuXHRcdFx0XHRcdFx0XHRcdGxldCBwb3NpdGlvbiA9IHNvdXJjZS5wb3NpdGlvbiArIHByb3BlcnR5Lm9mZnNldDtcblx0XHRcdFx0XHRcdFx0XHRsZXQgdmFsdWUgPSBkYXRhVmlldy5nZXRJbnQzMihwb3NpdGlvbiwgdHJ1ZSlcblx0XHRcdFx0XHRcdFx0XHRpZiAodmFsdWUgPCAweDIwMDAwMDAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAodmFsdWUgPiAtMHgxZjAwMDAwMClcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKHZhbHVlID4gLTB4MjAwMDAwMDApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiB0b0NvbnN0YW50KHZhbHVlICYgMHhmZik7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGxldCBmVmFsdWUgPSBkYXRhVmlldy5nZXRGbG9hdDMyKHBvc2l0aW9uLCB0cnVlKTtcblx0XHRcdFx0XHRcdFx0XHQvLyB0aGlzIGRvZXMgcm91bmRpbmcgb2YgbnVtYmVycyB0aGF0IHdlcmUgZW5jb2RlZCBpbiAzMi1iaXQgZmxvYXQgdG8gbmVhcmVzdCBzaWduaWZpY2FudCBkZWNpbWFsIGRpZ2l0IHRoYXQgY291bGQgYmUgcHJlc2VydmVkXG5cdFx0XHRcdFx0XHRcdFx0bGV0IG11bHRpcGxpZXIgPSBtdWx0MTBbKChzcmNbcG9zaXRpb24gKyAzXSAmIDB4N2YpIDw8IDEpIHwgKHNyY1twb3NpdGlvbiArIDJdID4+IDcpXVxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiAoKG11bHRpcGxpZXIgKiBmVmFsdWUgKyAoZlZhbHVlID4gMCA/IDAuNSA6IC0wLjUpKSA+PiAwKSAvIG11bHRpcGxpZXI7XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSA4OlxuXHRcdFx0XHRcdFx0XHRnZXQgPSBmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRcdFx0XHRcdFx0bGV0IHNyYyA9IHNvdXJjZS5ieXRlcztcblx0XHRcdFx0XHRcdFx0XHRsZXQgZGF0YVZpZXcgPSBzcmMuZGF0YVZpZXcgfHwgKHNyYy5kYXRhVmlldyA9IG5ldyBEYXRhVmlldyhzcmMuYnVmZmVyLCBzcmMuYnl0ZU9mZnNldCwgc3JjLmJ5dGVMZW5ndGgpKTtcblx0XHRcdFx0XHRcdFx0XHRsZXQgdmFsdWUgPSBkYXRhVmlldy5nZXRGbG9hdDY0KHNvdXJjZS5wb3NpdGlvbiArIHByb3BlcnR5Lm9mZnNldCwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGlzTmFOKHZhbHVlKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0bGV0IGJ5dGUgPSBzcmNbc291cmNlLnBvc2l0aW9uICsgcHJvcGVydHkub2Zmc2V0XTtcblx0XHRcdFx0XHRcdFx0XHRcdGlmIChieXRlID49IDB4ZjYpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiB0b0NvbnN0YW50KGJ5dGUpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHRcdFx0XHRnZXQgPSBmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRcdFx0XHRcdFx0bGV0IHNyYyA9IHNvdXJjZS5ieXRlcztcblx0XHRcdFx0XHRcdFx0XHRsZXQgdmFsdWUgPSBzcmNbc291cmNlLnBvc2l0aW9uICsgcHJvcGVydHkub2Zmc2V0XTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWUgPCAweGY2ID8gdmFsdWUgOiB0b0NvbnN0YW50KHZhbHVlKTtcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIERBVEU6XG5cdFx0XHRcdFx0Z2V0ID0gZnVuY3Rpb24gKHNvdXJjZSkge1xuXHRcdFx0XHRcdFx0bGV0IHNyYyA9IHNvdXJjZS5ieXRlcztcblx0XHRcdFx0XHRcdGxldCBkYXRhVmlldyA9IHNyYy5kYXRhVmlldyB8fCAoc3JjLmRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KHNyYy5idWZmZXIsIHNyYy5ieXRlT2Zmc2V0LCBzcmMuYnl0ZUxlbmd0aCkpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIG5ldyBEYXRlKGRhdGFWaWV3LmdldEZsb2F0NjQoc291cmNlLnBvc2l0aW9uICsgcHJvcGVydHkub2Zmc2V0LCB0cnVlKSk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXHRcdFx0cHJvcGVydHkuZ2V0ID0gZ2V0O1xuXHRcdH1cblx0XHQvLyBUT0RPOiBsb2FkIHRoZSBzcmNTdHJpbmcgZm9yIGZhc3RlciBzdHJpbmcgZGVjb2Rpbmcgb24gdG9KU09OXG5cdFx0aWYgKGV2YWxTdXBwb3J0ZWQpIHtcblx0XHRcdGxldCBvYmplY3RMaXRlcmFsUHJvcGVydGllcyA9IFtdO1xuXHRcdFx0bGV0IGFyZ3MgPSBbXTtcblx0XHRcdGxldCBpID0gMDtcblx0XHRcdGxldCBoYXNJbmhlcml0ZWRQcm9wZXJ0aWVzO1xuXHRcdFx0Zm9yIChsZXQgcHJvcGVydHkgb2YgcHJvcGVydGllcykgeyAvLyBhc3NpZ24gaW4gZW51bWVyYXRpb24gb3JkZXJcblx0XHRcdFx0aWYgKHVucGFja3IuYWx3YXlzTGF6eVByb3BlcnR5ICYmIHVucGFja3IuYWx3YXlzTGF6eVByb3BlcnR5KHByb3BlcnR5LmtleSkpIHtcblx0XHRcdFx0XHQvLyB0aGVzZSBwcm9wZXJ0aWVzIGFyZSBub3QgZWFnZXJseSBldmFsdWF0ZWQgYW5kIHRoaXMgY2FuIGJlIHVzZWQgZm9yIGNyZWF0aW5nIHByb3BlcnRpZXNcblx0XHRcdFx0XHQvLyB0aGF0IGFyZSBub3Qgc2VyaWFsaXplZCBhcyBKU09OXG5cdFx0XHRcdFx0aGFzSW5oZXJpdGVkUHJvcGVydGllcyA9IHRydWU7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgcHJvcGVydHkua2V5LCB7IGdldDogd2l0aFNvdXJjZShwcm9wZXJ0eS5nZXQpLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuXHRcdFx0XHRsZXQgdmFsdWVGdW5jdGlvbiA9ICd2JyArIGkrKztcblx0XHRcdFx0YXJncy5wdXNoKHZhbHVlRnVuY3Rpb24pO1xuXHRcdFx0XHRvYmplY3RMaXRlcmFsUHJvcGVydGllcy5wdXNoKCdvWycgKyBKU09OLnN0cmluZ2lmeShwcm9wZXJ0eS5rZXkpICsgJ109JyArIHZhbHVlRnVuY3Rpb24gKyAnKHMpJyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoaGFzSW5oZXJpdGVkUHJvcGVydGllcykge1xuXHRcdFx0XHRvYmplY3RMaXRlcmFsUHJvcGVydGllcy5wdXNoKCdfX3Byb3RvX186dGhpcycpO1xuXHRcdFx0fVxuXHRcdFx0bGV0IHRvT2JqZWN0ID0gKG5ldyBGdW5jdGlvbiguLi5hcmdzLCAndmFyIGM9dGhpcztyZXR1cm4gZnVuY3Rpb24ocyl7dmFyIG89bmV3IGMoKTsnICsgb2JqZWN0TGl0ZXJhbFByb3BlcnRpZXMuam9pbignOycpICsgJztyZXR1cm4gbzt9JykpLmFwcGx5KGZ1bGxDb25zdHJ1Y3QsIHByb3BlcnRpZXMubWFwKHByb3AgPT4gcHJvcC5nZXQpKTtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90b3R5cGUsICd0b0pTT04nLCB7XG5cdFx0XHRcdHZhbHVlKG9taXRVbmRlcnNjb3JlZFByb3BlcnRpZXMpIHtcblx0XHRcdFx0XHRyZXR1cm4gdG9PYmplY3QuY2FsbCh0aGlzLCB0aGlzW3NvdXJjZVN5bWJvbF0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgJ3RvSlNPTicsIHtcblx0XHRcdFx0dmFsdWUob21pdFVuZGVyc2NvcmVkUHJvcGVydGllcykge1xuXHRcdFx0XHRcdC8vIHJldHVybiBhbiBlbnVtZXJhYmxlIG9iamVjdCB3aXRoIG93biBwcm9wZXJ0aWVzIHRvIEpTT04gc3RyaW5naWZ5XG5cdFx0XHRcdFx0bGV0IHJlc29sdmVkID0ge307XG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBwcm9wZXJ0aWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdFx0Ly8gVE9ETzogY2hlY2sgYWx3YXlzTGF6eVByb3BlcnR5XG5cdFx0XHRcdFx0XHRsZXQga2V5ID0gcHJvcGVydGllc1tpXS5rZXk7XG5cblx0XHRcdFx0XHRcdHJlc29sdmVkW2tleV0gPSB0aGlzW2tleV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiByZXNvbHZlZDtcblx0XHRcdFx0fSxcblx0XHRcdFx0Ly8gbm90IGVudW1lcmFibGUgb3IgYW55dGhpbmdcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXHR2YXIgaW5zdGFuY2UgPSBuZXcgY29uc3RydWN0KCk7XG5cdGluc3RhbmNlW3NvdXJjZVN5bWJvbF0gPSB7XG5cdFx0Ynl0ZXM6IHNyYyxcblx0XHRwb3NpdGlvbixcblx0XHRzcmNTdHJpbmc6ICcnLFxuXHRcdGJ5dGVzRW5kOiBzcmNFbmRcblx0fVxuXHRyZXR1cm4gaW5zdGFuY2U7XG59XG5mdW5jdGlvbiB0b0NvbnN0YW50KGNvZGUpIHtcblx0c3dpdGNoKGNvZGUpIHtcblx0XHRjYXNlIDB4ZjY6IHJldHVybiBudWxsO1xuXHRcdGNhc2UgMHhmNzogcmV0dXJuIHVuZGVmaW5lZDtcblx0XHRjYXNlIDB4Zjg6IHJldHVybiBmYWxzZTtcblx0XHRjYXNlIDB4Zjk6IHJldHVybiB0cnVlO1xuXHR9XG5cdHRocm93IG5ldyBFcnJvcignVW5rbm93biBjb25zdGFudCcpO1xufVxuZnVuY3Rpb24gd2l0aFNvdXJjZShnZXQpIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBnZXQodGhpc1tzb3VyY2VTeW1ib2xdKTtcblx0fVxufVxuXG5mdW5jdGlvbiBzYXZlU3RhdGUoKSB7XG5cdGlmIChjdXJyZW50U291cmNlKSB7XG5cdFx0Y3VycmVudFNvdXJjZS5ieXRlcyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoY3VycmVudFNvdXJjZS5ieXRlcywgY3VycmVudFNvdXJjZS5wb3NpdGlvbiwgY3VycmVudFNvdXJjZS5ieXRlc0VuZCk7XG5cdFx0Y3VycmVudFNvdXJjZS5wb3NpdGlvbiA9IDA7XG5cdFx0Y3VycmVudFNvdXJjZS5ieXRlc0VuZCA9IGN1cnJlbnRTb3VyY2UuYnl0ZXMubGVuZ3RoO1xuXHR9XG59XG5mdW5jdGlvbiBwcmVwYXJlU3RydWN0dXJlcyhzdHJ1Y3R1cmVzLCBwYWNrcikge1xuXHRpZiAocGFja3IudHlwZWRTdHJ1Y3RzKSB7XG5cdFx0bGV0IHN0cnVjdE1hcCA9IG5ldyBNYXAoKTtcblx0XHRzdHJ1Y3RNYXAuc2V0KCduYW1lZCcsIHN0cnVjdHVyZXMpO1xuXHRcdHN0cnVjdE1hcC5zZXQoJ3R5cGVkJywgcGFja3IudHlwZWRTdHJ1Y3RzKTtcblx0XHRzdHJ1Y3R1cmVzID0gc3RydWN0TWFwO1xuXHR9XG5cdGxldCBsYXN0VHlwZWRTdHJ1Y3R1cmVzTGVuZ3RoID0gcGFja3IubGFzdFR5cGVkU3RydWN0dXJlc0xlbmd0aCB8fCAwO1xuXHRzdHJ1Y3R1cmVzLmlzQ29tcGF0aWJsZSA9IGV4aXN0aW5nID0+IHtcblx0XHRsZXQgY29tcGF0aWJsZSA9IHRydWU7XG5cdFx0aWYgKGV4aXN0aW5nIGluc3RhbmNlb2YgTWFwKSB7XG5cdFx0XHRsZXQgbmFtZWQgPSBleGlzdGluZy5nZXQoJ25hbWVkJykgfHwgW107XG5cdFx0XHRpZiAobmFtZWQubGVuZ3RoICE9PSAocGFja3IubGFzdE5hbWVkU3RydWN0dXJlc0xlbmd0aCB8fCAwKSlcblx0XHRcdFx0Y29tcGF0aWJsZSA9IGZhbHNlO1xuXHRcdFx0bGV0IHR5cGVkID0gZXhpc3RpbmcuZ2V0KCd0eXBlZCcpIHx8IFtdO1xuXHRcdFx0aWYgKHR5cGVkLmxlbmd0aCAhPT0gbGFzdFR5cGVkU3RydWN0dXJlc0xlbmd0aClcblx0XHRcdFx0Y29tcGF0aWJsZSA9IGZhbHNlO1xuXHRcdH0gZWxzZSBpZiAoZXhpc3RpbmcgaW5zdGFuY2VvZiBBcnJheSB8fCBBcnJheS5pc0FycmF5KGV4aXN0aW5nKSkge1xuXHRcdFx0aWYgKGV4aXN0aW5nLmxlbmd0aCAhPT0gKHBhY2tyLmxhc3ROYW1lZFN0cnVjdHVyZXNMZW5ndGggfHwgMCkpXG5cdFx0XHRcdGNvbXBhdGlibGUgPSBmYWxzZTtcblx0XHR9XG5cdFx0aWYgKCFjb21wYXRpYmxlKVxuXHRcdFx0cGFja3IuX21lcmdlU3RydWN0dXJlcyhleGlzdGluZyk7XG5cdFx0cmV0dXJuIGNvbXBhdGlibGU7XG5cdH07XG5cdHBhY2tyLmxhc3RUeXBlZFN0cnVjdHVyZXNMZW5ndGggPSBwYWNrci50eXBlZFN0cnVjdHMgJiYgcGFja3IudHlwZWRTdHJ1Y3RzLmxlbmd0aDtcblx0cmV0dXJuIHN0cnVjdHVyZXM7XG59XG5cbnNldFJlYWRTdHJ1Y3QocmVhZFN0cnVjdCwgb25Mb2FkZWRTdHJ1Y3R1cmVzLCBzYXZlU3RhdGUpO1xuXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../../node_modules/msgpackr/struct.js\n");

/***/ }),

/***/ "(action-browser)/../../node_modules/msgpackr/unpack.js":
/*!*********************************************!*\
  !*** ../../node_modules/msgpackr/unpack.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   C1: () => (/* binding */ C1),\n/* harmony export */   C1Type: () => (/* binding */ C1Type),\n/* harmony export */   Decoder: () => (/* binding */ Decoder),\n/* harmony export */   FLOAT32_OPTIONS: () => (/* binding */ FLOAT32_OPTIONS),\n/* harmony export */   Unpackr: () => (/* binding */ Unpackr),\n/* harmony export */   addExtension: () => (/* binding */ addExtension),\n/* harmony export */   checkedRead: () => (/* binding */ checkedRead),\n/* harmony export */   clearSource: () => (/* binding */ clearSource),\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   getPosition: () => (/* binding */ getPosition),\n/* harmony export */   isNativeAccelerationEnabled: () => (/* binding */ isNativeAccelerationEnabled),\n/* harmony export */   loadStructures: () => (/* binding */ loadStructures),\n/* harmony export */   mult10: () => (/* binding */ mult10),\n/* harmony export */   read: () => (/* binding */ read),\n/* harmony export */   readString: () => (/* binding */ readString),\n/* harmony export */   roundFloat32: () => (/* binding */ roundFloat32),\n/* harmony export */   setExtractor: () => (/* binding */ setExtractor),\n/* harmony export */   setReadStruct: () => (/* binding */ setReadStruct),\n/* harmony export */   typedArrays: () => (/* binding */ typedArrays),\n/* harmony export */   unpack: () => (/* binding */ unpack),\n/* harmony export */   unpackMultiple: () => (/* binding */ unpackMultiple)\n/* harmony export */ });\nvar decoder\ntry {\n\tdecoder = new TextDecoder()\n} catch(error) {}\nvar src\nvar srcEnd\nvar position = 0\nvar alreadySet\nconst EMPTY_ARRAY = []\nvar strings = EMPTY_ARRAY\nvar stringPosition = 0\nvar currentUnpackr = {}\nvar currentStructures\nvar srcString\nvar srcStringStart = 0\nvar srcStringEnd = 0\nvar bundledStrings\nvar referenceMap\nvar currentExtensions = []\nvar dataView\nvar defaultOptions = {\n\tuseRecords: false,\n\tmapsAsObjects: true\n}\nclass C1Type {}\nconst C1 = new C1Type()\nC1.name = 'MessagePack 0xC1'\nvar sequentialMode = false\nvar inlineObjectReadThreshold = 2\nvar readStruct, onLoadedStructures, onSaveState\nvar BlockedFunction // we use search and replace to change the next call to BlockedFunction to avoid CSP issues for\n// no-eval build\ntry {\n\tnew Function('')\n} catch(error) {\n\t// if eval variants are not supported, do not create inline object readers ever\n\tinlineObjectReadThreshold = Infinity\n}\n\nclass Unpackr {\n\tconstructor(options) {\n\t\tif (options) {\n\t\t\tif (options.useRecords === false && options.mapsAsObjects === undefined)\n\t\t\t\toptions.mapsAsObjects = true\n\t\t\tif (options.sequential && options.trusted !== false) {\n\t\t\t\toptions.trusted = true;\n\t\t\t\tif (!options.structures && options.useRecords != false) {\n\t\t\t\t\toptions.structures = []\n\t\t\t\t\tif (!options.maxSharedStructures)\n\t\t\t\t\t\toptions.maxSharedStructures = 0\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (options.structures)\n\t\t\t\toptions.structures.sharedLength = options.structures.length\n\t\t\telse if (options.getStructures) {\n\t\t\t\t(options.structures = []).uninitialized = true // this is what we use to denote an uninitialized structures\n\t\t\t\toptions.structures.sharedLength = 0\n\t\t\t}\n\t\t\tif (options.int64AsNumber) {\n\t\t\t\toptions.int64AsType = 'number'\n\t\t\t}\n\t\t}\n\t\tObject.assign(this, options)\n\t}\n\tunpack(source, options) {\n\t\tif (src) {\n\t\t\t// re-entrant execution, save the state and restore it after we do this unpack\n\t\t\treturn saveState(() => {\n\t\t\t\tclearSource()\n\t\t\t\treturn this ? this.unpack(source, options) : Unpackr.prototype.unpack.call(defaultOptions, source, options)\n\t\t\t})\n\t\t}\n\t\tif (!source.buffer && source.constructor === ArrayBuffer)\n\t\t\tsource = typeof Buffer !== 'undefined' ? Buffer.from(source) : new Uint8Array(source);\n\t\tif (typeof options === 'object') {\n\t\t\tsrcEnd = options.end || source.length\n\t\t\tposition = options.start || 0\n\t\t} else {\n\t\t\tposition = 0\n\t\t\tsrcEnd = options > -1 ? options : source.length\n\t\t}\n\t\tstringPosition = 0\n\t\tsrcStringEnd = 0\n\t\tsrcString = null\n\t\tstrings = EMPTY_ARRAY\n\t\tbundledStrings = null\n\t\tsrc = source\n\t\t// this provides cached access to the data view for a buffer if it is getting reused, which is a recommend\n\t\t// technique for getting data from a database where it can be copied into an existing buffer instead of creating\n\t\t// new ones\n\t\ttry {\n\t\t\tdataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength))\n\t\t} catch(error) {\n\t\t\t// if it doesn't have a buffer, maybe it is the wrong type of object\n\t\t\tsrc = null\n\t\t\tif (source instanceof Uint8Array)\n\t\t\t\tthrow error\n\t\t\tthrow new Error('Source must be a Uint8Array or Buffer but was a ' + ((source && typeof source == 'object') ? source.constructor.name : typeof source))\n\t\t}\n\t\tif (this instanceof Unpackr) {\n\t\t\tcurrentUnpackr = this\n\t\t\tif (this.structures) {\n\t\t\t\tcurrentStructures = this.structures\n\t\t\t\treturn checkedRead(options)\n\t\t\t} else if (!currentStructures || currentStructures.length > 0) {\n\t\t\t\tcurrentStructures = []\n\t\t\t}\n\t\t} else {\n\t\t\tcurrentUnpackr = defaultOptions\n\t\t\tif (!currentStructures || currentStructures.length > 0)\n\t\t\t\tcurrentStructures = []\n\t\t}\n\t\treturn checkedRead(options)\n\t}\n\tunpackMultiple(source, forEach) {\n\t\tlet values, lastPosition = 0\n\t\ttry {\n\t\t\tsequentialMode = true\n\t\t\tlet size = source.length\n\t\t\tlet value = this ? this.unpack(source, size) : defaultUnpackr.unpack(source, size)\n\t\t\tif (forEach) {\n\t\t\t\tif (forEach(value, lastPosition, position) === false) return;\n\t\t\t\twhile(position < size) {\n\t\t\t\t\tlastPosition = position\n\t\t\t\t\tif (forEach(checkedRead(), lastPosition, position) === false) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalues = [ value ]\n\t\t\t\twhile(position < size) {\n\t\t\t\t\tlastPosition = position\n\t\t\t\t\tvalues.push(checkedRead())\n\t\t\t\t}\n\t\t\t\treturn values\n\t\t\t}\n\t\t} catch(error) {\n\t\t\terror.lastPosition = lastPosition\n\t\t\terror.values = values\n\t\t\tthrow error\n\t\t} finally {\n\t\t\tsequentialMode = false\n\t\t\tclearSource()\n\t\t}\n\t}\n\t_mergeStructures(loadedStructures, existingStructures) {\n\t\tif (onLoadedStructures)\n\t\t\tloadedStructures = onLoadedStructures.call(this, loadedStructures);\n\t\tloadedStructures = loadedStructures || []\n\t\tif (Object.isFrozen(loadedStructures))\n\t\t\tloadedStructures = loadedStructures.map(structure => structure.slice(0))\n\t\tfor (let i = 0, l = loadedStructures.length; i < l; i++) {\n\t\t\tlet structure = loadedStructures[i]\n\t\t\tif (structure) {\n\t\t\t\tstructure.isShared = true\n\t\t\t\tif (i >= 32)\n\t\t\t\t\tstructure.highByte = (i - 32) >> 5\n\t\t\t}\n\t\t}\n\t\tloadedStructures.sharedLength = loadedStructures.length\n\t\tfor (let id in existingStructures || []) {\n\t\t\tif (id >= 0) {\n\t\t\t\tlet structure = loadedStructures[id]\n\t\t\t\tlet existing = existingStructures[id]\n\t\t\t\tif (existing) {\n\t\t\t\t\tif (structure)\n\t\t\t\t\t\t(loadedStructures.restoreStructures || (loadedStructures.restoreStructures = []))[id] = structure\n\t\t\t\t\tloadedStructures[id] = existing\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this.structures = loadedStructures\n\t}\n\tdecode(source, options) {\n\t\treturn this.unpack(source, options)\n\t}\n}\nfunction getPosition() {\n\treturn position\n}\nfunction checkedRead(options) {\n\ttry {\n\t\tif (!currentUnpackr.trusted && !sequentialMode) {\n\t\t\tlet sharedLength = currentStructures.sharedLength || 0\n\t\t\tif (sharedLength < currentStructures.length)\n\t\t\t\tcurrentStructures.length = sharedLength\n\t\t}\n\t\tlet result\n\t\tif (currentUnpackr.randomAccessStructure && src[position] < 0x40 && src[position] >= 0x20 && readStruct) {\n\t\t\tresult = readStruct(src, position, srcEnd, currentUnpackr)\n\t\t\tsrc = null // dispose of this so that recursive unpack calls don't save state\n\t\t\tif (!(options && options.lazy) && result)\n\t\t\t\tresult = result.toJSON()\n\t\t\tposition = srcEnd\n\t\t} else\n\t\t\tresult = read()\n\t\tif (bundledStrings) { // bundled strings to skip past\n\t\t\tposition = bundledStrings.postBundlePosition\n\t\t\tbundledStrings = null\n\t\t}\n\t\tif (sequentialMode)\n\t\t\t// we only need to restore the structures if there was an error, but if we completed a read,\n\t\t\t// we can clear this out and keep the structures we read\n\t\t\tcurrentStructures.restoreStructures = null\n\n\t\tif (position == srcEnd) {\n\t\t\t// finished reading this source, cleanup references\n\t\t\tif (currentStructures && currentStructures.restoreStructures)\n\t\t\t\trestoreStructures()\n\t\t\tcurrentStructures = null\n\t\t\tsrc = null\n\t\t\tif (referenceMap)\n\t\t\t\treferenceMap = null\n\t\t} else if (position > srcEnd) {\n\t\t\t// over read\n\t\t\tthrow new Error('Unexpected end of MessagePack data')\n\t\t} else if (!sequentialMode) {\n\t\t\tlet jsonView;\n\t\t\ttry {\n\t\t\t\tjsonView = JSON.stringify(result, (_, value) => typeof value === \"bigint\" ? `${value}n` : value).slice(0, 100)\n\t\t\t} catch(error) {\n\t\t\t\tjsonView = '(JSON view not available ' + error + ')'\n\t\t\t}\n\t\t\tthrow new Error('Data read, but end of buffer not reached ' + jsonView)\n\t\t}\n\t\t// else more to read, but we are reading sequentially, so don't clear source yet\n\t\treturn result\n\t} catch(error) {\n\t\tif (currentStructures && currentStructures.restoreStructures)\n\t\t\trestoreStructures()\n\t\tclearSource()\n\t\tif (error instanceof RangeError || error.message.startsWith('Unexpected end of buffer') || position > srcEnd) {\n\t\t\terror.incomplete = true\n\t\t}\n\t\tthrow error\n\t}\n}\n\nfunction restoreStructures() {\n\tfor (let id in currentStructures.restoreStructures) {\n\t\tcurrentStructures[id] = currentStructures.restoreStructures[id]\n\t}\n\tcurrentStructures.restoreStructures = null\n}\n\nfunction read() {\n\tlet token = src[position++]\n\tif (token < 0xa0) {\n\t\tif (token < 0x80) {\n\t\t\tif (token < 0x40)\n\t\t\t\treturn token\n\t\t\telse {\n\t\t\t\tlet structure = currentStructures[token & 0x3f] ||\n\t\t\t\t\tcurrentUnpackr.getStructures && loadStructures()[token & 0x3f]\n\t\t\t\tif (structure) {\n\t\t\t\t\tif (!structure.read) {\n\t\t\t\t\t\tstructure.read = createStructureReader(structure, token & 0x3f)\n\t\t\t\t\t}\n\t\t\t\t\treturn structure.read()\n\t\t\t\t} else\n\t\t\t\t\treturn token\n\t\t\t}\n\t\t} else if (token < 0x90) {\n\t\t\t// map\n\t\t\ttoken -= 0x80\n\t\t\tif (currentUnpackr.mapsAsObjects) {\n\t\t\t\tlet object = {}\n\t\t\t\tfor (let i = 0; i < token; i++) {\n\t\t\t\t\tlet key = readKey()\n\t\t\t\t\tif (key === '__proto__')\n\t\t\t\t\t\tkey = '__proto_'\n\t\t\t\t\tobject[key] = read()\n\t\t\t\t}\n\t\t\t\treturn object\n\t\t\t} else {\n\t\t\t\tlet map = new Map()\n\t\t\t\tfor (let i = 0; i < token; i++) {\n\t\t\t\t\tmap.set(read(), read())\n\t\t\t\t}\n\t\t\t\treturn map\n\t\t\t}\n\t\t} else {\n\t\t\ttoken -= 0x90\n\t\t\tlet array = new Array(token)\n\t\t\tfor (let i = 0; i < token; i++) {\n\t\t\t\tarray[i] = read()\n\t\t\t}\n\t\t\tif (currentUnpackr.freezeData)\n\t\t\t\treturn Object.freeze(array)\n\t\t\treturn array\n\t\t}\n\t} else if (token < 0xc0) {\n\t\t// fixstr\n\t\tlet length = token - 0xa0\n\t\tif (srcStringEnd >= position) {\n\t\t\treturn srcString.slice(position - srcStringStart, (position += length) - srcStringStart)\n\t\t}\n\t\tif (srcStringEnd == 0 && srcEnd < 140) {\n\t\t\t// for small blocks, avoiding the overhead of the extract call is helpful\n\t\t\tlet string = length < 16 ? shortStringInJS(length) : longStringInJS(length)\n\t\t\tif (string != null)\n\t\t\t\treturn string\n\t\t}\n\t\treturn readFixedString(length)\n\t} else {\n\t\tlet value\n\t\tswitch (token) {\n\t\t\tcase 0xc0: return null\n\t\t\tcase 0xc1:\n\t\t\t\tif (bundledStrings) {\n\t\t\t\t\tvalue = read() // followed by the length of the string in characters (not bytes!)\n\t\t\t\t\tif (value > 0)\n\t\t\t\t\t\treturn bundledStrings[1].slice(bundledStrings.position1, bundledStrings.position1 += value)\n\t\t\t\t\telse\n\t\t\t\t\t\treturn bundledStrings[0].slice(bundledStrings.position0, bundledStrings.position0 -= value)\n\t\t\t\t}\n\t\t\t\treturn C1; // \"never-used\", return special object to denote that\n\t\t\tcase 0xc2: return false\n\t\t\tcase 0xc3: return true\n\t\t\tcase 0xc4:\n\t\t\t\t// bin 8\n\t\t\t\tvalue = src[position++]\n\t\t\t\tif (value === undefined)\n\t\t\t\t\tthrow new Error('Unexpected end of buffer')\n\t\t\t\treturn readBin(value)\n\t\t\tcase 0xc5:\n\t\t\t\t// bin 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readBin(value)\n\t\t\tcase 0xc6:\n\t\t\t\t// bin 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readBin(value)\n\t\t\tcase 0xc7:\n\t\t\t\t// ext 8\n\t\t\t\treturn readExt(src[position++])\n\t\t\tcase 0xc8:\n\t\t\t\t// ext 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readExt(value)\n\t\t\tcase 0xc9:\n\t\t\t\t// ext 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readExt(value)\n\t\t\tcase 0xca:\n\t\t\t\tvalue = dataView.getFloat32(position)\n\t\t\t\tif (currentUnpackr.useFloat32 > 2) {\n\t\t\t\t\t// this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\tlet multiplier = mult10[((src[position] & 0x7f) << 1) | (src[position + 1] >> 7)]\n\t\t\t\t\tposition += 4\n\t\t\t\t\treturn ((multiplier * value + (value > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n\t\t\t\t}\n\t\t\t\tposition += 4\n\t\t\t\treturn value\n\t\t\tcase 0xcb:\n\t\t\t\tvalue = dataView.getFloat64(position)\n\t\t\t\tposition += 8\n\t\t\t\treturn value\n\t\t\t// uint handlers\n\t\t\tcase 0xcc:\n\t\t\t\treturn src[position++]\n\t\t\tcase 0xcd:\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn value\n\t\t\tcase 0xce:\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn value\n\t\t\tcase 0xcf:\n\t\t\t\tif (currentUnpackr.int64AsType === 'number') {\n\t\t\t\t\tvalue = dataView.getUint32(position) * 0x100000000\n\t\t\t\t\tvalue += dataView.getUint32(position + 4)\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'string') {\n\t\t\t\t\tvalue = dataView.getBigUint64(position).toString()\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'auto') {\n\t\t\t\t\tvalue = dataView.getBigUint64(position)\n\t\t\t\t\tif (value<=BigInt(2)<<BigInt(52)) value=Number(value)\n\t\t\t\t} else\n\t\t\t\t\tvalue = dataView.getBigUint64(position)\n\t\t\t\tposition += 8\n\t\t\t\treturn value\n\n\t\t\t// int handlers\n\t\t\tcase 0xd0:\n\t\t\t\treturn dataView.getInt8(position++)\n\t\t\tcase 0xd1:\n\t\t\t\tvalue = dataView.getInt16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn value\n\t\t\tcase 0xd2:\n\t\t\t\tvalue = dataView.getInt32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn value\n\t\t\tcase 0xd3:\n\t\t\t\tif (currentUnpackr.int64AsType === 'number') {\n\t\t\t\t\tvalue = dataView.getInt32(position) * 0x100000000\n\t\t\t\t\tvalue += dataView.getUint32(position + 4)\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'string') {\n\t\t\t\t\tvalue = dataView.getBigInt64(position).toString()\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'auto') {\n\t\t\t\t\tvalue = dataView.getBigInt64(position)\n\t\t\t\t\tif (value>=BigInt(-2)<<BigInt(52)&&value<=BigInt(2)<<BigInt(52)) value=Number(value)\n\t\t\t\t} else\n\t\t\t\t\tvalue = dataView.getBigInt64(position)\n\t\t\t\tposition += 8\n\t\t\t\treturn value\n\n\t\t\tcase 0xd4:\n\t\t\t\t// fixext 1\n\t\t\t\tvalue = src[position++]\n\t\t\t\tif (value == 0x72) {\n\t\t\t\t\treturn recordDefinition(src[position++] & 0x3f)\n\t\t\t\t} else {\n\t\t\t\t\tlet extension = currentExtensions[value]\n\t\t\t\t\tif (extension) {\n\t\t\t\t\t\tif (extension.read) {\n\t\t\t\t\t\t\tposition++ // skip filler byte\n\t\t\t\t\t\t\treturn extension.read(read())\n\t\t\t\t\t\t} else if (extension.noBuffer) {\n\t\t\t\t\t\t\tposition++ // skip filler byte\n\t\t\t\t\t\t\treturn extension()\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\treturn extension(src.subarray(position, ++position))\n\t\t\t\t\t} else\n\t\t\t\t\t\tthrow new Error('Unknown extension ' + value)\n\t\t\t\t}\n\t\t\tcase 0xd5:\n\t\t\t\t// fixext 2\n\t\t\t\tvalue = src[position]\n\t\t\t\tif (value == 0x72) {\n\t\t\t\t\tposition++\n\t\t\t\t\treturn recordDefinition(src[position++] & 0x3f, src[position++])\n\t\t\t\t} else\n\t\t\t\t\treturn readExt(2)\n\t\t\tcase 0xd6:\n\t\t\t\t// fixext 4\n\t\t\t\treturn readExt(4)\n\t\t\tcase 0xd7:\n\t\t\t\t// fixext 8\n\t\t\t\treturn readExt(8)\n\t\t\tcase 0xd8:\n\t\t\t\t// fixext 16\n\t\t\t\treturn readExt(16)\n\t\t\tcase 0xd9:\n\t\t\t// str 8\n\t\t\t\tvalue = src[position++]\n\t\t\t\tif (srcStringEnd >= position) {\n\t\t\t\t\treturn srcString.slice(position - srcStringStart, (position += value) - srcStringStart)\n\t\t\t\t}\n\t\t\t\treturn readString8(value)\n\t\t\tcase 0xda:\n\t\t\t// str 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\tif (srcStringEnd >= position) {\n\t\t\t\t\treturn srcString.slice(position - srcStringStart, (position += value) - srcStringStart)\n\t\t\t\t}\n\t\t\t\treturn readString16(value)\n\t\t\tcase 0xdb:\n\t\t\t// str 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\tif (srcStringEnd >= position) {\n\t\t\t\t\treturn srcString.slice(position - srcStringStart, (position += value) - srcStringStart)\n\t\t\t\t}\n\t\t\t\treturn readString32(value)\n\t\t\tcase 0xdc:\n\t\t\t// array 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readArray(value)\n\t\t\tcase 0xdd:\n\t\t\t// array 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readArray(value)\n\t\t\tcase 0xde:\n\t\t\t// map 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readMap(value)\n\t\t\tcase 0xdf:\n\t\t\t// map 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readMap(value)\n\t\t\tdefault: // negative int\n\t\t\t\tif (token >= 0xe0)\n\t\t\t\t\treturn token - 0x100\n\t\t\t\tif (token === undefined) {\n\t\t\t\t\tlet error = new Error('Unexpected end of MessagePack data')\n\t\t\t\t\terror.incomplete = true\n\t\t\t\t\tthrow error\n\t\t\t\t}\n\t\t\t\tthrow new Error('Unknown MessagePack token ' + token)\n\n\t\t}\n\t}\n}\nconst validName = /^[a-zA-Z_$][a-zA-Z\\d_$]*$/\nfunction createStructureReader(structure, firstId) {\n\tfunction readObject() {\n\t\t// This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function\n\t\tif (readObject.count++ > inlineObjectReadThreshold) {\n\t\t\tlet readObject = structure.read = (new Function('r', 'return function(){return ' + (currentUnpackr.freezeData ? 'Object.freeze' : '') +\n\t\t\t\t'({' + structure.map(key => key === '__proto__' ? '__proto_:r()' : validName.test(key) ? key + ':r()' : ('[' + JSON.stringify(key) + ']:r()')).join(',') + '})}'))(read)\n\t\t\tif (structure.highByte === 0)\n\t\t\t\tstructure.read = createSecondByteReader(firstId, structure.read)\n\t\t\treturn readObject() // second byte is already read, if there is one so immediately read object\n\t\t}\n\t\tlet object = {}\n\t\tfor (let i = 0, l = structure.length; i < l; i++) {\n\t\t\tlet key = structure[i]\n\t\t\tif (key === '__proto__')\n\t\t\t\tkey = '__proto_'\n\t\t\tobject[key] = read()\n\t\t}\n\t\tif (currentUnpackr.freezeData)\n\t\t\treturn Object.freeze(object);\n\t\treturn object\n\t}\n\treadObject.count = 0\n\tif (structure.highByte === 0) {\n\t\treturn createSecondByteReader(firstId, readObject)\n\t}\n\treturn readObject\n}\n\nconst createSecondByteReader = (firstId, read0) => {\n\treturn function() {\n\t\tlet highByte = src[position++]\n\t\tif (highByte === 0)\n\t\t\treturn read0()\n\t\tlet id = firstId < 32 ? -(firstId + (highByte << 5)) : firstId + (highByte << 5)\n\t\tlet structure = currentStructures[id] || loadStructures()[id]\n\t\tif (!structure) {\n\t\t\tthrow new Error('Record id is not defined for ' + id)\n\t\t}\n\t\tif (!structure.read)\n\t\t\tstructure.read = createStructureReader(structure, firstId)\n\t\treturn structure.read()\n\t}\n}\n\nfunction loadStructures() {\n\tlet loadedStructures = saveState(() => {\n\t\t// save the state in case getStructures modifies our buffer\n\t\tsrc = null\n\t\treturn currentUnpackr.getStructures()\n\t})\n\treturn currentStructures = currentUnpackr._mergeStructures(loadedStructures, currentStructures)\n}\n\nvar readFixedString = readStringJS\nvar readString8 = readStringJS\nvar readString16 = readStringJS\nvar readString32 = readStringJS\nlet isNativeAccelerationEnabled = false\n\nfunction setExtractor(extractStrings) {\n\tisNativeAccelerationEnabled = true\n\treadFixedString = readString(1)\n\treadString8 = readString(2)\n\treadString16 = readString(3)\n\treadString32 = readString(5)\n\tfunction readString(headerLength) {\n\t\treturn function readString(length) {\n\t\t\tlet string = strings[stringPosition++]\n\t\t\tif (string == null) {\n\t\t\t\tif (bundledStrings)\n\t\t\t\t\treturn readStringJS(length)\n\t\t\t\tlet byteOffset = src.byteOffset\n\t\t\t\tlet extraction = extractStrings(position - headerLength + byteOffset, srcEnd + byteOffset, src.buffer)\n\t\t\t\tif (typeof extraction == 'string') {\n\t\t\t\t\tstring = extraction\n\t\t\t\t\tstrings = EMPTY_ARRAY\n\t\t\t\t} else {\n\t\t\t\t\tstrings = extraction\n\t\t\t\t\tstringPosition = 1\n\t\t\t\t\tsrcStringEnd = 1 // even if a utf-8 string was decoded, must indicate we are in the midst of extracted strings and can't skip strings\n\t\t\t\t\tstring = strings[0]\n\t\t\t\t\tif (string === undefined)\n\t\t\t\t\t\tthrow new Error('Unexpected end of buffer')\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet srcStringLength = string.length\n\t\t\tif (srcStringLength <= length) {\n\t\t\t\tposition += length\n\t\t\t\treturn string\n\t\t\t}\n\t\t\tsrcString = string\n\t\t\tsrcStringStart = position\n\t\t\tsrcStringEnd = position + srcStringLength\n\t\t\tposition += length\n\t\t\treturn string.slice(0, length) // we know we just want the beginning\n\t\t}\n\t}\n}\nfunction readStringJS(length) {\n\tlet result\n\tif (length < 16) {\n\t\tif (result = shortStringInJS(length))\n\t\t\treturn result\n\t}\n\tif (length > 64 && decoder)\n\t\treturn decoder.decode(src.subarray(position, position += length))\n\tconst end = position + length\n\tconst units = []\n\tresult = ''\n\twhile (position < end) {\n\t\tconst byte1 = src[position++]\n\t\tif ((byte1 & 0x80) === 0) {\n\t\t\t// 1 byte\n\t\t\tunits.push(byte1)\n\t\t} else if ((byte1 & 0xe0) === 0xc0) {\n\t\t\t// 2 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 6) | byte2)\n\t\t} else if ((byte1 & 0xf0) === 0xe0) {\n\t\t\t// 3 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3)\n\t\t} else if ((byte1 & 0xf8) === 0xf0) {\n\t\t\t// 4 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tconst byte4 = src[position++] & 0x3f\n\t\t\tlet unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4\n\t\t\tif (unit > 0xffff) {\n\t\t\t\tunit -= 0x10000\n\t\t\t\tunits.push(((unit >>> 10) & 0x3ff) | 0xd800)\n\t\t\t\tunit = 0xdc00 | (unit & 0x3ff)\n\t\t\t}\n\t\t\tunits.push(unit)\n\t\t} else {\n\t\t\tunits.push(byte1)\n\t\t}\n\n\t\tif (units.length >= 0x1000) {\n\t\t\tresult += fromCharCode.apply(String, units)\n\t\t\tunits.length = 0\n\t\t}\n\t}\n\n\tif (units.length > 0) {\n\t\tresult += fromCharCode.apply(String, units)\n\t}\n\n\treturn result\n}\nfunction readString(source, start, length) {\n\tlet existingSrc = src;\n\tsrc = source;\n\tposition = start;\n\ttry {\n\t\treturn readStringJS(length);\n\t} finally {\n\t\tsrc = existingSrc;\n\t}\n}\n\nfunction readArray(length) {\n\tlet array = new Array(length)\n\tfor (let i = 0; i < length; i++) {\n\t\tarray[i] = read()\n\t}\n\tif (currentUnpackr.freezeData)\n\t\treturn Object.freeze(array)\n\treturn array\n}\n\nfunction readMap(length) {\n\tif (currentUnpackr.mapsAsObjects) {\n\t\tlet object = {}\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tlet key = readKey()\n\t\t\tif (key === '__proto__')\n\t\t\t\tkey = '__proto_';\n\t\t\tobject[key] = read()\n\t\t}\n\t\treturn object\n\t} else {\n\t\tlet map = new Map()\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tmap.set(read(), read())\n\t\t}\n\t\treturn map\n\t}\n}\n\nvar fromCharCode = String.fromCharCode\nfunction longStringInJS(length) {\n\tlet start = position\n\tlet bytes = new Array(length)\n\tfor (let i = 0; i < length; i++) {\n\t\tconst byte = src[position++];\n\t\tif ((byte & 0x80) > 0) {\n\t\t\t\tposition = start\n\t\t\t\treturn\n\t\t\t}\n\t\t\tbytes[i] = byte\n\t\t}\n\t\treturn fromCharCode.apply(String, bytes)\n}\nfunction shortStringInJS(length) {\n\tif (length < 4) {\n\t\tif (length < 2) {\n\t\t\tif (length === 0)\n\t\t\t\treturn ''\n\t\t\telse {\n\t\t\t\tlet a = src[position++]\n\t\t\t\tif ((a & 0x80) > 1) {\n\t\t\t\t\tposition -= 1\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a)\n\t\t\t}\n\t\t} else {\n\t\t\tlet a = src[position++]\n\t\t\tlet b = src[position++]\n\t\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0) {\n\t\t\t\tposition -= 2\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 3)\n\t\t\t\treturn fromCharCode(a, b)\n\t\t\tlet c = src[position++]\n\t\t\tif ((c & 0x80) > 0) {\n\t\t\t\tposition -= 3\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c)\n\t\t}\n\t} else {\n\t\tlet a = src[position++]\n\t\tlet b = src[position++]\n\t\tlet c = src[position++]\n\t\tlet d = src[position++]\n\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {\n\t\t\tposition -= 4\n\t\t\treturn\n\t\t}\n\t\tif (length < 6) {\n\t\t\tif (length === 4)\n\t\t\t\treturn fromCharCode(a, b, c, d)\n\t\t\telse {\n\t\t\t\tlet e = src[position++]\n\t\t\t\tif ((e & 0x80) > 0) {\n\t\t\t\t\tposition -= 5\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e)\n\t\t\t}\n\t\t} else if (length < 8) {\n\t\t\tlet e = src[position++]\n\t\t\tlet f = src[position++]\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0) {\n\t\t\t\tposition -= 6\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 7)\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f)\n\t\t\tlet g = src[position++]\n\t\t\tif ((g & 0x80) > 0) {\n\t\t\t\tposition -= 7\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c, d, e, f, g)\n\t\t} else {\n\t\t\tlet e = src[position++]\n\t\t\tlet f = src[position++]\n\t\t\tlet g = src[position++]\n\t\t\tlet h = src[position++]\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0 || (g & 0x80) > 0 || (h & 0x80) > 0) {\n\t\t\t\tposition -= 8\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 10) {\n\t\t\t\tif (length === 8)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h)\n\t\t\t\telse {\n\t\t\t\t\tlet i = src[position++]\n\t\t\t\t\tif ((i & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 9\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i)\n\t\t\t\t}\n\t\t\t} else if (length < 12) {\n\t\t\t\tlet i = src[position++]\n\t\t\t\tlet j = src[position++]\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0) {\n\t\t\t\t\tposition -= 10\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length < 11)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j)\n\t\t\t\tlet k = src[position++]\n\t\t\t\tif ((k & 0x80) > 0) {\n\t\t\t\t\tposition -= 11\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k)\n\t\t\t} else {\n\t\t\t\tlet i = src[position++]\n\t\t\t\tlet j = src[position++]\n\t\t\t\tlet k = src[position++]\n\t\t\t\tlet l = src[position++]\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0 || (k & 0x80) > 0 || (l & 0x80) > 0) {\n\t\t\t\t\tposition -= 12\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length < 14) {\n\t\t\t\t\tif (length === 12)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l)\n\t\t\t\t\telse {\n\t\t\t\t\t\tlet m = src[position++]\n\t\t\t\t\t\tif ((m & 0x80) > 0) {\n\t\t\t\t\t\t\tposition -= 13\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet m = src[position++]\n\t\t\t\t\tlet n = src[position++]\n\t\t\t\t\tif ((m & 0x80) > 0 || (n & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 14\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tif (length < 15)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n)\n\t\t\t\t\tlet o = src[position++]\n\t\t\t\t\tif ((o & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 15\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction readOnlyJSString() {\n\tlet token = src[position++]\n\tlet length\n\tif (token < 0xc0) {\n\t\t// fixstr\n\t\tlength = token - 0xa0\n\t} else {\n\t\tswitch(token) {\n\t\t\tcase 0xd9:\n\t\t\t// str 8\n\t\t\t\tlength = src[position++]\n\t\t\t\tbreak\n\t\t\tcase 0xda:\n\t\t\t// str 16\n\t\t\t\tlength = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\tbreak\n\t\t\tcase 0xdb:\n\t\t\t// str 32\n\t\t\t\tlength = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\tbreak\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Expected string')\n\t\t}\n\t}\n\treturn readStringJS(length)\n}\n\n\nfunction readBin(length) {\n\treturn currentUnpackr.copyBuffers ?\n\t\t// specifically use the copying slice (not the node one)\n\t\tUint8Array.prototype.slice.call(src, position, position += length) :\n\t\tsrc.subarray(position, position += length)\n}\nfunction readExt(length) {\n\tlet type = src[position++]\n\tif (currentExtensions[type]) {\n\t\tlet end\n\t\treturn currentExtensions[type](src.subarray(position, end = (position += length)), (readPosition) => {\n\t\t\tposition = readPosition;\n\t\t\ttry {\n\t\t\t\treturn read();\n\t\t\t} finally {\n\t\t\t\tposition = end;\n\t\t\t}\n\t\t})\n\t}\n\telse\n\t\tthrow new Error('Unknown extension type ' + type)\n}\n\nvar keyCache = new Array(4096)\nfunction readKey() {\n\tlet length = src[position++]\n\tif (length >= 0xa0 && length < 0xc0) {\n\t\t// fixstr, potentially use key cache\n\t\tlength = length - 0xa0\n\t\tif (srcStringEnd >= position) // if it has been extracted, must use it (and faster anyway)\n\t\t\treturn srcString.slice(position - srcStringStart, (position += length) - srcStringStart)\n\t\telse if (!(srcStringEnd == 0 && srcEnd < 180))\n\t\t\treturn readFixedString(length)\n\t} else { // not cacheable, go back and do a standard read\n\t\tposition--\n\t\treturn asSafeString(read())\n\t}\n\tlet key = ((length << 5) ^ (length > 1 ? dataView.getUint16(position) : length > 0 ? src[position] : 0)) & 0xfff\n\tlet entry = keyCache[key]\n\tlet checkPosition = position\n\tlet end = position + length - 3\n\tlet chunk\n\tlet i = 0\n\tif (entry && entry.bytes == length) {\n\t\twhile (checkPosition < end) {\n\t\t\tchunk = dataView.getUint32(checkPosition)\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcheckPosition += 4\n\t\t}\n\t\tend += 3\n\t\twhile (checkPosition < end) {\n\t\t\tchunk = src[checkPosition++]\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif (checkPosition === end) {\n\t\t\tposition = checkPosition\n\t\t\treturn entry.string\n\t\t}\n\t\tend -= 3\n\t\tcheckPosition = position\n\t}\n\tentry = []\n\tkeyCache[key] = entry\n\tentry.bytes = length\n\twhile (checkPosition < end) {\n\t\tchunk = dataView.getUint32(checkPosition)\n\t\tentry.push(chunk)\n\t\tcheckPosition += 4\n\t}\n\tend += 3\n\twhile (checkPosition < end) {\n\t\tchunk = src[checkPosition++]\n\t\tentry.push(chunk)\n\t}\n\t// for small blocks, avoiding the overhead of the extract call is helpful\n\tlet string = length < 16 ? shortStringInJS(length) : longStringInJS(length)\n\tif (string != null)\n\t\treturn entry.string = string\n\treturn entry.string = readFixedString(length)\n}\n\nfunction asSafeString(property) {\n\t// protect against expensive (DoS) string conversions\n\tif (typeof property === 'string') return property;\n\tif (typeof property === 'number' || typeof property === 'boolean' || typeof property === 'bigint') return property.toString();\n\tif (property == null) return property + '';\n\tif (currentUnpackr.allowArraysInMapKeys && Array.isArray(property) && property.flat().every(item => ['string', 'number', 'boolean', 'bigint'].includes(typeof item))) {\n\t\treturn property.flat().toString();\n\t}\n\tthrow new Error(`Invalid property type for record: ${typeof property}`);\n}\n// the registration of the record definition extension (as \"r\")\nconst recordDefinition = (id, highByte) => {\n\tlet structure = read().map(asSafeString) // ensure that all keys are strings and\n\t// that the array is mutable\n\tlet firstByte = id\n\tif (highByte !== undefined) {\n\t\tid = id < 32 ? -((highByte << 5) + id) : ((highByte << 5) + id)\n\t\tstructure.highByte = highByte\n\t}\n\tlet existingStructure = currentStructures[id]\n\t// If it is a shared structure, we need to restore any changes after reading.\n\t// Also in sequential mode, we may get incomplete reads and thus errors, and we need to restore\n\t// to the state prior to an incomplete read in order to properly resume.\n\tif (existingStructure && (existingStructure.isShared || sequentialMode)) {\n\t\t(currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure\n\t}\n\tcurrentStructures[id] = structure\n\tstructure.read = createStructureReader(structure, firstByte)\n\treturn structure.read()\n}\ncurrentExtensions[0] = () => {} // notepack defines extension 0 to mean undefined, so use that as the default here\ncurrentExtensions[0].noBuffer = true\n\ncurrentExtensions[0x42] = data => {\n\tlet headLength = (data.byteLength % 8) || 8\n\tlet head = BigInt(data[0] & 0x80 ? data[0] - 0x100 : data[0])\n\tfor (let i = 1; i < headLength; i++) {\n\t\thead <<= BigInt(8)\n\t\thead += BigInt(data[i])\n\t}\n\tif (data.byteLength !== headLength) {\n\t\tlet view = new DataView(data.buffer, data.byteOffset, data.byteLength)\n\t\tlet decode = (start, end) => {\n\t\t\tlet length = end - start\n\t\t\tif (length <= 40) {\n\t\t\t\tlet out = view.getBigUint64(start)\n\t\t\t\tfor (let i = start + 8; i < end; i += 8) {\n\t\t\t\t\tout <<= BigInt(64n)\n\t\t\t\t\tout |= view.getBigUint64(i)\n\t\t\t\t}\n\t\t\t\treturn out\n\t\t\t}\n\t\t\t// if (length === 8) return view.getBigUint64(start)\n\t\t\tlet middle = start + (length >> 4 << 3)\n\t\t\tlet left = decode(start, middle)\n\t\t\tlet right = decode(middle, end)\n\t\t\treturn (left << BigInt((end - middle) * 8)) | right\n\t\t}\n\t\thead = (head << BigInt((view.byteLength - headLength) * 8)) | decode(headLength, view.byteLength)\n\t}\n\treturn head\n}\n\nlet errors = {\n\tError, EvalError, RangeError, ReferenceError, SyntaxError, TypeError, URIError, AggregateError: typeof AggregateError === 'function' ? AggregateError : null,\n}\ncurrentExtensions[0x65] = () => {\n\tlet data = read()\n\tif (!errors[data[0]]) {\n\t\tlet error = Error(data[1], { cause: data[2] })\n\t\terror.name = data[0]\n\t\treturn error\n\t}\n\treturn errors[data[0]](data[1], { cause: data[2] })\n}\n\ncurrentExtensions[0x69] = (data) => {\n\t// id extension (for structured clones)\n\tif (currentUnpackr.structuredClone === false) throw new Error('Structured clone extension is disabled')\n\tlet id = dataView.getUint32(position - 4)\n\tif (!referenceMap)\n\t\treferenceMap = new Map()\n\tlet token = src[position]\n\tlet target\n\t// TODO: handle any other types that can cycle and make the code more robust if there are other extensions\n\tif (token >= 0x90 && token < 0xa0 || token == 0xdc || token == 0xdd)\n\t\ttarget = []\n\telse if (token >= 0x80 && token < 0x90 || token == 0xde || token == 0xdf)\n\t\ttarget = new Map()\n\telse if ((token >= 0xc7 && token <= 0xc9 || token >= 0xd4 && token <= 0xd8) && src[position + 1] === 0x73)\n\t\ttarget = new Set()\n\telse\n\t\ttarget = {}\n\n\tlet refEntry = { target } // a placeholder object\n\treferenceMap.set(id, refEntry)\n\tlet targetProperties = read() // read the next value as the target object to id\n\tif (!refEntry.used) {\n\t\t// no cycle, can just use the returned read object\n\t\treturn refEntry.target = targetProperties // replace the placeholder with the real one\n\t} else {\n\t\t// there is a cycle, so we have to assign properties to original target\n\t\tObject.assign(target, targetProperties)\n\t}\n\n\t// copy over map/set entries if we're able to\n\tif (target instanceof Map)\n\t\tfor (let [k, v] of targetProperties.entries()) target.set(k, v)\n\tif (target instanceof Set)\n\t\tfor (let i of Array.from(targetProperties)) target.add(i)\n\treturn target\n}\n\ncurrentExtensions[0x70] = (data) => {\n\t// pointer extension (for structured clones)\n\tif (currentUnpackr.structuredClone === false) throw new Error('Structured clone extension is disabled')\n\tlet id = dataView.getUint32(position - 4)\n\tlet refEntry = referenceMap.get(id)\n\trefEntry.used = true\n\treturn refEntry.target\n}\n\ncurrentExtensions[0x73] = () => new Set(read())\n\nconst typedArrays = ['Int8','Uint8','Uint8Clamped','Int16','Uint16','Int32','Uint32','Float32','Float64','BigInt64','BigUint64'].map(type => type + 'Array')\n\nlet glbl = typeof globalThis === 'object' ? globalThis : window;\ncurrentExtensions[0x74] = (data) => {\n\tlet typeCode = data[0]\n\t// we always have to slice to get a new ArrayBuffer that is aligned\n\tlet buffer = Uint8Array.prototype.slice.call(data, 1).buffer\n\n\tlet typedArrayName = typedArrays[typeCode]\n\tif (!typedArrayName) {\n\t\tif (typeCode === 16) return buffer\n\t\tif (typeCode === 17) return new DataView(buffer)\n\t\tthrow new Error('Could not find typed array for code ' + typeCode)\n\t}\n\treturn new glbl[typedArrayName](buffer)\n}\ncurrentExtensions[0x78] = () => {\n\tlet data = read()\n\treturn new RegExp(data[0], data[1])\n}\nconst TEMP_BUNDLE = []\ncurrentExtensions[0x62] = (data) => {\n\tlet dataSize = (data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3]\n\tlet dataPosition = position\n\tposition += dataSize - data.length\n\tbundledStrings = TEMP_BUNDLE\n\tbundledStrings = [readOnlyJSString(), readOnlyJSString()]\n\tbundledStrings.position0 = 0\n\tbundledStrings.position1 = 0\n\tbundledStrings.postBundlePosition = position\n\tposition = dataPosition\n\treturn read()\n}\n\ncurrentExtensions[0xff] = (data) => {\n\t// 32-bit date extension\n\tif (data.length == 4)\n\t\treturn new Date((data[0] * 0x1000000 + (data[1] << 16) + (data[2] << 8) + data[3]) * 1000)\n\telse if (data.length == 8)\n\t\treturn new Date(\n\t\t\t((data[0] << 22) + (data[1] << 14) + (data[2] << 6) + (data[3] >> 2)) / 1000000 +\n\t\t\t((data[3] & 0x3) * 0x100000000 + data[4] * 0x1000000 + (data[5] << 16) + (data[6] << 8) + data[7]) * 1000)\n\telse if (data.length == 12)\n\t\treturn new Date(\n\t\t\t((data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3]) / 1000000 +\n\t\t\t(((data[4] & 0x80) ? -0x1000000000000 : 0) + data[6] * 0x10000000000 + data[7] * 0x100000000 + data[8] * 0x1000000 + (data[9] << 16) + (data[10] << 8) + data[11]) * 1000)\n\telse\n\t\treturn new Date('invalid')\n}\n// registration of bulk record definition?\n// currentExtensions[0x52] = () =>\n\nfunction saveState(callback) {\n\tif (onSaveState)\n\t\tonSaveState();\n\tlet savedSrcEnd = srcEnd\n\tlet savedPosition = position\n\tlet savedStringPosition = stringPosition\n\tlet savedSrcStringStart = srcStringStart\n\tlet savedSrcStringEnd = srcStringEnd\n\tlet savedSrcString = srcString\n\tlet savedStrings = strings\n\tlet savedReferenceMap = referenceMap\n\tlet savedBundledStrings = bundledStrings\n\n\t// TODO: We may need to revisit this if we do more external calls to user code (since it could be slow)\n\tlet savedSrc = new Uint8Array(src.slice(0, srcEnd)) // we copy the data in case it changes while external data is processed\n\tlet savedStructures = currentStructures\n\tlet savedStructuresContents = currentStructures.slice(0, currentStructures.length)\n\tlet savedPackr = currentUnpackr\n\tlet savedSequentialMode = sequentialMode\n\tlet value = callback()\n\tsrcEnd = savedSrcEnd\n\tposition = savedPosition\n\tstringPosition = savedStringPosition\n\tsrcStringStart = savedSrcStringStart\n\tsrcStringEnd = savedSrcStringEnd\n\tsrcString = savedSrcString\n\tstrings = savedStrings\n\treferenceMap = savedReferenceMap\n\tbundledStrings = savedBundledStrings\n\tsrc = savedSrc\n\tsequentialMode = savedSequentialMode\n\tcurrentStructures = savedStructures\n\tcurrentStructures.splice(0, currentStructures.length, ...savedStructuresContents)\n\tcurrentUnpackr = savedPackr\n\tdataView = new DataView(src.buffer, src.byteOffset, src.byteLength)\n\treturn value\n}\nfunction clearSource() {\n\tsrc = null\n\treferenceMap = null\n\tcurrentStructures = null\n}\n\nfunction addExtension(extension) {\n\tif (extension.unpack)\n\t\tcurrentExtensions[extension.type] = extension.unpack\n\telse\n\t\tcurrentExtensions[extension.type] = extension\n}\n\nconst mult10 = new Array(147) // this is a table matching binary exponents to the multiplier to determine significant digit rounding\nfor (let i = 0; i < 256; i++) {\n\tmult10[i] = +('1e' + Math.floor(45.15 - i * 0.30103))\n}\nconst Decoder = Unpackr\nvar defaultUnpackr = new Unpackr({ useRecords: false })\nconst unpack = defaultUnpackr.unpack\nconst unpackMultiple = defaultUnpackr.unpackMultiple\nconst decode = defaultUnpackr.unpack\nconst FLOAT32_OPTIONS = {\n\tNEVER: 0,\n\tALWAYS: 1,\n\tDECIMAL_ROUND: 3,\n\tDECIMAL_FIT: 4\n}\nlet f32Array = new Float32Array(1)\nlet u8Array = new Uint8Array(f32Array.buffer, 0, 4)\nfunction roundFloat32(float32Number) {\n\tf32Array[0] = float32Number\n\tlet multiplier = mult10[((u8Array[3] & 0x7f) << 1) | (u8Array[2] >> 7)]\n\treturn ((multiplier * float32Number + (float32Number > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n}\nfunction setReadStruct(updatedReadStruct, loadedStructs, saveState) {\n\treadStruct = updatedReadStruct;\n\tonLoadedStructures = loadedStructs;\n\tonSaveState = saveState;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvbXNncGFja3IvdW5wYWNrLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxPQUFPO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLG1GQUFtRixNQUFNO0FBQ3pGLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsbUJBQW1CLFdBQVc7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0UsT0FBTywwSkFBMEosRUFBRTtBQUNuSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDTzs7QUFFQTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLE9BQU87QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGdCQUFnQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsU0FBUztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGdCQUFnQjtBQUMvQztBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0JBQWdCO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1AsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNPO0FBQ1AsbUNBQW1DLG1CQUFtQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWxhbi9EZXNrdG9wL0FwcHMvYmV0dGVyLWF1dGgvbm9kZV9tb2R1bGVzL21zZ3BhY2tyL3VucGFjay5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZGVjb2RlclxudHJ5IHtcblx0ZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpXG59IGNhdGNoKGVycm9yKSB7fVxudmFyIHNyY1xudmFyIHNyY0VuZFxudmFyIHBvc2l0aW9uID0gMFxudmFyIGFscmVhZHlTZXRcbmNvbnN0IEVNUFRZX0FSUkFZID0gW11cbnZhciBzdHJpbmdzID0gRU1QVFlfQVJSQVlcbnZhciBzdHJpbmdQb3NpdGlvbiA9IDBcbnZhciBjdXJyZW50VW5wYWNrciA9IHt9XG52YXIgY3VycmVudFN0cnVjdHVyZXNcbnZhciBzcmNTdHJpbmdcbnZhciBzcmNTdHJpbmdTdGFydCA9IDBcbnZhciBzcmNTdHJpbmdFbmQgPSAwXG52YXIgYnVuZGxlZFN0cmluZ3NcbnZhciByZWZlcmVuY2VNYXBcbnZhciBjdXJyZW50RXh0ZW5zaW9ucyA9IFtdXG52YXIgZGF0YVZpZXdcbnZhciBkZWZhdWx0T3B0aW9ucyA9IHtcblx0dXNlUmVjb3JkczogZmFsc2UsXG5cdG1hcHNBc09iamVjdHM6IHRydWVcbn1cbmV4cG9ydCBjbGFzcyBDMVR5cGUge31cbmV4cG9ydCBjb25zdCBDMSA9IG5ldyBDMVR5cGUoKVxuQzEubmFtZSA9ICdNZXNzYWdlUGFjayAweEMxJ1xudmFyIHNlcXVlbnRpYWxNb2RlID0gZmFsc2VcbnZhciBpbmxpbmVPYmplY3RSZWFkVGhyZXNob2xkID0gMlxudmFyIHJlYWRTdHJ1Y3QsIG9uTG9hZGVkU3RydWN0dXJlcywgb25TYXZlU3RhdGVcbnZhciBCbG9ja2VkRnVuY3Rpb24gLy8gd2UgdXNlIHNlYXJjaCBhbmQgcmVwbGFjZSB0byBjaGFuZ2UgdGhlIG5leHQgY2FsbCB0byBCbG9ja2VkRnVuY3Rpb24gdG8gYXZvaWQgQ1NQIGlzc3VlcyBmb3Jcbi8vIG5vLWV2YWwgYnVpbGRcbnRyeSB7XG5cdG5ldyBGdW5jdGlvbignJylcbn0gY2F0Y2goZXJyb3IpIHtcblx0Ly8gaWYgZXZhbCB2YXJpYW50cyBhcmUgbm90IHN1cHBvcnRlZCwgZG8gbm90IGNyZWF0ZSBpbmxpbmUgb2JqZWN0IHJlYWRlcnMgZXZlclxuXHRpbmxpbmVPYmplY3RSZWFkVGhyZXNob2xkID0gSW5maW5pdHlcbn1cblxuZXhwb3J0IGNsYXNzIFVucGFja3Ige1xuXHRjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG5cdFx0aWYgKG9wdGlvbnMpIHtcblx0XHRcdGlmIChvcHRpb25zLnVzZVJlY29yZHMgPT09IGZhbHNlICYmIG9wdGlvbnMubWFwc0FzT2JqZWN0cyA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRvcHRpb25zLm1hcHNBc09iamVjdHMgPSB0cnVlXG5cdFx0XHRpZiAob3B0aW9ucy5zZXF1ZW50aWFsICYmIG9wdGlvbnMudHJ1c3RlZCAhPT0gZmFsc2UpIHtcblx0XHRcdFx0b3B0aW9ucy50cnVzdGVkID0gdHJ1ZTtcblx0XHRcdFx0aWYgKCFvcHRpb25zLnN0cnVjdHVyZXMgJiYgb3B0aW9ucy51c2VSZWNvcmRzICE9IGZhbHNlKSB7XG5cdFx0XHRcdFx0b3B0aW9ucy5zdHJ1Y3R1cmVzID0gW11cblx0XHRcdFx0XHRpZiAoIW9wdGlvbnMubWF4U2hhcmVkU3RydWN0dXJlcylcblx0XHRcdFx0XHRcdG9wdGlvbnMubWF4U2hhcmVkU3RydWN0dXJlcyA9IDBcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKG9wdGlvbnMuc3RydWN0dXJlcylcblx0XHRcdFx0b3B0aW9ucy5zdHJ1Y3R1cmVzLnNoYXJlZExlbmd0aCA9IG9wdGlvbnMuc3RydWN0dXJlcy5sZW5ndGhcblx0XHRcdGVsc2UgaWYgKG9wdGlvbnMuZ2V0U3RydWN0dXJlcykge1xuXHRcdFx0XHQob3B0aW9ucy5zdHJ1Y3R1cmVzID0gW10pLnVuaW5pdGlhbGl6ZWQgPSB0cnVlIC8vIHRoaXMgaXMgd2hhdCB3ZSB1c2UgdG8gZGVub3RlIGFuIHVuaW5pdGlhbGl6ZWQgc3RydWN0dXJlc1xuXHRcdFx0XHRvcHRpb25zLnN0cnVjdHVyZXMuc2hhcmVkTGVuZ3RoID0gMFxuXHRcdFx0fVxuXHRcdFx0aWYgKG9wdGlvbnMuaW50NjRBc051bWJlcikge1xuXHRcdFx0XHRvcHRpb25zLmludDY0QXNUeXBlID0gJ251bWJlcidcblx0XHRcdH1cblx0XHR9XG5cdFx0T2JqZWN0LmFzc2lnbih0aGlzLCBvcHRpb25zKVxuXHR9XG5cdHVucGFjayhzb3VyY2UsIG9wdGlvbnMpIHtcblx0XHRpZiAoc3JjKSB7XG5cdFx0XHQvLyByZS1lbnRyYW50IGV4ZWN1dGlvbiwgc2F2ZSB0aGUgc3RhdGUgYW5kIHJlc3RvcmUgaXQgYWZ0ZXIgd2UgZG8gdGhpcyB1bnBhY2tcblx0XHRcdHJldHVybiBzYXZlU3RhdGUoKCkgPT4ge1xuXHRcdFx0XHRjbGVhclNvdXJjZSgpXG5cdFx0XHRcdHJldHVybiB0aGlzID8gdGhpcy51bnBhY2soc291cmNlLCBvcHRpb25zKSA6IFVucGFja3IucHJvdG90eXBlLnVucGFjay5jYWxsKGRlZmF1bHRPcHRpb25zLCBzb3VyY2UsIG9wdGlvbnMpXG5cdFx0XHR9KVxuXHRcdH1cblx0XHRpZiAoIXNvdXJjZS5idWZmZXIgJiYgc291cmNlLmNvbnN0cnVjdG9yID09PSBBcnJheUJ1ZmZlcilcblx0XHRcdHNvdXJjZSA9IHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnID8gQnVmZmVyLmZyb20oc291cmNlKSA6IG5ldyBVaW50OEFycmF5KHNvdXJjZSk7XG5cdFx0aWYgKHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0Jykge1xuXHRcdFx0c3JjRW5kID0gb3B0aW9ucy5lbmQgfHwgc291cmNlLmxlbmd0aFxuXHRcdFx0cG9zaXRpb24gPSBvcHRpb25zLnN0YXJ0IHx8IDBcblx0XHR9IGVsc2Uge1xuXHRcdFx0cG9zaXRpb24gPSAwXG5cdFx0XHRzcmNFbmQgPSBvcHRpb25zID4gLTEgPyBvcHRpb25zIDogc291cmNlLmxlbmd0aFxuXHRcdH1cblx0XHRzdHJpbmdQb3NpdGlvbiA9IDBcblx0XHRzcmNTdHJpbmdFbmQgPSAwXG5cdFx0c3JjU3RyaW5nID0gbnVsbFxuXHRcdHN0cmluZ3MgPSBFTVBUWV9BUlJBWVxuXHRcdGJ1bmRsZWRTdHJpbmdzID0gbnVsbFxuXHRcdHNyYyA9IHNvdXJjZVxuXHRcdC8vIHRoaXMgcHJvdmlkZXMgY2FjaGVkIGFjY2VzcyB0byB0aGUgZGF0YSB2aWV3IGZvciBhIGJ1ZmZlciBpZiBpdCBpcyBnZXR0aW5nIHJldXNlZCwgd2hpY2ggaXMgYSByZWNvbW1lbmRcblx0XHQvLyB0ZWNobmlxdWUgZm9yIGdldHRpbmcgZGF0YSBmcm9tIGEgZGF0YWJhc2Ugd2hlcmUgaXQgY2FuIGJlIGNvcGllZCBpbnRvIGFuIGV4aXN0aW5nIGJ1ZmZlciBpbnN0ZWFkIG9mIGNyZWF0aW5nXG5cdFx0Ly8gbmV3IG9uZXNcblx0XHR0cnkge1xuXHRcdFx0ZGF0YVZpZXcgPSBzb3VyY2UuZGF0YVZpZXcgfHwgKHNvdXJjZS5kYXRhVmlldyA9IG5ldyBEYXRhVmlldyhzb3VyY2UuYnVmZmVyLCBzb3VyY2UuYnl0ZU9mZnNldCwgc291cmNlLmJ5dGVMZW5ndGgpKVxuXHRcdH0gY2F0Y2goZXJyb3IpIHtcblx0XHRcdC8vIGlmIGl0IGRvZXNuJ3QgaGF2ZSBhIGJ1ZmZlciwgbWF5YmUgaXQgaXMgdGhlIHdyb25nIHR5cGUgb2Ygb2JqZWN0XG5cdFx0XHRzcmMgPSBudWxsXG5cdFx0XHRpZiAoc291cmNlIGluc3RhbmNlb2YgVWludDhBcnJheSlcblx0XHRcdFx0dGhyb3cgZXJyb3Jcblx0XHRcdHRocm93IG5ldyBFcnJvcignU291cmNlIG11c3QgYmUgYSBVaW50OEFycmF5IG9yIEJ1ZmZlciBidXQgd2FzIGEgJyArICgoc291cmNlICYmIHR5cGVvZiBzb3VyY2UgPT0gJ29iamVjdCcpID8gc291cmNlLmNvbnN0cnVjdG9yLm5hbWUgOiB0eXBlb2Ygc291cmNlKSlcblx0XHR9XG5cdFx0aWYgKHRoaXMgaW5zdGFuY2VvZiBVbnBhY2tyKSB7XG5cdFx0XHRjdXJyZW50VW5wYWNrciA9IHRoaXNcblx0XHRcdGlmICh0aGlzLnN0cnVjdHVyZXMpIHtcblx0XHRcdFx0Y3VycmVudFN0cnVjdHVyZXMgPSB0aGlzLnN0cnVjdHVyZXNcblx0XHRcdFx0cmV0dXJuIGNoZWNrZWRSZWFkKG9wdGlvbnMpXG5cdFx0XHR9IGVsc2UgaWYgKCFjdXJyZW50U3RydWN0dXJlcyB8fCBjdXJyZW50U3RydWN0dXJlcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdGN1cnJlbnRTdHJ1Y3R1cmVzID0gW11cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VycmVudFVucGFja3IgPSBkZWZhdWx0T3B0aW9uc1xuXHRcdFx0aWYgKCFjdXJyZW50U3RydWN0dXJlcyB8fCBjdXJyZW50U3RydWN0dXJlcy5sZW5ndGggPiAwKVxuXHRcdFx0XHRjdXJyZW50U3RydWN0dXJlcyA9IFtdXG5cdFx0fVxuXHRcdHJldHVybiBjaGVja2VkUmVhZChvcHRpb25zKVxuXHR9XG5cdHVucGFja011bHRpcGxlKHNvdXJjZSwgZm9yRWFjaCkge1xuXHRcdGxldCB2YWx1ZXMsIGxhc3RQb3NpdGlvbiA9IDBcblx0XHR0cnkge1xuXHRcdFx0c2VxdWVudGlhbE1vZGUgPSB0cnVlXG5cdFx0XHRsZXQgc2l6ZSA9IHNvdXJjZS5sZW5ndGhcblx0XHRcdGxldCB2YWx1ZSA9IHRoaXMgPyB0aGlzLnVucGFjayhzb3VyY2UsIHNpemUpIDogZGVmYXVsdFVucGFja3IudW5wYWNrKHNvdXJjZSwgc2l6ZSlcblx0XHRcdGlmIChmb3JFYWNoKSB7XG5cdFx0XHRcdGlmIChmb3JFYWNoKHZhbHVlLCBsYXN0UG9zaXRpb24sIHBvc2l0aW9uKSA9PT0gZmFsc2UpIHJldHVybjtcblx0XHRcdFx0d2hpbGUocG9zaXRpb24gPCBzaXplKSB7XG5cdFx0XHRcdFx0bGFzdFBvc2l0aW9uID0gcG9zaXRpb25cblx0XHRcdFx0XHRpZiAoZm9yRWFjaChjaGVja2VkUmVhZCgpLCBsYXN0UG9zaXRpb24sIHBvc2l0aW9uKSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHZhbHVlcyA9IFsgdmFsdWUgXVxuXHRcdFx0XHR3aGlsZShwb3NpdGlvbiA8IHNpemUpIHtcblx0XHRcdFx0XHRsYXN0UG9zaXRpb24gPSBwb3NpdGlvblxuXHRcdFx0XHRcdHZhbHVlcy5wdXNoKGNoZWNrZWRSZWFkKCkpXG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZhbHVlc1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2goZXJyb3IpIHtcblx0XHRcdGVycm9yLmxhc3RQb3NpdGlvbiA9IGxhc3RQb3NpdGlvblxuXHRcdFx0ZXJyb3IudmFsdWVzID0gdmFsdWVzXG5cdFx0XHR0aHJvdyBlcnJvclxuXHRcdH0gZmluYWxseSB7XG5cdFx0XHRzZXF1ZW50aWFsTW9kZSA9IGZhbHNlXG5cdFx0XHRjbGVhclNvdXJjZSgpXG5cdFx0fVxuXHR9XG5cdF9tZXJnZVN0cnVjdHVyZXMobG9hZGVkU3RydWN0dXJlcywgZXhpc3RpbmdTdHJ1Y3R1cmVzKSB7XG5cdFx0aWYgKG9uTG9hZGVkU3RydWN0dXJlcylcblx0XHRcdGxvYWRlZFN0cnVjdHVyZXMgPSBvbkxvYWRlZFN0cnVjdHVyZXMuY2FsbCh0aGlzLCBsb2FkZWRTdHJ1Y3R1cmVzKTtcblx0XHRsb2FkZWRTdHJ1Y3R1cmVzID0gbG9hZGVkU3RydWN0dXJlcyB8fCBbXVxuXHRcdGlmIChPYmplY3QuaXNGcm96ZW4obG9hZGVkU3RydWN0dXJlcykpXG5cdFx0XHRsb2FkZWRTdHJ1Y3R1cmVzID0gbG9hZGVkU3RydWN0dXJlcy5tYXAoc3RydWN0dXJlID0+IHN0cnVjdHVyZS5zbGljZSgwKSlcblx0XHRmb3IgKGxldCBpID0gMCwgbCA9IGxvYWRlZFN0cnVjdHVyZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRsZXQgc3RydWN0dXJlID0gbG9hZGVkU3RydWN0dXJlc1tpXVxuXHRcdFx0aWYgKHN0cnVjdHVyZSkge1xuXHRcdFx0XHRzdHJ1Y3R1cmUuaXNTaGFyZWQgPSB0cnVlXG5cdFx0XHRcdGlmIChpID49IDMyKVxuXHRcdFx0XHRcdHN0cnVjdHVyZS5oaWdoQnl0ZSA9IChpIC0gMzIpID4+IDVcblx0XHRcdH1cblx0XHR9XG5cdFx0bG9hZGVkU3RydWN0dXJlcy5zaGFyZWRMZW5ndGggPSBsb2FkZWRTdHJ1Y3R1cmVzLmxlbmd0aFxuXHRcdGZvciAobGV0IGlkIGluIGV4aXN0aW5nU3RydWN0dXJlcyB8fCBbXSkge1xuXHRcdFx0aWYgKGlkID49IDApIHtcblx0XHRcdFx0bGV0IHN0cnVjdHVyZSA9IGxvYWRlZFN0cnVjdHVyZXNbaWRdXG5cdFx0XHRcdGxldCBleGlzdGluZyA9IGV4aXN0aW5nU3RydWN0dXJlc1tpZF1cblx0XHRcdFx0aWYgKGV4aXN0aW5nKSB7XG5cdFx0XHRcdFx0aWYgKHN0cnVjdHVyZSlcblx0XHRcdFx0XHRcdChsb2FkZWRTdHJ1Y3R1cmVzLnJlc3RvcmVTdHJ1Y3R1cmVzIHx8IChsb2FkZWRTdHJ1Y3R1cmVzLnJlc3RvcmVTdHJ1Y3R1cmVzID0gW10pKVtpZF0gPSBzdHJ1Y3R1cmVcblx0XHRcdFx0XHRsb2FkZWRTdHJ1Y3R1cmVzW2lkXSA9IGV4aXN0aW5nXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuc3RydWN0dXJlcyA9IGxvYWRlZFN0cnVjdHVyZXNcblx0fVxuXHRkZWNvZGUoc291cmNlLCBvcHRpb25zKSB7XG5cdFx0cmV0dXJuIHRoaXMudW5wYWNrKHNvdXJjZSwgb3B0aW9ucylcblx0fVxufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFBvc2l0aW9uKCkge1xuXHRyZXR1cm4gcG9zaXRpb25cbn1cbmV4cG9ydCBmdW5jdGlvbiBjaGVja2VkUmVhZChvcHRpb25zKSB7XG5cdHRyeSB7XG5cdFx0aWYgKCFjdXJyZW50VW5wYWNrci50cnVzdGVkICYmICFzZXF1ZW50aWFsTW9kZSkge1xuXHRcdFx0bGV0IHNoYXJlZExlbmd0aCA9IGN1cnJlbnRTdHJ1Y3R1cmVzLnNoYXJlZExlbmd0aCB8fCAwXG5cdFx0XHRpZiAoc2hhcmVkTGVuZ3RoIDwgY3VycmVudFN0cnVjdHVyZXMubGVuZ3RoKVxuXHRcdFx0XHRjdXJyZW50U3RydWN0dXJlcy5sZW5ndGggPSBzaGFyZWRMZW5ndGhcblx0XHR9XG5cdFx0bGV0IHJlc3VsdFxuXHRcdGlmIChjdXJyZW50VW5wYWNrci5yYW5kb21BY2Nlc3NTdHJ1Y3R1cmUgJiYgc3JjW3Bvc2l0aW9uXSA8IDB4NDAgJiYgc3JjW3Bvc2l0aW9uXSA+PSAweDIwICYmIHJlYWRTdHJ1Y3QpIHtcblx0XHRcdHJlc3VsdCA9IHJlYWRTdHJ1Y3Qoc3JjLCBwb3NpdGlvbiwgc3JjRW5kLCBjdXJyZW50VW5wYWNrcilcblx0XHRcdHNyYyA9IG51bGwgLy8gZGlzcG9zZSBvZiB0aGlzIHNvIHRoYXQgcmVjdXJzaXZlIHVucGFjayBjYWxscyBkb24ndCBzYXZlIHN0YXRlXG5cdFx0XHRpZiAoIShvcHRpb25zICYmIG9wdGlvbnMubGF6eSkgJiYgcmVzdWx0KVxuXHRcdFx0XHRyZXN1bHQgPSByZXN1bHQudG9KU09OKClcblx0XHRcdHBvc2l0aW9uID0gc3JjRW5kXG5cdFx0fSBlbHNlXG5cdFx0XHRyZXN1bHQgPSByZWFkKClcblx0XHRpZiAoYnVuZGxlZFN0cmluZ3MpIHsgLy8gYnVuZGxlZCBzdHJpbmdzIHRvIHNraXAgcGFzdFxuXHRcdFx0cG9zaXRpb24gPSBidW5kbGVkU3RyaW5ncy5wb3N0QnVuZGxlUG9zaXRpb25cblx0XHRcdGJ1bmRsZWRTdHJpbmdzID0gbnVsbFxuXHRcdH1cblx0XHRpZiAoc2VxdWVudGlhbE1vZGUpXG5cdFx0XHQvLyB3ZSBvbmx5IG5lZWQgdG8gcmVzdG9yZSB0aGUgc3RydWN0dXJlcyBpZiB0aGVyZSB3YXMgYW4gZXJyb3IsIGJ1dCBpZiB3ZSBjb21wbGV0ZWQgYSByZWFkLFxuXHRcdFx0Ly8gd2UgY2FuIGNsZWFyIHRoaXMgb3V0IGFuZCBrZWVwIHRoZSBzdHJ1Y3R1cmVzIHdlIHJlYWRcblx0XHRcdGN1cnJlbnRTdHJ1Y3R1cmVzLnJlc3RvcmVTdHJ1Y3R1cmVzID0gbnVsbFxuXG5cdFx0aWYgKHBvc2l0aW9uID09IHNyY0VuZCkge1xuXHRcdFx0Ly8gZmluaXNoZWQgcmVhZGluZyB0aGlzIHNvdXJjZSwgY2xlYW51cCByZWZlcmVuY2VzXG5cdFx0XHRpZiAoY3VycmVudFN0cnVjdHVyZXMgJiYgY3VycmVudFN0cnVjdHVyZXMucmVzdG9yZVN0cnVjdHVyZXMpXG5cdFx0XHRcdHJlc3RvcmVTdHJ1Y3R1cmVzKClcblx0XHRcdGN1cnJlbnRTdHJ1Y3R1cmVzID0gbnVsbFxuXHRcdFx0c3JjID0gbnVsbFxuXHRcdFx0aWYgKHJlZmVyZW5jZU1hcClcblx0XHRcdFx0cmVmZXJlbmNlTWFwID0gbnVsbFxuXHRcdH0gZWxzZSBpZiAocG9zaXRpb24gPiBzcmNFbmQpIHtcblx0XHRcdC8vIG92ZXIgcmVhZFxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIGVuZCBvZiBNZXNzYWdlUGFjayBkYXRhJylcblx0XHR9IGVsc2UgaWYgKCFzZXF1ZW50aWFsTW9kZSkge1xuXHRcdFx0bGV0IGpzb25WaWV3O1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0anNvblZpZXcgPSBKU09OLnN0cmluZ2lmeShyZXN1bHQsIChfLCB2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiID8gYCR7dmFsdWV9bmAgOiB2YWx1ZSkuc2xpY2UoMCwgMTAwKVxuXHRcdFx0fSBjYXRjaChlcnJvcikge1xuXHRcdFx0XHRqc29uVmlldyA9ICcoSlNPTiB2aWV3IG5vdCBhdmFpbGFibGUgJyArIGVycm9yICsgJyknXG5cdFx0XHR9XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgcmVhZCwgYnV0IGVuZCBvZiBidWZmZXIgbm90IHJlYWNoZWQgJyArIGpzb25WaWV3KVxuXHRcdH1cblx0XHQvLyBlbHNlIG1vcmUgdG8gcmVhZCwgYnV0IHdlIGFyZSByZWFkaW5nIHNlcXVlbnRpYWxseSwgc28gZG9uJ3QgY2xlYXIgc291cmNlIHlldFxuXHRcdHJldHVybiByZXN1bHRcblx0fSBjYXRjaChlcnJvcikge1xuXHRcdGlmIChjdXJyZW50U3RydWN0dXJlcyAmJiBjdXJyZW50U3RydWN0dXJlcy5yZXN0b3JlU3RydWN0dXJlcylcblx0XHRcdHJlc3RvcmVTdHJ1Y3R1cmVzKClcblx0XHRjbGVhclNvdXJjZSgpXG5cdFx0aWYgKGVycm9yIGluc3RhbmNlb2YgUmFuZ2VFcnJvciB8fCBlcnJvci5tZXNzYWdlLnN0YXJ0c1dpdGgoJ1VuZXhwZWN0ZWQgZW5kIG9mIGJ1ZmZlcicpIHx8IHBvc2l0aW9uID4gc3JjRW5kKSB7XG5cdFx0XHRlcnJvci5pbmNvbXBsZXRlID0gdHJ1ZVxuXHRcdH1cblx0XHR0aHJvdyBlcnJvclxuXHR9XG59XG5cbmZ1bmN0aW9uIHJlc3RvcmVTdHJ1Y3R1cmVzKCkge1xuXHRmb3IgKGxldCBpZCBpbiBjdXJyZW50U3RydWN0dXJlcy5yZXN0b3JlU3RydWN0dXJlcykge1xuXHRcdGN1cnJlbnRTdHJ1Y3R1cmVzW2lkXSA9IGN1cnJlbnRTdHJ1Y3R1cmVzLnJlc3RvcmVTdHJ1Y3R1cmVzW2lkXVxuXHR9XG5cdGN1cnJlbnRTdHJ1Y3R1cmVzLnJlc3RvcmVTdHJ1Y3R1cmVzID0gbnVsbFxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVhZCgpIHtcblx0bGV0IHRva2VuID0gc3JjW3Bvc2l0aW9uKytdXG5cdGlmICh0b2tlbiA8IDB4YTApIHtcblx0XHRpZiAodG9rZW4gPCAweDgwKSB7XG5cdFx0XHRpZiAodG9rZW4gPCAweDQwKVxuXHRcdFx0XHRyZXR1cm4gdG9rZW5cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRsZXQgc3RydWN0dXJlID0gY3VycmVudFN0cnVjdHVyZXNbdG9rZW4gJiAweDNmXSB8fFxuXHRcdFx0XHRcdGN1cnJlbnRVbnBhY2tyLmdldFN0cnVjdHVyZXMgJiYgbG9hZFN0cnVjdHVyZXMoKVt0b2tlbiAmIDB4M2ZdXG5cdFx0XHRcdGlmIChzdHJ1Y3R1cmUpIHtcblx0XHRcdFx0XHRpZiAoIXN0cnVjdHVyZS5yZWFkKSB7XG5cdFx0XHRcdFx0XHRzdHJ1Y3R1cmUucmVhZCA9IGNyZWF0ZVN0cnVjdHVyZVJlYWRlcihzdHJ1Y3R1cmUsIHRva2VuICYgMHgzZilcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHN0cnVjdHVyZS5yZWFkKClcblx0XHRcdFx0fSBlbHNlXG5cdFx0XHRcdFx0cmV0dXJuIHRva2VuXG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICh0b2tlbiA8IDB4OTApIHtcblx0XHRcdC8vIG1hcFxuXHRcdFx0dG9rZW4gLT0gMHg4MFxuXHRcdFx0aWYgKGN1cnJlbnRVbnBhY2tyLm1hcHNBc09iamVjdHMpIHtcblx0XHRcdFx0bGV0IG9iamVjdCA9IHt9XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW47IGkrKykge1xuXHRcdFx0XHRcdGxldCBrZXkgPSByZWFkS2V5KClcblx0XHRcdFx0XHRpZiAoa2V5ID09PSAnX19wcm90b19fJylcblx0XHRcdFx0XHRcdGtleSA9ICdfX3Byb3RvXydcblx0XHRcdFx0XHRvYmplY3Rba2V5XSA9IHJlYWQoKVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBvYmplY3Rcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGxldCBtYXAgPSBuZXcgTWFwKClcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbjsgaSsrKSB7XG5cdFx0XHRcdFx0bWFwLnNldChyZWFkKCksIHJlYWQoKSlcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbWFwXG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRva2VuIC09IDB4OTBcblx0XHRcdGxldCBhcnJheSA9IG5ldyBBcnJheSh0b2tlbilcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW47IGkrKykge1xuXHRcdFx0XHRhcnJheVtpXSA9IHJlYWQoKVxuXHRcdFx0fVxuXHRcdFx0aWYgKGN1cnJlbnRVbnBhY2tyLmZyZWV6ZURhdGEpXG5cdFx0XHRcdHJldHVybiBPYmplY3QuZnJlZXplKGFycmF5KVxuXHRcdFx0cmV0dXJuIGFycmF5XG5cdFx0fVxuXHR9IGVsc2UgaWYgKHRva2VuIDwgMHhjMCkge1xuXHRcdC8vIGZpeHN0clxuXHRcdGxldCBsZW5ndGggPSB0b2tlbiAtIDB4YTBcblx0XHRpZiAoc3JjU3RyaW5nRW5kID49IHBvc2l0aW9uKSB7XG5cdFx0XHRyZXR1cm4gc3JjU3RyaW5nLnNsaWNlKHBvc2l0aW9uIC0gc3JjU3RyaW5nU3RhcnQsIChwb3NpdGlvbiArPSBsZW5ndGgpIC0gc3JjU3RyaW5nU3RhcnQpXG5cdFx0fVxuXHRcdGlmIChzcmNTdHJpbmdFbmQgPT0gMCAmJiBzcmNFbmQgPCAxNDApIHtcblx0XHRcdC8vIGZvciBzbWFsbCBibG9ja3MsIGF2b2lkaW5nIHRoZSBvdmVyaGVhZCBvZiB0aGUgZXh0cmFjdCBjYWxsIGlzIGhlbHBmdWxcblx0XHRcdGxldCBzdHJpbmcgPSBsZW5ndGggPCAxNiA/IHNob3J0U3RyaW5nSW5KUyhsZW5ndGgpIDogbG9uZ1N0cmluZ0luSlMobGVuZ3RoKVxuXHRcdFx0aWYgKHN0cmluZyAhPSBudWxsKVxuXHRcdFx0XHRyZXR1cm4gc3RyaW5nXG5cdFx0fVxuXHRcdHJldHVybiByZWFkRml4ZWRTdHJpbmcobGVuZ3RoKVxuXHR9IGVsc2Uge1xuXHRcdGxldCB2YWx1ZVxuXHRcdHN3aXRjaCAodG9rZW4pIHtcblx0XHRcdGNhc2UgMHhjMDogcmV0dXJuIG51bGxcblx0XHRcdGNhc2UgMHhjMTpcblx0XHRcdFx0aWYgKGJ1bmRsZWRTdHJpbmdzKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSByZWFkKCkgLy8gZm9sbG93ZWQgYnkgdGhlIGxlbmd0aCBvZiB0aGUgc3RyaW5nIGluIGNoYXJhY3RlcnMgKG5vdCBieXRlcyEpXG5cdFx0XHRcdFx0aWYgKHZhbHVlID4gMClcblx0XHRcdFx0XHRcdHJldHVybiBidW5kbGVkU3RyaW5nc1sxXS5zbGljZShidW5kbGVkU3RyaW5ncy5wb3NpdGlvbjEsIGJ1bmRsZWRTdHJpbmdzLnBvc2l0aW9uMSArPSB2YWx1ZSlcblx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRyZXR1cm4gYnVuZGxlZFN0cmluZ3NbMF0uc2xpY2UoYnVuZGxlZFN0cmluZ3MucG9zaXRpb24wLCBidW5kbGVkU3RyaW5ncy5wb3NpdGlvbjAgLT0gdmFsdWUpXG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIEMxOyAvLyBcIm5ldmVyLXVzZWRcIiwgcmV0dXJuIHNwZWNpYWwgb2JqZWN0IHRvIGRlbm90ZSB0aGF0XG5cdFx0XHRjYXNlIDB4YzI6IHJldHVybiBmYWxzZVxuXHRcdFx0Y2FzZSAweGMzOiByZXR1cm4gdHJ1ZVxuXHRcdFx0Y2FzZSAweGM0OlxuXHRcdFx0XHQvLyBiaW4gOFxuXHRcdFx0XHR2YWx1ZSA9IHNyY1twb3NpdGlvbisrXVxuXHRcdFx0XHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgZW5kIG9mIGJ1ZmZlcicpXG5cdFx0XHRcdHJldHVybiByZWFkQmluKHZhbHVlKVxuXHRcdFx0Y2FzZSAweGM1OlxuXHRcdFx0XHQvLyBiaW4gMTZcblx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRVaW50MTYocG9zaXRpb24pXG5cdFx0XHRcdHBvc2l0aW9uICs9IDJcblx0XHRcdFx0cmV0dXJuIHJlYWRCaW4odmFsdWUpXG5cdFx0XHRjYXNlIDB4YzY6XG5cdFx0XHRcdC8vIGJpbiAzMlxuXHRcdFx0XHR2YWx1ZSA9IGRhdGFWaWV3LmdldFVpbnQzMihwb3NpdGlvbilcblx0XHRcdFx0cG9zaXRpb24gKz0gNFxuXHRcdFx0XHRyZXR1cm4gcmVhZEJpbih2YWx1ZSlcblx0XHRcdGNhc2UgMHhjNzpcblx0XHRcdFx0Ly8gZXh0IDhcblx0XHRcdFx0cmV0dXJuIHJlYWRFeHQoc3JjW3Bvc2l0aW9uKytdKVxuXHRcdFx0Y2FzZSAweGM4OlxuXHRcdFx0XHQvLyBleHQgMTZcblx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRVaW50MTYocG9zaXRpb24pXG5cdFx0XHRcdHBvc2l0aW9uICs9IDJcblx0XHRcdFx0cmV0dXJuIHJlYWRFeHQodmFsdWUpXG5cdFx0XHRjYXNlIDB4Yzk6XG5cdFx0XHRcdC8vIGV4dCAzMlxuXHRcdFx0XHR2YWx1ZSA9IGRhdGFWaWV3LmdldFVpbnQzMihwb3NpdGlvbilcblx0XHRcdFx0cG9zaXRpb24gKz0gNFxuXHRcdFx0XHRyZXR1cm4gcmVhZEV4dCh2YWx1ZSlcblx0XHRcdGNhc2UgMHhjYTpcblx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRGbG9hdDMyKHBvc2l0aW9uKVxuXHRcdFx0XHRpZiAoY3VycmVudFVucGFja3IudXNlRmxvYXQzMiA+IDIpIHtcblx0XHRcdFx0XHQvLyB0aGlzIGRvZXMgcm91bmRpbmcgb2YgbnVtYmVycyB0aGF0IHdlcmUgZW5jb2RlZCBpbiAzMi1iaXQgZmxvYXQgdG8gbmVhcmVzdCBzaWduaWZpY2FudCBkZWNpbWFsIGRpZ2l0IHRoYXQgY291bGQgYmUgcHJlc2VydmVkXG5cdFx0XHRcdFx0bGV0IG11bHRpcGxpZXIgPSBtdWx0MTBbKChzcmNbcG9zaXRpb25dICYgMHg3ZikgPDwgMSkgfCAoc3JjW3Bvc2l0aW9uICsgMV0gPj4gNyldXG5cdFx0XHRcdFx0cG9zaXRpb24gKz0gNFxuXHRcdFx0XHRcdHJldHVybiAoKG11bHRpcGxpZXIgKiB2YWx1ZSArICh2YWx1ZSA+IDAgPyAwLjUgOiAtMC41KSkgPj4gMCkgLyBtdWx0aXBsaWVyXG5cdFx0XHRcdH1cblx0XHRcdFx0cG9zaXRpb24gKz0gNFxuXHRcdFx0XHRyZXR1cm4gdmFsdWVcblx0XHRcdGNhc2UgMHhjYjpcblx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRGbG9hdDY0KHBvc2l0aW9uKVxuXHRcdFx0XHRwb3NpdGlvbiArPSA4XG5cdFx0XHRcdHJldHVybiB2YWx1ZVxuXHRcdFx0Ly8gdWludCBoYW5kbGVyc1xuXHRcdFx0Y2FzZSAweGNjOlxuXHRcdFx0XHRyZXR1cm4gc3JjW3Bvc2l0aW9uKytdXG5cdFx0XHRjYXNlIDB4Y2Q6XG5cdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0VWludDE2KHBvc2l0aW9uKVxuXHRcdFx0XHRwb3NpdGlvbiArPSAyXG5cdFx0XHRcdHJldHVybiB2YWx1ZVxuXHRcdFx0Y2FzZSAweGNlOlxuXHRcdFx0XHR2YWx1ZSA9IGRhdGFWaWV3LmdldFVpbnQzMihwb3NpdGlvbilcblx0XHRcdFx0cG9zaXRpb24gKz0gNFxuXHRcdFx0XHRyZXR1cm4gdmFsdWVcblx0XHRcdGNhc2UgMHhjZjpcblx0XHRcdFx0aWYgKGN1cnJlbnRVbnBhY2tyLmludDY0QXNUeXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0VWludDMyKHBvc2l0aW9uKSAqIDB4MTAwMDAwMDAwXG5cdFx0XHRcdFx0dmFsdWUgKz0gZGF0YVZpZXcuZ2V0VWludDMyKHBvc2l0aW9uICsgNClcblx0XHRcdFx0fSBlbHNlIGlmIChjdXJyZW50VW5wYWNrci5pbnQ2NEFzVHlwZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGRhdGFWaWV3LmdldEJpZ1VpbnQ2NChwb3NpdGlvbikudG9TdHJpbmcoKVxuXHRcdFx0XHR9IGVsc2UgaWYgKGN1cnJlbnRVbnBhY2tyLmludDY0QXNUeXBlID09PSAnYXV0bycpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGRhdGFWaWV3LmdldEJpZ1VpbnQ2NChwb3NpdGlvbilcblx0XHRcdFx0XHRpZiAodmFsdWU8PUJpZ0ludCgyKTw8QmlnSW50KDUyKSkgdmFsdWU9TnVtYmVyKHZhbHVlKVxuXHRcdFx0XHR9IGVsc2Vcblx0XHRcdFx0XHR2YWx1ZSA9IGRhdGFWaWV3LmdldEJpZ1VpbnQ2NChwb3NpdGlvbilcblx0XHRcdFx0cG9zaXRpb24gKz0gOFxuXHRcdFx0XHRyZXR1cm4gdmFsdWVcblxuXHRcdFx0Ly8gaW50IGhhbmRsZXJzXG5cdFx0XHRjYXNlIDB4ZDA6XG5cdFx0XHRcdHJldHVybiBkYXRhVmlldy5nZXRJbnQ4KHBvc2l0aW9uKyspXG5cdFx0XHRjYXNlIDB4ZDE6XG5cdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0SW50MTYocG9zaXRpb24pXG5cdFx0XHRcdHBvc2l0aW9uICs9IDJcblx0XHRcdFx0cmV0dXJuIHZhbHVlXG5cdFx0XHRjYXNlIDB4ZDI6XG5cdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0SW50MzIocG9zaXRpb24pXG5cdFx0XHRcdHBvc2l0aW9uICs9IDRcblx0XHRcdFx0cmV0dXJuIHZhbHVlXG5cdFx0XHRjYXNlIDB4ZDM6XG5cdFx0XHRcdGlmIChjdXJyZW50VW5wYWNrci5pbnQ2NEFzVHlwZSA9PT0gJ251bWJlcicpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGRhdGFWaWV3LmdldEludDMyKHBvc2l0aW9uKSAqIDB4MTAwMDAwMDAwXG5cdFx0XHRcdFx0dmFsdWUgKz0gZGF0YVZpZXcuZ2V0VWludDMyKHBvc2l0aW9uICsgNClcblx0XHRcdFx0fSBlbHNlIGlmIChjdXJyZW50VW5wYWNrci5pbnQ2NEFzVHlwZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGRhdGFWaWV3LmdldEJpZ0ludDY0KHBvc2l0aW9uKS50b1N0cmluZygpXG5cdFx0XHRcdH0gZWxzZSBpZiAoY3VycmVudFVucGFja3IuaW50NjRBc1R5cGUgPT09ICdhdXRvJykge1xuXHRcdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0QmlnSW50NjQocG9zaXRpb24pXG5cdFx0XHRcdFx0aWYgKHZhbHVlPj1CaWdJbnQoLTIpPDxCaWdJbnQoNTIpJiZ2YWx1ZTw9QmlnSW50KDIpPDxCaWdJbnQoNTIpKSB2YWx1ZT1OdW1iZXIodmFsdWUpXG5cdFx0XHRcdH0gZWxzZVxuXHRcdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0QmlnSW50NjQocG9zaXRpb24pXG5cdFx0XHRcdHBvc2l0aW9uICs9IDhcblx0XHRcdFx0cmV0dXJuIHZhbHVlXG5cblx0XHRcdGNhc2UgMHhkNDpcblx0XHRcdFx0Ly8gZml4ZXh0IDFcblx0XHRcdFx0dmFsdWUgPSBzcmNbcG9zaXRpb24rK11cblx0XHRcdFx0aWYgKHZhbHVlID09IDB4NzIpIHtcblx0XHRcdFx0XHRyZXR1cm4gcmVjb3JkRGVmaW5pdGlvbihzcmNbcG9zaXRpb24rK10gJiAweDNmKVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxldCBleHRlbnNpb24gPSBjdXJyZW50RXh0ZW5zaW9uc1t2YWx1ZV1cblx0XHRcdFx0XHRpZiAoZXh0ZW5zaW9uKSB7XG5cdFx0XHRcdFx0XHRpZiAoZXh0ZW5zaW9uLnJlYWQpIHtcblx0XHRcdFx0XHRcdFx0cG9zaXRpb24rKyAvLyBza2lwIGZpbGxlciBieXRlXG5cdFx0XHRcdFx0XHRcdHJldHVybiBleHRlbnNpb24ucmVhZChyZWFkKCkpXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGV4dGVuc2lvbi5ub0J1ZmZlcikge1xuXHRcdFx0XHRcdFx0XHRwb3NpdGlvbisrIC8vIHNraXAgZmlsbGVyIGJ5dGVcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGV4dGVuc2lvbigpXG5cdFx0XHRcdFx0XHR9IGVsc2Vcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGV4dGVuc2lvbihzcmMuc3ViYXJyYXkocG9zaXRpb24sICsrcG9zaXRpb24pKVxuXHRcdFx0XHRcdH0gZWxzZVxuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGV4dGVuc2lvbiAnICsgdmFsdWUpXG5cdFx0XHRcdH1cblx0XHRcdGNhc2UgMHhkNTpcblx0XHRcdFx0Ly8gZml4ZXh0IDJcblx0XHRcdFx0dmFsdWUgPSBzcmNbcG9zaXRpb25dXG5cdFx0XHRcdGlmICh2YWx1ZSA9PSAweDcyKSB7XG5cdFx0XHRcdFx0cG9zaXRpb24rK1xuXHRcdFx0XHRcdHJldHVybiByZWNvcmREZWZpbml0aW9uKHNyY1twb3NpdGlvbisrXSAmIDB4M2YsIHNyY1twb3NpdGlvbisrXSlcblx0XHRcdFx0fSBlbHNlXG5cdFx0XHRcdFx0cmV0dXJuIHJlYWRFeHQoMilcblx0XHRcdGNhc2UgMHhkNjpcblx0XHRcdFx0Ly8gZml4ZXh0IDRcblx0XHRcdFx0cmV0dXJuIHJlYWRFeHQoNClcblx0XHRcdGNhc2UgMHhkNzpcblx0XHRcdFx0Ly8gZml4ZXh0IDhcblx0XHRcdFx0cmV0dXJuIHJlYWRFeHQoOClcblx0XHRcdGNhc2UgMHhkODpcblx0XHRcdFx0Ly8gZml4ZXh0IDE2XG5cdFx0XHRcdHJldHVybiByZWFkRXh0KDE2KVxuXHRcdFx0Y2FzZSAweGQ5OlxuXHRcdFx0Ly8gc3RyIDhcblx0XHRcdFx0dmFsdWUgPSBzcmNbcG9zaXRpb24rK11cblx0XHRcdFx0aWYgKHNyY1N0cmluZ0VuZCA+PSBwb3NpdGlvbikge1xuXHRcdFx0XHRcdHJldHVybiBzcmNTdHJpbmcuc2xpY2UocG9zaXRpb24gLSBzcmNTdHJpbmdTdGFydCwgKHBvc2l0aW9uICs9IHZhbHVlKSAtIHNyY1N0cmluZ1N0YXJ0KVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiByZWFkU3RyaW5nOCh2YWx1ZSlcblx0XHRcdGNhc2UgMHhkYTpcblx0XHRcdC8vIHN0ciAxNlxuXHRcdFx0XHR2YWx1ZSA9IGRhdGFWaWV3LmdldFVpbnQxNihwb3NpdGlvbilcblx0XHRcdFx0cG9zaXRpb24gKz0gMlxuXHRcdFx0XHRpZiAoc3JjU3RyaW5nRW5kID49IHBvc2l0aW9uKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHNyY1N0cmluZy5zbGljZShwb3NpdGlvbiAtIHNyY1N0cmluZ1N0YXJ0LCAocG9zaXRpb24gKz0gdmFsdWUpIC0gc3JjU3RyaW5nU3RhcnQpXG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHJlYWRTdHJpbmcxNih2YWx1ZSlcblx0XHRcdGNhc2UgMHhkYjpcblx0XHRcdC8vIHN0ciAzMlxuXHRcdFx0XHR2YWx1ZSA9IGRhdGFWaWV3LmdldFVpbnQzMihwb3NpdGlvbilcblx0XHRcdFx0cG9zaXRpb24gKz0gNFxuXHRcdFx0XHRpZiAoc3JjU3RyaW5nRW5kID49IHBvc2l0aW9uKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHNyY1N0cmluZy5zbGljZShwb3NpdGlvbiAtIHNyY1N0cmluZ1N0YXJ0LCAocG9zaXRpb24gKz0gdmFsdWUpIC0gc3JjU3RyaW5nU3RhcnQpXG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHJlYWRTdHJpbmczMih2YWx1ZSlcblx0XHRcdGNhc2UgMHhkYzpcblx0XHRcdC8vIGFycmF5IDE2XG5cdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0VWludDE2KHBvc2l0aW9uKVxuXHRcdFx0XHRwb3NpdGlvbiArPSAyXG5cdFx0XHRcdHJldHVybiByZWFkQXJyYXkodmFsdWUpXG5cdFx0XHRjYXNlIDB4ZGQ6XG5cdFx0XHQvLyBhcnJheSAzMlxuXHRcdFx0XHR2YWx1ZSA9IGRhdGFWaWV3LmdldFVpbnQzMihwb3NpdGlvbilcblx0XHRcdFx0cG9zaXRpb24gKz0gNFxuXHRcdFx0XHRyZXR1cm4gcmVhZEFycmF5KHZhbHVlKVxuXHRcdFx0Y2FzZSAweGRlOlxuXHRcdFx0Ly8gbWFwIDE2XG5cdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0VWludDE2KHBvc2l0aW9uKVxuXHRcdFx0XHRwb3NpdGlvbiArPSAyXG5cdFx0XHRcdHJldHVybiByZWFkTWFwKHZhbHVlKVxuXHRcdFx0Y2FzZSAweGRmOlxuXHRcdFx0Ly8gbWFwIDMyXG5cdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0VWludDMyKHBvc2l0aW9uKVxuXHRcdFx0XHRwb3NpdGlvbiArPSA0XG5cdFx0XHRcdHJldHVybiByZWFkTWFwKHZhbHVlKVxuXHRcdFx0ZGVmYXVsdDogLy8gbmVnYXRpdmUgaW50XG5cdFx0XHRcdGlmICh0b2tlbiA+PSAweGUwKVxuXHRcdFx0XHRcdHJldHVybiB0b2tlbiAtIDB4MTAwXG5cdFx0XHRcdGlmICh0b2tlbiA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0bGV0IGVycm9yID0gbmV3IEVycm9yKCdVbmV4cGVjdGVkIGVuZCBvZiBNZXNzYWdlUGFjayBkYXRhJylcblx0XHRcdFx0XHRlcnJvci5pbmNvbXBsZXRlID0gdHJ1ZVxuXHRcdFx0XHRcdHRocm93IGVycm9yXG5cdFx0XHRcdH1cblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbmtub3duIE1lc3NhZ2VQYWNrIHRva2VuICcgKyB0b2tlbilcblxuXHRcdH1cblx0fVxufVxuY29uc3QgdmFsaWROYW1lID0gL15bYS16QS1aXyRdW2EtekEtWlxcZF8kXSokL1xuZnVuY3Rpb24gY3JlYXRlU3RydWN0dXJlUmVhZGVyKHN0cnVjdHVyZSwgZmlyc3RJZCkge1xuXHRmdW5jdGlvbiByZWFkT2JqZWN0KCkge1xuXHRcdC8vIFRoaXMgaW5pdGlhbCBmdW5jdGlvbiBpcyBxdWljayB0byBpbnN0YW50aWF0ZSwgYnV0IHJ1bnMgc2xvd2VyLiBBZnRlciBzZXZlcmFsIGl0ZXJhdGlvbnMgcGF5IHRoZSBjb3N0IHRvIGJ1aWxkIHRoZSBmYXN0ZXIgZnVuY3Rpb25cblx0XHRpZiAocmVhZE9iamVjdC5jb3VudCsrID4gaW5saW5lT2JqZWN0UmVhZFRocmVzaG9sZCkge1xuXHRcdFx0bGV0IHJlYWRPYmplY3QgPSBzdHJ1Y3R1cmUucmVhZCA9IChuZXcgRnVuY3Rpb24oJ3InLCAncmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuICcgKyAoY3VycmVudFVucGFja3IuZnJlZXplRGF0YSA/ICdPYmplY3QuZnJlZXplJyA6ICcnKSArXG5cdFx0XHRcdCcoeycgKyBzdHJ1Y3R1cmUubWFwKGtleSA9PiBrZXkgPT09ICdfX3Byb3RvX18nID8gJ19fcHJvdG9fOnIoKScgOiB2YWxpZE5hbWUudGVzdChrZXkpID8ga2V5ICsgJzpyKCknIDogKCdbJyArIEpTT04uc3RyaW5naWZ5KGtleSkgKyAnXTpyKCknKSkuam9pbignLCcpICsgJ30pfScpKShyZWFkKVxuXHRcdFx0aWYgKHN0cnVjdHVyZS5oaWdoQnl0ZSA9PT0gMClcblx0XHRcdFx0c3RydWN0dXJlLnJlYWQgPSBjcmVhdGVTZWNvbmRCeXRlUmVhZGVyKGZpcnN0SWQsIHN0cnVjdHVyZS5yZWFkKVxuXHRcdFx0cmV0dXJuIHJlYWRPYmplY3QoKSAvLyBzZWNvbmQgYnl0ZSBpcyBhbHJlYWR5IHJlYWQsIGlmIHRoZXJlIGlzIG9uZSBzbyBpbW1lZGlhdGVseSByZWFkIG9iamVjdFxuXHRcdH1cblx0XHRsZXQgb2JqZWN0ID0ge31cblx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHN0cnVjdHVyZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdGxldCBrZXkgPSBzdHJ1Y3R1cmVbaV1cblx0XHRcdGlmIChrZXkgPT09ICdfX3Byb3RvX18nKVxuXHRcdFx0XHRrZXkgPSAnX19wcm90b18nXG5cdFx0XHRvYmplY3Rba2V5XSA9IHJlYWQoKVxuXHRcdH1cblx0XHRpZiAoY3VycmVudFVucGFja3IuZnJlZXplRGF0YSlcblx0XHRcdHJldHVybiBPYmplY3QuZnJlZXplKG9iamVjdCk7XG5cdFx0cmV0dXJuIG9iamVjdFxuXHR9XG5cdHJlYWRPYmplY3QuY291bnQgPSAwXG5cdGlmIChzdHJ1Y3R1cmUuaGlnaEJ5dGUgPT09IDApIHtcblx0XHRyZXR1cm4gY3JlYXRlU2Vjb25kQnl0ZVJlYWRlcihmaXJzdElkLCByZWFkT2JqZWN0KVxuXHR9XG5cdHJldHVybiByZWFkT2JqZWN0XG59XG5cbmNvbnN0IGNyZWF0ZVNlY29uZEJ5dGVSZWFkZXIgPSAoZmlyc3RJZCwgcmVhZDApID0+IHtcblx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdGxldCBoaWdoQnl0ZSA9IHNyY1twb3NpdGlvbisrXVxuXHRcdGlmIChoaWdoQnl0ZSA9PT0gMClcblx0XHRcdHJldHVybiByZWFkMCgpXG5cdFx0bGV0IGlkID0gZmlyc3RJZCA8IDMyID8gLShmaXJzdElkICsgKGhpZ2hCeXRlIDw8IDUpKSA6IGZpcnN0SWQgKyAoaGlnaEJ5dGUgPDwgNSlcblx0XHRsZXQgc3RydWN0dXJlID0gY3VycmVudFN0cnVjdHVyZXNbaWRdIHx8IGxvYWRTdHJ1Y3R1cmVzKClbaWRdXG5cdFx0aWYgKCFzdHJ1Y3R1cmUpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignUmVjb3JkIGlkIGlzIG5vdCBkZWZpbmVkIGZvciAnICsgaWQpXG5cdFx0fVxuXHRcdGlmICghc3RydWN0dXJlLnJlYWQpXG5cdFx0XHRzdHJ1Y3R1cmUucmVhZCA9IGNyZWF0ZVN0cnVjdHVyZVJlYWRlcihzdHJ1Y3R1cmUsIGZpcnN0SWQpXG5cdFx0cmV0dXJuIHN0cnVjdHVyZS5yZWFkKClcblx0fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9hZFN0cnVjdHVyZXMoKSB7XG5cdGxldCBsb2FkZWRTdHJ1Y3R1cmVzID0gc2F2ZVN0YXRlKCgpID0+IHtcblx0XHQvLyBzYXZlIHRoZSBzdGF0ZSBpbiBjYXNlIGdldFN0cnVjdHVyZXMgbW9kaWZpZXMgb3VyIGJ1ZmZlclxuXHRcdHNyYyA9IG51bGxcblx0XHRyZXR1cm4gY3VycmVudFVucGFja3IuZ2V0U3RydWN0dXJlcygpXG5cdH0pXG5cdHJldHVybiBjdXJyZW50U3RydWN0dXJlcyA9IGN1cnJlbnRVbnBhY2tyLl9tZXJnZVN0cnVjdHVyZXMobG9hZGVkU3RydWN0dXJlcywgY3VycmVudFN0cnVjdHVyZXMpXG59XG5cbnZhciByZWFkRml4ZWRTdHJpbmcgPSByZWFkU3RyaW5nSlNcbnZhciByZWFkU3RyaW5nOCA9IHJlYWRTdHJpbmdKU1xudmFyIHJlYWRTdHJpbmcxNiA9IHJlYWRTdHJpbmdKU1xudmFyIHJlYWRTdHJpbmczMiA9IHJlYWRTdHJpbmdKU1xuZXhwb3J0IGxldCBpc05hdGl2ZUFjY2VsZXJhdGlvbkVuYWJsZWQgPSBmYWxzZVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0RXh0cmFjdG9yKGV4dHJhY3RTdHJpbmdzKSB7XG5cdGlzTmF0aXZlQWNjZWxlcmF0aW9uRW5hYmxlZCA9IHRydWVcblx0cmVhZEZpeGVkU3RyaW5nID0gcmVhZFN0cmluZygxKVxuXHRyZWFkU3RyaW5nOCA9IHJlYWRTdHJpbmcoMilcblx0cmVhZFN0cmluZzE2ID0gcmVhZFN0cmluZygzKVxuXHRyZWFkU3RyaW5nMzIgPSByZWFkU3RyaW5nKDUpXG5cdGZ1bmN0aW9uIHJlYWRTdHJpbmcoaGVhZGVyTGVuZ3RoKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHJlYWRTdHJpbmcobGVuZ3RoKSB7XG5cdFx0XHRsZXQgc3RyaW5nID0gc3RyaW5nc1tzdHJpbmdQb3NpdGlvbisrXVxuXHRcdFx0aWYgKHN0cmluZyA9PSBudWxsKSB7XG5cdFx0XHRcdGlmIChidW5kbGVkU3RyaW5ncylcblx0XHRcdFx0XHRyZXR1cm4gcmVhZFN0cmluZ0pTKGxlbmd0aClcblx0XHRcdFx0bGV0IGJ5dGVPZmZzZXQgPSBzcmMuYnl0ZU9mZnNldFxuXHRcdFx0XHRsZXQgZXh0cmFjdGlvbiA9IGV4dHJhY3RTdHJpbmdzKHBvc2l0aW9uIC0gaGVhZGVyTGVuZ3RoICsgYnl0ZU9mZnNldCwgc3JjRW5kICsgYnl0ZU9mZnNldCwgc3JjLmJ1ZmZlcilcblx0XHRcdFx0aWYgKHR5cGVvZiBleHRyYWN0aW9uID09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0c3RyaW5nID0gZXh0cmFjdGlvblxuXHRcdFx0XHRcdHN0cmluZ3MgPSBFTVBUWV9BUlJBWVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0cmluZ3MgPSBleHRyYWN0aW9uXG5cdFx0XHRcdFx0c3RyaW5nUG9zaXRpb24gPSAxXG5cdFx0XHRcdFx0c3JjU3RyaW5nRW5kID0gMSAvLyBldmVuIGlmIGEgdXRmLTggc3RyaW5nIHdhcyBkZWNvZGVkLCBtdXN0IGluZGljYXRlIHdlIGFyZSBpbiB0aGUgbWlkc3Qgb2YgZXh0cmFjdGVkIHN0cmluZ3MgYW5kIGNhbid0IHNraXAgc3RyaW5nc1xuXHRcdFx0XHRcdHN0cmluZyA9IHN0cmluZ3NbMF1cblx0XHRcdFx0XHRpZiAoc3RyaW5nID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgZW5kIG9mIGJ1ZmZlcicpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGxldCBzcmNTdHJpbmdMZW5ndGggPSBzdHJpbmcubGVuZ3RoXG5cdFx0XHRpZiAoc3JjU3RyaW5nTGVuZ3RoIDw9IGxlbmd0aCkge1xuXHRcdFx0XHRwb3NpdGlvbiArPSBsZW5ndGhcblx0XHRcdFx0cmV0dXJuIHN0cmluZ1xuXHRcdFx0fVxuXHRcdFx0c3JjU3RyaW5nID0gc3RyaW5nXG5cdFx0XHRzcmNTdHJpbmdTdGFydCA9IHBvc2l0aW9uXG5cdFx0XHRzcmNTdHJpbmdFbmQgPSBwb3NpdGlvbiArIHNyY1N0cmluZ0xlbmd0aFxuXHRcdFx0cG9zaXRpb24gKz0gbGVuZ3RoXG5cdFx0XHRyZXR1cm4gc3RyaW5nLnNsaWNlKDAsIGxlbmd0aCkgLy8gd2Uga25vdyB3ZSBqdXN0IHdhbnQgdGhlIGJlZ2lubmluZ1xuXHRcdH1cblx0fVxufVxuZnVuY3Rpb24gcmVhZFN0cmluZ0pTKGxlbmd0aCkge1xuXHRsZXQgcmVzdWx0XG5cdGlmIChsZW5ndGggPCAxNikge1xuXHRcdGlmIChyZXN1bHQgPSBzaG9ydFN0cmluZ0luSlMobGVuZ3RoKSlcblx0XHRcdHJldHVybiByZXN1bHRcblx0fVxuXHRpZiAobGVuZ3RoID4gNjQgJiYgZGVjb2Rlcilcblx0XHRyZXR1cm4gZGVjb2Rlci5kZWNvZGUoc3JjLnN1YmFycmF5KHBvc2l0aW9uLCBwb3NpdGlvbiArPSBsZW5ndGgpKVxuXHRjb25zdCBlbmQgPSBwb3NpdGlvbiArIGxlbmd0aFxuXHRjb25zdCB1bml0cyA9IFtdXG5cdHJlc3VsdCA9ICcnXG5cdHdoaWxlIChwb3NpdGlvbiA8IGVuZCkge1xuXHRcdGNvbnN0IGJ5dGUxID0gc3JjW3Bvc2l0aW9uKytdXG5cdFx0aWYgKChieXRlMSAmIDB4ODApID09PSAwKSB7XG5cdFx0XHQvLyAxIGJ5dGVcblx0XHRcdHVuaXRzLnB1c2goYnl0ZTEpXG5cdFx0fSBlbHNlIGlmICgoYnl0ZTEgJiAweGUwKSA9PT0gMHhjMCkge1xuXHRcdFx0Ly8gMiBieXRlc1xuXHRcdFx0Y29uc3QgYnl0ZTIgPSBzcmNbcG9zaXRpb24rK10gJiAweDNmXG5cdFx0XHR1bml0cy5wdXNoKCgoYnl0ZTEgJiAweDFmKSA8PCA2KSB8IGJ5dGUyKVxuXHRcdH0gZWxzZSBpZiAoKGJ5dGUxICYgMHhmMCkgPT09IDB4ZTApIHtcblx0XHRcdC8vIDMgYnl0ZXNcblx0XHRcdGNvbnN0IGJ5dGUyID0gc3JjW3Bvc2l0aW9uKytdICYgMHgzZlxuXHRcdFx0Y29uc3QgYnl0ZTMgPSBzcmNbcG9zaXRpb24rK10gJiAweDNmXG5cdFx0XHR1bml0cy5wdXNoKCgoYnl0ZTEgJiAweDFmKSA8PCAxMikgfCAoYnl0ZTIgPDwgNikgfCBieXRlMylcblx0XHR9IGVsc2UgaWYgKChieXRlMSAmIDB4ZjgpID09PSAweGYwKSB7XG5cdFx0XHQvLyA0IGJ5dGVzXG5cdFx0XHRjb25zdCBieXRlMiA9IHNyY1twb3NpdGlvbisrXSAmIDB4M2Zcblx0XHRcdGNvbnN0IGJ5dGUzID0gc3JjW3Bvc2l0aW9uKytdICYgMHgzZlxuXHRcdFx0Y29uc3QgYnl0ZTQgPSBzcmNbcG9zaXRpb24rK10gJiAweDNmXG5cdFx0XHRsZXQgdW5pdCA9ICgoYnl0ZTEgJiAweDA3KSA8PCAweDEyKSB8IChieXRlMiA8PCAweDBjKSB8IChieXRlMyA8PCAweDA2KSB8IGJ5dGU0XG5cdFx0XHRpZiAodW5pdCA+IDB4ZmZmZikge1xuXHRcdFx0XHR1bml0IC09IDB4MTAwMDBcblx0XHRcdFx0dW5pdHMucHVzaCgoKHVuaXQgPj4+IDEwKSAmIDB4M2ZmKSB8IDB4ZDgwMClcblx0XHRcdFx0dW5pdCA9IDB4ZGMwMCB8ICh1bml0ICYgMHgzZmYpXG5cdFx0XHR9XG5cdFx0XHR1bml0cy5wdXNoKHVuaXQpXG5cdFx0fSBlbHNlIHtcblx0XHRcdHVuaXRzLnB1c2goYnl0ZTEpXG5cdFx0fVxuXG5cdFx0aWYgKHVuaXRzLmxlbmd0aCA+PSAweDEwMDApIHtcblx0XHRcdHJlc3VsdCArPSBmcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCB1bml0cylcblx0XHRcdHVuaXRzLmxlbmd0aCA9IDBcblx0XHR9XG5cdH1cblxuXHRpZiAodW5pdHMubGVuZ3RoID4gMCkge1xuXHRcdHJlc3VsdCArPSBmcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCB1bml0cylcblx0fVxuXG5cdHJldHVybiByZXN1bHRcbn1cbmV4cG9ydCBmdW5jdGlvbiByZWFkU3RyaW5nKHNvdXJjZSwgc3RhcnQsIGxlbmd0aCkge1xuXHRsZXQgZXhpc3RpbmdTcmMgPSBzcmM7XG5cdHNyYyA9IHNvdXJjZTtcblx0cG9zaXRpb24gPSBzdGFydDtcblx0dHJ5IHtcblx0XHRyZXR1cm4gcmVhZFN0cmluZ0pTKGxlbmd0aCk7XG5cdH0gZmluYWxseSB7XG5cdFx0c3JjID0gZXhpc3RpbmdTcmM7XG5cdH1cbn1cblxuZnVuY3Rpb24gcmVhZEFycmF5KGxlbmd0aCkge1xuXHRsZXQgYXJyYXkgPSBuZXcgQXJyYXkobGVuZ3RoKVxuXHRmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0YXJyYXlbaV0gPSByZWFkKClcblx0fVxuXHRpZiAoY3VycmVudFVucGFja3IuZnJlZXplRGF0YSlcblx0XHRyZXR1cm4gT2JqZWN0LmZyZWV6ZShhcnJheSlcblx0cmV0dXJuIGFycmF5XG59XG5cbmZ1bmN0aW9uIHJlYWRNYXAobGVuZ3RoKSB7XG5cdGlmIChjdXJyZW50VW5wYWNrci5tYXBzQXNPYmplY3RzKSB7XG5cdFx0bGV0IG9iamVjdCA9IHt9XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0bGV0IGtleSA9IHJlYWRLZXkoKVxuXHRcdFx0aWYgKGtleSA9PT0gJ19fcHJvdG9fXycpXG5cdFx0XHRcdGtleSA9ICdfX3Byb3RvXyc7XG5cdFx0XHRvYmplY3Rba2V5XSA9IHJlYWQoKVxuXHRcdH1cblx0XHRyZXR1cm4gb2JqZWN0XG5cdH0gZWxzZSB7XG5cdFx0bGV0IG1hcCA9IG5ldyBNYXAoKVxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdG1hcC5zZXQocmVhZCgpLCByZWFkKCkpXG5cdFx0fVxuXHRcdHJldHVybiBtYXBcblx0fVxufVxuXG52YXIgZnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZVxuZnVuY3Rpb24gbG9uZ1N0cmluZ0luSlMobGVuZ3RoKSB7XG5cdGxldCBzdGFydCA9IHBvc2l0aW9uXG5cdGxldCBieXRlcyA9IG5ldyBBcnJheShsZW5ndGgpXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRjb25zdCBieXRlID0gc3JjW3Bvc2l0aW9uKytdO1xuXHRcdGlmICgoYnl0ZSAmIDB4ODApID4gMCkge1xuXHRcdFx0XHRwb3NpdGlvbiA9IHN0YXJ0XG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0Ynl0ZXNbaV0gPSBieXRlXG5cdFx0fVxuXHRcdHJldHVybiBmcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBieXRlcylcbn1cbmZ1bmN0aW9uIHNob3J0U3RyaW5nSW5KUyhsZW5ndGgpIHtcblx0aWYgKGxlbmd0aCA8IDQpIHtcblx0XHRpZiAobGVuZ3RoIDwgMikge1xuXHRcdFx0aWYgKGxlbmd0aCA9PT0gMClcblx0XHRcdFx0cmV0dXJuICcnXG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0bGV0IGEgPSBzcmNbcG9zaXRpb24rK11cblx0XHRcdFx0aWYgKChhICYgMHg4MCkgPiAxKSB7XG5cdFx0XHRcdFx0cG9zaXRpb24gLT0gMVxuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmcm9tQ2hhckNvZGUoYSlcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0bGV0IGEgPSBzcmNbcG9zaXRpb24rK11cblx0XHRcdGxldCBiID0gc3JjW3Bvc2l0aW9uKytdXG5cdFx0XHRpZiAoKGEgJiAweDgwKSA+IDAgfHwgKGIgJiAweDgwKSA+IDApIHtcblx0XHRcdFx0cG9zaXRpb24gLT0gMlxuXHRcdFx0XHRyZXR1cm5cblx0XHRcdH1cblx0XHRcdGlmIChsZW5ndGggPCAzKVxuXHRcdFx0XHRyZXR1cm4gZnJvbUNoYXJDb2RlKGEsIGIpXG5cdFx0XHRsZXQgYyA9IHNyY1twb3NpdGlvbisrXVxuXHRcdFx0aWYgKChjICYgMHg4MCkgPiAwKSB7XG5cdFx0XHRcdHBvc2l0aW9uIC09IDNcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZnJvbUNoYXJDb2RlKGEsIGIsIGMpXG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGxldCBhID0gc3JjW3Bvc2l0aW9uKytdXG5cdFx0bGV0IGIgPSBzcmNbcG9zaXRpb24rK11cblx0XHRsZXQgYyA9IHNyY1twb3NpdGlvbisrXVxuXHRcdGxldCBkID0gc3JjW3Bvc2l0aW9uKytdXG5cdFx0aWYgKChhICYgMHg4MCkgPiAwIHx8IChiICYgMHg4MCkgPiAwIHx8IChjICYgMHg4MCkgPiAwIHx8IChkICYgMHg4MCkgPiAwKSB7XG5cdFx0XHRwb3NpdGlvbiAtPSA0XG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cdFx0aWYgKGxlbmd0aCA8IDYpIHtcblx0XHRcdGlmIChsZW5ndGggPT09IDQpXG5cdFx0XHRcdHJldHVybiBmcm9tQ2hhckNvZGUoYSwgYiwgYywgZClcblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRsZXQgZSA9IHNyY1twb3NpdGlvbisrXVxuXHRcdFx0XHRpZiAoKGUgJiAweDgwKSA+IDApIHtcblx0XHRcdFx0XHRwb3NpdGlvbiAtPSA1XG5cdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZyb21DaGFyQ29kZShhLCBiLCBjLCBkLCBlKVxuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAobGVuZ3RoIDwgOCkge1xuXHRcdFx0bGV0IGUgPSBzcmNbcG9zaXRpb24rK11cblx0XHRcdGxldCBmID0gc3JjW3Bvc2l0aW9uKytdXG5cdFx0XHRpZiAoKGUgJiAweDgwKSA+IDAgfHwgKGYgJiAweDgwKSA+IDApIHtcblx0XHRcdFx0cG9zaXRpb24gLT0gNlxuXHRcdFx0XHRyZXR1cm5cblx0XHRcdH1cblx0XHRcdGlmIChsZW5ndGggPCA3KVxuXHRcdFx0XHRyZXR1cm4gZnJvbUNoYXJDb2RlKGEsIGIsIGMsIGQsIGUsIGYpXG5cdFx0XHRsZXQgZyA9IHNyY1twb3NpdGlvbisrXVxuXHRcdFx0aWYgKChnICYgMHg4MCkgPiAwKSB7XG5cdFx0XHRcdHBvc2l0aW9uIC09IDdcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZnJvbUNoYXJDb2RlKGEsIGIsIGMsIGQsIGUsIGYsIGcpXG5cdFx0fSBlbHNlIHtcblx0XHRcdGxldCBlID0gc3JjW3Bvc2l0aW9uKytdXG5cdFx0XHRsZXQgZiA9IHNyY1twb3NpdGlvbisrXVxuXHRcdFx0bGV0IGcgPSBzcmNbcG9zaXRpb24rK11cblx0XHRcdGxldCBoID0gc3JjW3Bvc2l0aW9uKytdXG5cdFx0XHRpZiAoKGUgJiAweDgwKSA+IDAgfHwgKGYgJiAweDgwKSA+IDAgfHwgKGcgJiAweDgwKSA+IDAgfHwgKGggJiAweDgwKSA+IDApIHtcblx0XHRcdFx0cG9zaXRpb24gLT0gOFxuXHRcdFx0XHRyZXR1cm5cblx0XHRcdH1cblx0XHRcdGlmIChsZW5ndGggPCAxMCkge1xuXHRcdFx0XHRpZiAobGVuZ3RoID09PSA4KVxuXHRcdFx0XHRcdHJldHVybiBmcm9tQ2hhckNvZGUoYSwgYiwgYywgZCwgZSwgZiwgZywgaClcblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0bGV0IGkgPSBzcmNbcG9zaXRpb24rK11cblx0XHRcdFx0XHRpZiAoKGkgJiAweDgwKSA+IDApIHtcblx0XHRcdFx0XHRcdHBvc2l0aW9uIC09IDlcblx0XHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gZnJvbUNoYXJDb2RlKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgsIGkpXG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAobGVuZ3RoIDwgMTIpIHtcblx0XHRcdFx0bGV0IGkgPSBzcmNbcG9zaXRpb24rK11cblx0XHRcdFx0bGV0IGogPSBzcmNbcG9zaXRpb24rK11cblx0XHRcdFx0aWYgKChpICYgMHg4MCkgPiAwIHx8IChqICYgMHg4MCkgPiAwKSB7XG5cdFx0XHRcdFx0cG9zaXRpb24gLT0gMTBcblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobGVuZ3RoIDwgMTEpXG5cdFx0XHRcdFx0cmV0dXJuIGZyb21DaGFyQ29kZShhLCBiLCBjLCBkLCBlLCBmLCBnLCBoLCBpLCBqKVxuXHRcdFx0XHRsZXQgayA9IHNyY1twb3NpdGlvbisrXVxuXHRcdFx0XHRpZiAoKGsgJiAweDgwKSA+IDApIHtcblx0XHRcdFx0XHRwb3NpdGlvbiAtPSAxMVxuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmcm9tQ2hhckNvZGUoYSwgYiwgYywgZCwgZSwgZiwgZywgaCwgaSwgaiwgaylcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGxldCBpID0gc3JjW3Bvc2l0aW9uKytdXG5cdFx0XHRcdGxldCBqID0gc3JjW3Bvc2l0aW9uKytdXG5cdFx0XHRcdGxldCBrID0gc3JjW3Bvc2l0aW9uKytdXG5cdFx0XHRcdGxldCBsID0gc3JjW3Bvc2l0aW9uKytdXG5cdFx0XHRcdGlmICgoaSAmIDB4ODApID4gMCB8fCAoaiAmIDB4ODApID4gMCB8fCAoayAmIDB4ODApID4gMCB8fCAobCAmIDB4ODApID4gMCkge1xuXHRcdFx0XHRcdHBvc2l0aW9uIC09IDEyXG5cdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGxlbmd0aCA8IDE0KSB7XG5cdFx0XHRcdFx0aWYgKGxlbmd0aCA9PT0gMTIpXG5cdFx0XHRcdFx0XHRyZXR1cm4gZnJvbUNoYXJDb2RlKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgsIGksIGosIGssIGwpXG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRsZXQgbSA9IHNyY1twb3NpdGlvbisrXVxuXHRcdFx0XHRcdFx0aWYgKChtICYgMHg4MCkgPiAwKSB7XG5cdFx0XHRcdFx0XHRcdHBvc2l0aW9uIC09IDEzXG5cdFx0XHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmV0dXJuIGZyb21DaGFyQ29kZShhLCBiLCBjLCBkLCBlLCBmLCBnLCBoLCBpLCBqLCBrLCBsLCBtKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsZXQgbSA9IHNyY1twb3NpdGlvbisrXVxuXHRcdFx0XHRcdGxldCBuID0gc3JjW3Bvc2l0aW9uKytdXG5cdFx0XHRcdFx0aWYgKChtICYgMHg4MCkgPiAwIHx8IChuICYgMHg4MCkgPiAwKSB7XG5cdFx0XHRcdFx0XHRwb3NpdGlvbiAtPSAxNFxuXHRcdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChsZW5ndGggPCAxNSlcblx0XHRcdFx0XHRcdHJldHVybiBmcm9tQ2hhckNvZGUoYSwgYiwgYywgZCwgZSwgZiwgZywgaCwgaSwgaiwgaywgbCwgbSwgbilcblx0XHRcdFx0XHRsZXQgbyA9IHNyY1twb3NpdGlvbisrXVxuXHRcdFx0XHRcdGlmICgobyAmIDB4ODApID4gMCkge1xuXHRcdFx0XHRcdFx0cG9zaXRpb24gLT0gMTVcblx0XHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gZnJvbUNoYXJDb2RlKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgsIGksIGosIGssIGwsIG0sIG4sIG8pXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gcmVhZE9ubHlKU1N0cmluZygpIHtcblx0bGV0IHRva2VuID0gc3JjW3Bvc2l0aW9uKytdXG5cdGxldCBsZW5ndGhcblx0aWYgKHRva2VuIDwgMHhjMCkge1xuXHRcdC8vIGZpeHN0clxuXHRcdGxlbmd0aCA9IHRva2VuIC0gMHhhMFxuXHR9IGVsc2Uge1xuXHRcdHN3aXRjaCh0b2tlbikge1xuXHRcdFx0Y2FzZSAweGQ5OlxuXHRcdFx0Ly8gc3RyIDhcblx0XHRcdFx0bGVuZ3RoID0gc3JjW3Bvc2l0aW9uKytdXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRjYXNlIDB4ZGE6XG5cdFx0XHQvLyBzdHIgMTZcblx0XHRcdFx0bGVuZ3RoID0gZGF0YVZpZXcuZ2V0VWludDE2KHBvc2l0aW9uKVxuXHRcdFx0XHRwb3NpdGlvbiArPSAyXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRjYXNlIDB4ZGI6XG5cdFx0XHQvLyBzdHIgMzJcblx0XHRcdFx0bGVuZ3RoID0gZGF0YVZpZXcuZ2V0VWludDMyKHBvc2l0aW9uKVxuXHRcdFx0XHRwb3NpdGlvbiArPSA0XG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHN0cmluZycpXG5cdFx0fVxuXHR9XG5cdHJldHVybiByZWFkU3RyaW5nSlMobGVuZ3RoKVxufVxuXG5cbmZ1bmN0aW9uIHJlYWRCaW4obGVuZ3RoKSB7XG5cdHJldHVybiBjdXJyZW50VW5wYWNrci5jb3B5QnVmZmVycyA/XG5cdFx0Ly8gc3BlY2lmaWNhbGx5IHVzZSB0aGUgY29weWluZyBzbGljZSAobm90IHRoZSBub2RlIG9uZSlcblx0XHRVaW50OEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHNyYywgcG9zaXRpb24sIHBvc2l0aW9uICs9IGxlbmd0aCkgOlxuXHRcdHNyYy5zdWJhcnJheShwb3NpdGlvbiwgcG9zaXRpb24gKz0gbGVuZ3RoKVxufVxuZnVuY3Rpb24gcmVhZEV4dChsZW5ndGgpIHtcblx0bGV0IHR5cGUgPSBzcmNbcG9zaXRpb24rK11cblx0aWYgKGN1cnJlbnRFeHRlbnNpb25zW3R5cGVdKSB7XG5cdFx0bGV0IGVuZFxuXHRcdHJldHVybiBjdXJyZW50RXh0ZW5zaW9uc1t0eXBlXShzcmMuc3ViYXJyYXkocG9zaXRpb24sIGVuZCA9IChwb3NpdGlvbiArPSBsZW5ndGgpKSwgKHJlYWRQb3NpdGlvbikgPT4ge1xuXHRcdFx0cG9zaXRpb24gPSByZWFkUG9zaXRpb247XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRyZXR1cm4gcmVhZCgpO1xuXHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0cG9zaXRpb24gPSBlbmQ7XG5cdFx0XHR9XG5cdFx0fSlcblx0fVxuXHRlbHNlXG5cdFx0dGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGV4dGVuc2lvbiB0eXBlICcgKyB0eXBlKVxufVxuXG52YXIga2V5Q2FjaGUgPSBuZXcgQXJyYXkoNDA5NilcbmZ1bmN0aW9uIHJlYWRLZXkoKSB7XG5cdGxldCBsZW5ndGggPSBzcmNbcG9zaXRpb24rK11cblx0aWYgKGxlbmd0aCA+PSAweGEwICYmIGxlbmd0aCA8IDB4YzApIHtcblx0XHQvLyBmaXhzdHIsIHBvdGVudGlhbGx5IHVzZSBrZXkgY2FjaGVcblx0XHRsZW5ndGggPSBsZW5ndGggLSAweGEwXG5cdFx0aWYgKHNyY1N0cmluZ0VuZCA+PSBwb3NpdGlvbikgLy8gaWYgaXQgaGFzIGJlZW4gZXh0cmFjdGVkLCBtdXN0IHVzZSBpdCAoYW5kIGZhc3RlciBhbnl3YXkpXG5cdFx0XHRyZXR1cm4gc3JjU3RyaW5nLnNsaWNlKHBvc2l0aW9uIC0gc3JjU3RyaW5nU3RhcnQsIChwb3NpdGlvbiArPSBsZW5ndGgpIC0gc3JjU3RyaW5nU3RhcnQpXG5cdFx0ZWxzZSBpZiAoIShzcmNTdHJpbmdFbmQgPT0gMCAmJiBzcmNFbmQgPCAxODApKVxuXHRcdFx0cmV0dXJuIHJlYWRGaXhlZFN0cmluZyhsZW5ndGgpXG5cdH0gZWxzZSB7IC8vIG5vdCBjYWNoZWFibGUsIGdvIGJhY2sgYW5kIGRvIGEgc3RhbmRhcmQgcmVhZFxuXHRcdHBvc2l0aW9uLS1cblx0XHRyZXR1cm4gYXNTYWZlU3RyaW5nKHJlYWQoKSlcblx0fVxuXHRsZXQga2V5ID0gKChsZW5ndGggPDwgNSkgXiAobGVuZ3RoID4gMSA/IGRhdGFWaWV3LmdldFVpbnQxNihwb3NpdGlvbikgOiBsZW5ndGggPiAwID8gc3JjW3Bvc2l0aW9uXSA6IDApKSAmIDB4ZmZmXG5cdGxldCBlbnRyeSA9IGtleUNhY2hlW2tleV1cblx0bGV0IGNoZWNrUG9zaXRpb24gPSBwb3NpdGlvblxuXHRsZXQgZW5kID0gcG9zaXRpb24gKyBsZW5ndGggLSAzXG5cdGxldCBjaHVua1xuXHRsZXQgaSA9IDBcblx0aWYgKGVudHJ5ICYmIGVudHJ5LmJ5dGVzID09IGxlbmd0aCkge1xuXHRcdHdoaWxlIChjaGVja1Bvc2l0aW9uIDwgZW5kKSB7XG5cdFx0XHRjaHVuayA9IGRhdGFWaWV3LmdldFVpbnQzMihjaGVja1Bvc2l0aW9uKVxuXHRcdFx0aWYgKGNodW5rICE9IGVudHJ5W2krK10pIHtcblx0XHRcdFx0Y2hlY2tQb3NpdGlvbiA9IDB4NzAwMDAwMDBcblx0XHRcdFx0YnJlYWtcblx0XHRcdH1cblx0XHRcdGNoZWNrUG9zaXRpb24gKz0gNFxuXHRcdH1cblx0XHRlbmQgKz0gM1xuXHRcdHdoaWxlIChjaGVja1Bvc2l0aW9uIDwgZW5kKSB7XG5cdFx0XHRjaHVuayA9IHNyY1tjaGVja1Bvc2l0aW9uKytdXG5cdFx0XHRpZiAoY2h1bmsgIT0gZW50cnlbaSsrXSkge1xuXHRcdFx0XHRjaGVja1Bvc2l0aW9uID0gMHg3MDAwMDAwMFxuXHRcdFx0XHRicmVha1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoY2hlY2tQb3NpdGlvbiA9PT0gZW5kKSB7XG5cdFx0XHRwb3NpdGlvbiA9IGNoZWNrUG9zaXRpb25cblx0XHRcdHJldHVybiBlbnRyeS5zdHJpbmdcblx0XHR9XG5cdFx0ZW5kIC09IDNcblx0XHRjaGVja1Bvc2l0aW9uID0gcG9zaXRpb25cblx0fVxuXHRlbnRyeSA9IFtdXG5cdGtleUNhY2hlW2tleV0gPSBlbnRyeVxuXHRlbnRyeS5ieXRlcyA9IGxlbmd0aFxuXHR3aGlsZSAoY2hlY2tQb3NpdGlvbiA8IGVuZCkge1xuXHRcdGNodW5rID0gZGF0YVZpZXcuZ2V0VWludDMyKGNoZWNrUG9zaXRpb24pXG5cdFx0ZW50cnkucHVzaChjaHVuaylcblx0XHRjaGVja1Bvc2l0aW9uICs9IDRcblx0fVxuXHRlbmQgKz0gM1xuXHR3aGlsZSAoY2hlY2tQb3NpdGlvbiA8IGVuZCkge1xuXHRcdGNodW5rID0gc3JjW2NoZWNrUG9zaXRpb24rK11cblx0XHRlbnRyeS5wdXNoKGNodW5rKVxuXHR9XG5cdC8vIGZvciBzbWFsbCBibG9ja3MsIGF2b2lkaW5nIHRoZSBvdmVyaGVhZCBvZiB0aGUgZXh0cmFjdCBjYWxsIGlzIGhlbHBmdWxcblx0bGV0IHN0cmluZyA9IGxlbmd0aCA8IDE2ID8gc2hvcnRTdHJpbmdJbkpTKGxlbmd0aCkgOiBsb25nU3RyaW5nSW5KUyhsZW5ndGgpXG5cdGlmIChzdHJpbmcgIT0gbnVsbClcblx0XHRyZXR1cm4gZW50cnkuc3RyaW5nID0gc3RyaW5nXG5cdHJldHVybiBlbnRyeS5zdHJpbmcgPSByZWFkRml4ZWRTdHJpbmcobGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc1NhZmVTdHJpbmcocHJvcGVydHkpIHtcblx0Ly8gcHJvdGVjdCBhZ2FpbnN0IGV4cGVuc2l2ZSAoRG9TKSBzdHJpbmcgY29udmVyc2lvbnNcblx0aWYgKHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ3N0cmluZycpIHJldHVybiBwcm9wZXJ0eTtcblx0aWYgKHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHByb3BlcnR5ID09PSAnYm9vbGVhbicgfHwgdHlwZW9mIHByb3BlcnR5ID09PSAnYmlnaW50JykgcmV0dXJuIHByb3BlcnR5LnRvU3RyaW5nKCk7XG5cdGlmIChwcm9wZXJ0eSA9PSBudWxsKSByZXR1cm4gcHJvcGVydHkgKyAnJztcblx0aWYgKGN1cnJlbnRVbnBhY2tyLmFsbG93QXJyYXlzSW5NYXBLZXlzICYmIEFycmF5LmlzQXJyYXkocHJvcGVydHkpICYmIHByb3BlcnR5LmZsYXQoKS5ldmVyeShpdGVtID0+IFsnc3RyaW5nJywgJ251bWJlcicsICdib29sZWFuJywgJ2JpZ2ludCddLmluY2x1ZGVzKHR5cGVvZiBpdGVtKSkpIHtcblx0XHRyZXR1cm4gcHJvcGVydHkuZmxhdCgpLnRvU3RyaW5nKCk7XG5cdH1cblx0dGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHByb3BlcnR5IHR5cGUgZm9yIHJlY29yZDogJHt0eXBlb2YgcHJvcGVydHl9YCk7XG59XG4vLyB0aGUgcmVnaXN0cmF0aW9uIG9mIHRoZSByZWNvcmQgZGVmaW5pdGlvbiBleHRlbnNpb24gKGFzIFwiclwiKVxuY29uc3QgcmVjb3JkRGVmaW5pdGlvbiA9IChpZCwgaGlnaEJ5dGUpID0+IHtcblx0bGV0IHN0cnVjdHVyZSA9IHJlYWQoKS5tYXAoYXNTYWZlU3RyaW5nKSAvLyBlbnN1cmUgdGhhdCBhbGwga2V5cyBhcmUgc3RyaW5ncyBhbmRcblx0Ly8gdGhhdCB0aGUgYXJyYXkgaXMgbXV0YWJsZVxuXHRsZXQgZmlyc3RCeXRlID0gaWRcblx0aWYgKGhpZ2hCeXRlICE9PSB1bmRlZmluZWQpIHtcblx0XHRpZCA9IGlkIDwgMzIgPyAtKChoaWdoQnl0ZSA8PCA1KSArIGlkKSA6ICgoaGlnaEJ5dGUgPDwgNSkgKyBpZClcblx0XHRzdHJ1Y3R1cmUuaGlnaEJ5dGUgPSBoaWdoQnl0ZVxuXHR9XG5cdGxldCBleGlzdGluZ1N0cnVjdHVyZSA9IGN1cnJlbnRTdHJ1Y3R1cmVzW2lkXVxuXHQvLyBJZiBpdCBpcyBhIHNoYXJlZCBzdHJ1Y3R1cmUsIHdlIG5lZWQgdG8gcmVzdG9yZSBhbnkgY2hhbmdlcyBhZnRlciByZWFkaW5nLlxuXHQvLyBBbHNvIGluIHNlcXVlbnRpYWwgbW9kZSwgd2UgbWF5IGdldCBpbmNvbXBsZXRlIHJlYWRzIGFuZCB0aHVzIGVycm9ycywgYW5kIHdlIG5lZWQgdG8gcmVzdG9yZVxuXHQvLyB0byB0aGUgc3RhdGUgcHJpb3IgdG8gYW4gaW5jb21wbGV0ZSByZWFkIGluIG9yZGVyIHRvIHByb3Blcmx5IHJlc3VtZS5cblx0aWYgKGV4aXN0aW5nU3RydWN0dXJlICYmIChleGlzdGluZ1N0cnVjdHVyZS5pc1NoYXJlZCB8fCBzZXF1ZW50aWFsTW9kZSkpIHtcblx0XHQoY3VycmVudFN0cnVjdHVyZXMucmVzdG9yZVN0cnVjdHVyZXMgfHwgKGN1cnJlbnRTdHJ1Y3R1cmVzLnJlc3RvcmVTdHJ1Y3R1cmVzID0gW10pKVtpZF0gPSBleGlzdGluZ1N0cnVjdHVyZVxuXHR9XG5cdGN1cnJlbnRTdHJ1Y3R1cmVzW2lkXSA9IHN0cnVjdHVyZVxuXHRzdHJ1Y3R1cmUucmVhZCA9IGNyZWF0ZVN0cnVjdHVyZVJlYWRlcihzdHJ1Y3R1cmUsIGZpcnN0Qnl0ZSlcblx0cmV0dXJuIHN0cnVjdHVyZS5yZWFkKClcbn1cbmN1cnJlbnRFeHRlbnNpb25zWzBdID0gKCkgPT4ge30gLy8gbm90ZXBhY2sgZGVmaW5lcyBleHRlbnNpb24gMCB0byBtZWFuIHVuZGVmaW5lZCwgc28gdXNlIHRoYXQgYXMgdGhlIGRlZmF1bHQgaGVyZVxuY3VycmVudEV4dGVuc2lvbnNbMF0ubm9CdWZmZXIgPSB0cnVlXG5cbmN1cnJlbnRFeHRlbnNpb25zWzB4NDJdID0gZGF0YSA9PiB7XG5cdGxldCBoZWFkTGVuZ3RoID0gKGRhdGEuYnl0ZUxlbmd0aCAlIDgpIHx8IDhcblx0bGV0IGhlYWQgPSBCaWdJbnQoZGF0YVswXSAmIDB4ODAgPyBkYXRhWzBdIC0gMHgxMDAgOiBkYXRhWzBdKVxuXHRmb3IgKGxldCBpID0gMTsgaSA8IGhlYWRMZW5ndGg7IGkrKykge1xuXHRcdGhlYWQgPDw9IEJpZ0ludCg4KVxuXHRcdGhlYWQgKz0gQmlnSW50KGRhdGFbaV0pXG5cdH1cblx0aWYgKGRhdGEuYnl0ZUxlbmd0aCAhPT0gaGVhZExlbmd0aCkge1xuXHRcdGxldCB2aWV3ID0gbmV3IERhdGFWaWV3KGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIGRhdGEuYnl0ZUxlbmd0aClcblx0XHRsZXQgZGVjb2RlID0gKHN0YXJ0LCBlbmQpID0+IHtcblx0XHRcdGxldCBsZW5ndGggPSBlbmQgLSBzdGFydFxuXHRcdFx0aWYgKGxlbmd0aCA8PSA0MCkge1xuXHRcdFx0XHRsZXQgb3V0ID0gdmlldy5nZXRCaWdVaW50NjQoc3RhcnQpXG5cdFx0XHRcdGZvciAobGV0IGkgPSBzdGFydCArIDg7IGkgPCBlbmQ7IGkgKz0gOCkge1xuXHRcdFx0XHRcdG91dCA8PD0gQmlnSW50KDY0bilcblx0XHRcdFx0XHRvdXQgfD0gdmlldy5nZXRCaWdVaW50NjQoaSlcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gb3V0XG5cdFx0XHR9XG5cdFx0XHQvLyBpZiAobGVuZ3RoID09PSA4KSByZXR1cm4gdmlldy5nZXRCaWdVaW50NjQoc3RhcnQpXG5cdFx0XHRsZXQgbWlkZGxlID0gc3RhcnQgKyAobGVuZ3RoID4+IDQgPDwgMylcblx0XHRcdGxldCBsZWZ0ID0gZGVjb2RlKHN0YXJ0LCBtaWRkbGUpXG5cdFx0XHRsZXQgcmlnaHQgPSBkZWNvZGUobWlkZGxlLCBlbmQpXG5cdFx0XHRyZXR1cm4gKGxlZnQgPDwgQmlnSW50KChlbmQgLSBtaWRkbGUpICogOCkpIHwgcmlnaHRcblx0XHR9XG5cdFx0aGVhZCA9IChoZWFkIDw8IEJpZ0ludCgodmlldy5ieXRlTGVuZ3RoIC0gaGVhZExlbmd0aCkgKiA4KSkgfCBkZWNvZGUoaGVhZExlbmd0aCwgdmlldy5ieXRlTGVuZ3RoKVxuXHR9XG5cdHJldHVybiBoZWFkXG59XG5cbmxldCBlcnJvcnMgPSB7XG5cdEVycm9yLCBFdmFsRXJyb3IsIFJhbmdlRXJyb3IsIFJlZmVyZW5jZUVycm9yLCBTeW50YXhFcnJvciwgVHlwZUVycm9yLCBVUklFcnJvciwgQWdncmVnYXRlRXJyb3I6IHR5cGVvZiBBZ2dyZWdhdGVFcnJvciA9PT0gJ2Z1bmN0aW9uJyA/IEFnZ3JlZ2F0ZUVycm9yIDogbnVsbCxcbn1cbmN1cnJlbnRFeHRlbnNpb25zWzB4NjVdID0gKCkgPT4ge1xuXHRsZXQgZGF0YSA9IHJlYWQoKVxuXHRpZiAoIWVycm9yc1tkYXRhWzBdXSkge1xuXHRcdGxldCBlcnJvciA9IEVycm9yKGRhdGFbMV0sIHsgY2F1c2U6IGRhdGFbMl0gfSlcblx0XHRlcnJvci5uYW1lID0gZGF0YVswXVxuXHRcdHJldHVybiBlcnJvclxuXHR9XG5cdHJldHVybiBlcnJvcnNbZGF0YVswXV0oZGF0YVsxXSwgeyBjYXVzZTogZGF0YVsyXSB9KVxufVxuXG5jdXJyZW50RXh0ZW5zaW9uc1sweDY5XSA9IChkYXRhKSA9PiB7XG5cdC8vIGlkIGV4dGVuc2lvbiAoZm9yIHN0cnVjdHVyZWQgY2xvbmVzKVxuXHRpZiAoY3VycmVudFVucGFja3Iuc3RydWN0dXJlZENsb25lID09PSBmYWxzZSkgdGhyb3cgbmV3IEVycm9yKCdTdHJ1Y3R1cmVkIGNsb25lIGV4dGVuc2lvbiBpcyBkaXNhYmxlZCcpXG5cdGxldCBpZCA9IGRhdGFWaWV3LmdldFVpbnQzMihwb3NpdGlvbiAtIDQpXG5cdGlmICghcmVmZXJlbmNlTWFwKVxuXHRcdHJlZmVyZW5jZU1hcCA9IG5ldyBNYXAoKVxuXHRsZXQgdG9rZW4gPSBzcmNbcG9zaXRpb25dXG5cdGxldCB0YXJnZXRcblx0Ly8gVE9ETzogaGFuZGxlIGFueSBvdGhlciB0eXBlcyB0aGF0IGNhbiBjeWNsZSBhbmQgbWFrZSB0aGUgY29kZSBtb3JlIHJvYnVzdCBpZiB0aGVyZSBhcmUgb3RoZXIgZXh0ZW5zaW9uc1xuXHRpZiAodG9rZW4gPj0gMHg5MCAmJiB0b2tlbiA8IDB4YTAgfHwgdG9rZW4gPT0gMHhkYyB8fCB0b2tlbiA9PSAweGRkKVxuXHRcdHRhcmdldCA9IFtdXG5cdGVsc2UgaWYgKHRva2VuID49IDB4ODAgJiYgdG9rZW4gPCAweDkwIHx8IHRva2VuID09IDB4ZGUgfHwgdG9rZW4gPT0gMHhkZilcblx0XHR0YXJnZXQgPSBuZXcgTWFwKClcblx0ZWxzZSBpZiAoKHRva2VuID49IDB4YzcgJiYgdG9rZW4gPD0gMHhjOSB8fCB0b2tlbiA+PSAweGQ0ICYmIHRva2VuIDw9IDB4ZDgpICYmIHNyY1twb3NpdGlvbiArIDFdID09PSAweDczKVxuXHRcdHRhcmdldCA9IG5ldyBTZXQoKVxuXHRlbHNlXG5cdFx0dGFyZ2V0ID0ge31cblxuXHRsZXQgcmVmRW50cnkgPSB7IHRhcmdldCB9IC8vIGEgcGxhY2Vob2xkZXIgb2JqZWN0XG5cdHJlZmVyZW5jZU1hcC5zZXQoaWQsIHJlZkVudHJ5KVxuXHRsZXQgdGFyZ2V0UHJvcGVydGllcyA9IHJlYWQoKSAvLyByZWFkIHRoZSBuZXh0IHZhbHVlIGFzIHRoZSB0YXJnZXQgb2JqZWN0IHRvIGlkXG5cdGlmICghcmVmRW50cnkudXNlZCkge1xuXHRcdC8vIG5vIGN5Y2xlLCBjYW4ganVzdCB1c2UgdGhlIHJldHVybmVkIHJlYWQgb2JqZWN0XG5cdFx0cmV0dXJuIHJlZkVudHJ5LnRhcmdldCA9IHRhcmdldFByb3BlcnRpZXMgLy8gcmVwbGFjZSB0aGUgcGxhY2Vob2xkZXIgd2l0aCB0aGUgcmVhbCBvbmVcblx0fSBlbHNlIHtcblx0XHQvLyB0aGVyZSBpcyBhIGN5Y2xlLCBzbyB3ZSBoYXZlIHRvIGFzc2lnbiBwcm9wZXJ0aWVzIHRvIG9yaWdpbmFsIHRhcmdldFxuXHRcdE9iamVjdC5hc3NpZ24odGFyZ2V0LCB0YXJnZXRQcm9wZXJ0aWVzKVxuXHR9XG5cblx0Ly8gY29weSBvdmVyIG1hcC9zZXQgZW50cmllcyBpZiB3ZSdyZSBhYmxlIHRvXG5cdGlmICh0YXJnZXQgaW5zdGFuY2VvZiBNYXApXG5cdFx0Zm9yIChsZXQgW2ssIHZdIG9mIHRhcmdldFByb3BlcnRpZXMuZW50cmllcygpKSB0YXJnZXQuc2V0KGssIHYpXG5cdGlmICh0YXJnZXQgaW5zdGFuY2VvZiBTZXQpXG5cdFx0Zm9yIChsZXQgaSBvZiBBcnJheS5mcm9tKHRhcmdldFByb3BlcnRpZXMpKSB0YXJnZXQuYWRkKGkpXG5cdHJldHVybiB0YXJnZXRcbn1cblxuY3VycmVudEV4dGVuc2lvbnNbMHg3MF0gPSAoZGF0YSkgPT4ge1xuXHQvLyBwb2ludGVyIGV4dGVuc2lvbiAoZm9yIHN0cnVjdHVyZWQgY2xvbmVzKVxuXHRpZiAoY3VycmVudFVucGFja3Iuc3RydWN0dXJlZENsb25lID09PSBmYWxzZSkgdGhyb3cgbmV3IEVycm9yKCdTdHJ1Y3R1cmVkIGNsb25lIGV4dGVuc2lvbiBpcyBkaXNhYmxlZCcpXG5cdGxldCBpZCA9IGRhdGFWaWV3LmdldFVpbnQzMihwb3NpdGlvbiAtIDQpXG5cdGxldCByZWZFbnRyeSA9IHJlZmVyZW5jZU1hcC5nZXQoaWQpXG5cdHJlZkVudHJ5LnVzZWQgPSB0cnVlXG5cdHJldHVybiByZWZFbnRyeS50YXJnZXRcbn1cblxuY3VycmVudEV4dGVuc2lvbnNbMHg3M10gPSAoKSA9PiBuZXcgU2V0KHJlYWQoKSlcblxuZXhwb3J0IGNvbnN0IHR5cGVkQXJyYXlzID0gWydJbnQ4JywnVWludDgnLCdVaW50OENsYW1wZWQnLCdJbnQxNicsJ1VpbnQxNicsJ0ludDMyJywnVWludDMyJywnRmxvYXQzMicsJ0Zsb2F0NjQnLCdCaWdJbnQ2NCcsJ0JpZ1VpbnQ2NCddLm1hcCh0eXBlID0+IHR5cGUgKyAnQXJyYXknKVxuXG5sZXQgZ2xibCA9IHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JyA/IGdsb2JhbFRoaXMgOiB3aW5kb3c7XG5jdXJyZW50RXh0ZW5zaW9uc1sweDc0XSA9IChkYXRhKSA9PiB7XG5cdGxldCB0eXBlQ29kZSA9IGRhdGFbMF1cblx0Ly8gd2UgYWx3YXlzIGhhdmUgdG8gc2xpY2UgdG8gZ2V0IGEgbmV3IEFycmF5QnVmZmVyIHRoYXQgaXMgYWxpZ25lZFxuXHRsZXQgYnVmZmVyID0gVWludDhBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkYXRhLCAxKS5idWZmZXJcblxuXHRsZXQgdHlwZWRBcnJheU5hbWUgPSB0eXBlZEFycmF5c1t0eXBlQ29kZV1cblx0aWYgKCF0eXBlZEFycmF5TmFtZSkge1xuXHRcdGlmICh0eXBlQ29kZSA9PT0gMTYpIHJldHVybiBidWZmZXJcblx0XHRpZiAodHlwZUNvZGUgPT09IDE3KSByZXR1cm4gbmV3IERhdGFWaWV3KGJ1ZmZlcilcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIHR5cGVkIGFycmF5IGZvciBjb2RlICcgKyB0eXBlQ29kZSlcblx0fVxuXHRyZXR1cm4gbmV3IGdsYmxbdHlwZWRBcnJheU5hbWVdKGJ1ZmZlcilcbn1cbmN1cnJlbnRFeHRlbnNpb25zWzB4NzhdID0gKCkgPT4ge1xuXHRsZXQgZGF0YSA9IHJlYWQoKVxuXHRyZXR1cm4gbmV3IFJlZ0V4cChkYXRhWzBdLCBkYXRhWzFdKVxufVxuY29uc3QgVEVNUF9CVU5ETEUgPSBbXVxuY3VycmVudEV4dGVuc2lvbnNbMHg2Ml0gPSAoZGF0YSkgPT4ge1xuXHRsZXQgZGF0YVNpemUgPSAoZGF0YVswXSA8PCAyNCkgKyAoZGF0YVsxXSA8PCAxNikgKyAoZGF0YVsyXSA8PCA4KSArIGRhdGFbM11cblx0bGV0IGRhdGFQb3NpdGlvbiA9IHBvc2l0aW9uXG5cdHBvc2l0aW9uICs9IGRhdGFTaXplIC0gZGF0YS5sZW5ndGhcblx0YnVuZGxlZFN0cmluZ3MgPSBURU1QX0JVTkRMRVxuXHRidW5kbGVkU3RyaW5ncyA9IFtyZWFkT25seUpTU3RyaW5nKCksIHJlYWRPbmx5SlNTdHJpbmcoKV1cblx0YnVuZGxlZFN0cmluZ3MucG9zaXRpb24wID0gMFxuXHRidW5kbGVkU3RyaW5ncy5wb3NpdGlvbjEgPSAwXG5cdGJ1bmRsZWRTdHJpbmdzLnBvc3RCdW5kbGVQb3NpdGlvbiA9IHBvc2l0aW9uXG5cdHBvc2l0aW9uID0gZGF0YVBvc2l0aW9uXG5cdHJldHVybiByZWFkKClcbn1cblxuY3VycmVudEV4dGVuc2lvbnNbMHhmZl0gPSAoZGF0YSkgPT4ge1xuXHQvLyAzMi1iaXQgZGF0ZSBleHRlbnNpb25cblx0aWYgKGRhdGEubGVuZ3RoID09IDQpXG5cdFx0cmV0dXJuIG5ldyBEYXRlKChkYXRhWzBdICogMHgxMDAwMDAwICsgKGRhdGFbMV0gPDwgMTYpICsgKGRhdGFbMl0gPDwgOCkgKyBkYXRhWzNdKSAqIDEwMDApXG5cdGVsc2UgaWYgKGRhdGEubGVuZ3RoID09IDgpXG5cdFx0cmV0dXJuIG5ldyBEYXRlKFxuXHRcdFx0KChkYXRhWzBdIDw8IDIyKSArIChkYXRhWzFdIDw8IDE0KSArIChkYXRhWzJdIDw8IDYpICsgKGRhdGFbM10gPj4gMikpIC8gMTAwMDAwMCArXG5cdFx0XHQoKGRhdGFbM10gJiAweDMpICogMHgxMDAwMDAwMDAgKyBkYXRhWzRdICogMHgxMDAwMDAwICsgKGRhdGFbNV0gPDwgMTYpICsgKGRhdGFbNl0gPDwgOCkgKyBkYXRhWzddKSAqIDEwMDApXG5cdGVsc2UgaWYgKGRhdGEubGVuZ3RoID09IDEyKVxuXHRcdHJldHVybiBuZXcgRGF0ZShcblx0XHRcdCgoZGF0YVswXSA8PCAyNCkgKyAoZGF0YVsxXSA8PCAxNikgKyAoZGF0YVsyXSA8PCA4KSArIGRhdGFbM10pIC8gMTAwMDAwMCArXG5cdFx0XHQoKChkYXRhWzRdICYgMHg4MCkgPyAtMHgxMDAwMDAwMDAwMDAwIDogMCkgKyBkYXRhWzZdICogMHgxMDAwMDAwMDAwMCArIGRhdGFbN10gKiAweDEwMDAwMDAwMCArIGRhdGFbOF0gKiAweDEwMDAwMDAgKyAoZGF0YVs5XSA8PCAxNikgKyAoZGF0YVsxMF0gPDwgOCkgKyBkYXRhWzExXSkgKiAxMDAwKVxuXHRlbHNlXG5cdFx0cmV0dXJuIG5ldyBEYXRlKCdpbnZhbGlkJylcbn1cbi8vIHJlZ2lzdHJhdGlvbiBvZiBidWxrIHJlY29yZCBkZWZpbml0aW9uP1xuLy8gY3VycmVudEV4dGVuc2lvbnNbMHg1Ml0gPSAoKSA9PlxuXG5mdW5jdGlvbiBzYXZlU3RhdGUoY2FsbGJhY2spIHtcblx0aWYgKG9uU2F2ZVN0YXRlKVxuXHRcdG9uU2F2ZVN0YXRlKCk7XG5cdGxldCBzYXZlZFNyY0VuZCA9IHNyY0VuZFxuXHRsZXQgc2F2ZWRQb3NpdGlvbiA9IHBvc2l0aW9uXG5cdGxldCBzYXZlZFN0cmluZ1Bvc2l0aW9uID0gc3RyaW5nUG9zaXRpb25cblx0bGV0IHNhdmVkU3JjU3RyaW5nU3RhcnQgPSBzcmNTdHJpbmdTdGFydFxuXHRsZXQgc2F2ZWRTcmNTdHJpbmdFbmQgPSBzcmNTdHJpbmdFbmRcblx0bGV0IHNhdmVkU3JjU3RyaW5nID0gc3JjU3RyaW5nXG5cdGxldCBzYXZlZFN0cmluZ3MgPSBzdHJpbmdzXG5cdGxldCBzYXZlZFJlZmVyZW5jZU1hcCA9IHJlZmVyZW5jZU1hcFxuXHRsZXQgc2F2ZWRCdW5kbGVkU3RyaW5ncyA9IGJ1bmRsZWRTdHJpbmdzXG5cblx0Ly8gVE9ETzogV2UgbWF5IG5lZWQgdG8gcmV2aXNpdCB0aGlzIGlmIHdlIGRvIG1vcmUgZXh0ZXJuYWwgY2FsbHMgdG8gdXNlciBjb2RlIChzaW5jZSBpdCBjb3VsZCBiZSBzbG93KVxuXHRsZXQgc2F2ZWRTcmMgPSBuZXcgVWludDhBcnJheShzcmMuc2xpY2UoMCwgc3JjRW5kKSkgLy8gd2UgY29weSB0aGUgZGF0YSBpbiBjYXNlIGl0IGNoYW5nZXMgd2hpbGUgZXh0ZXJuYWwgZGF0YSBpcyBwcm9jZXNzZWRcblx0bGV0IHNhdmVkU3RydWN0dXJlcyA9IGN1cnJlbnRTdHJ1Y3R1cmVzXG5cdGxldCBzYXZlZFN0cnVjdHVyZXNDb250ZW50cyA9IGN1cnJlbnRTdHJ1Y3R1cmVzLnNsaWNlKDAsIGN1cnJlbnRTdHJ1Y3R1cmVzLmxlbmd0aClcblx0bGV0IHNhdmVkUGFja3IgPSBjdXJyZW50VW5wYWNrclxuXHRsZXQgc2F2ZWRTZXF1ZW50aWFsTW9kZSA9IHNlcXVlbnRpYWxNb2RlXG5cdGxldCB2YWx1ZSA9IGNhbGxiYWNrKClcblx0c3JjRW5kID0gc2F2ZWRTcmNFbmRcblx0cG9zaXRpb24gPSBzYXZlZFBvc2l0aW9uXG5cdHN0cmluZ1Bvc2l0aW9uID0gc2F2ZWRTdHJpbmdQb3NpdGlvblxuXHRzcmNTdHJpbmdTdGFydCA9IHNhdmVkU3JjU3RyaW5nU3RhcnRcblx0c3JjU3RyaW5nRW5kID0gc2F2ZWRTcmNTdHJpbmdFbmRcblx0c3JjU3RyaW5nID0gc2F2ZWRTcmNTdHJpbmdcblx0c3RyaW5ncyA9IHNhdmVkU3RyaW5nc1xuXHRyZWZlcmVuY2VNYXAgPSBzYXZlZFJlZmVyZW5jZU1hcFxuXHRidW5kbGVkU3RyaW5ncyA9IHNhdmVkQnVuZGxlZFN0cmluZ3Ncblx0c3JjID0gc2F2ZWRTcmNcblx0c2VxdWVudGlhbE1vZGUgPSBzYXZlZFNlcXVlbnRpYWxNb2RlXG5cdGN1cnJlbnRTdHJ1Y3R1cmVzID0gc2F2ZWRTdHJ1Y3R1cmVzXG5cdGN1cnJlbnRTdHJ1Y3R1cmVzLnNwbGljZSgwLCBjdXJyZW50U3RydWN0dXJlcy5sZW5ndGgsIC4uLnNhdmVkU3RydWN0dXJlc0NvbnRlbnRzKVxuXHRjdXJyZW50VW5wYWNrciA9IHNhdmVkUGFja3Jcblx0ZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoc3JjLmJ1ZmZlciwgc3JjLmJ5dGVPZmZzZXQsIHNyYy5ieXRlTGVuZ3RoKVxuXHRyZXR1cm4gdmFsdWVcbn1cbmV4cG9ydCBmdW5jdGlvbiBjbGVhclNvdXJjZSgpIHtcblx0c3JjID0gbnVsbFxuXHRyZWZlcmVuY2VNYXAgPSBudWxsXG5cdGN1cnJlbnRTdHJ1Y3R1cmVzID0gbnVsbFxufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkRXh0ZW5zaW9uKGV4dGVuc2lvbikge1xuXHRpZiAoZXh0ZW5zaW9uLnVucGFjaylcblx0XHRjdXJyZW50RXh0ZW5zaW9uc1tleHRlbnNpb24udHlwZV0gPSBleHRlbnNpb24udW5wYWNrXG5cdGVsc2Vcblx0XHRjdXJyZW50RXh0ZW5zaW9uc1tleHRlbnNpb24udHlwZV0gPSBleHRlbnNpb25cbn1cblxuZXhwb3J0IGNvbnN0IG11bHQxMCA9IG5ldyBBcnJheSgxNDcpIC8vIHRoaXMgaXMgYSB0YWJsZSBtYXRjaGluZyBiaW5hcnkgZXhwb25lbnRzIHRvIHRoZSBtdWx0aXBsaWVyIHRvIGRldGVybWluZSBzaWduaWZpY2FudCBkaWdpdCByb3VuZGluZ1xuZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuXHRtdWx0MTBbaV0gPSArKCcxZScgKyBNYXRoLmZsb29yKDQ1LjE1IC0gaSAqIDAuMzAxMDMpKVxufVxuZXhwb3J0IGNvbnN0IERlY29kZXIgPSBVbnBhY2tyXG52YXIgZGVmYXVsdFVucGFja3IgPSBuZXcgVW5wYWNrcih7IHVzZVJlY29yZHM6IGZhbHNlIH0pXG5leHBvcnQgY29uc3QgdW5wYWNrID0gZGVmYXVsdFVucGFja3IudW5wYWNrXG5leHBvcnQgY29uc3QgdW5wYWNrTXVsdGlwbGUgPSBkZWZhdWx0VW5wYWNrci51bnBhY2tNdWx0aXBsZVxuZXhwb3J0IGNvbnN0IGRlY29kZSA9IGRlZmF1bHRVbnBhY2tyLnVucGFja1xuZXhwb3J0IGNvbnN0IEZMT0FUMzJfT1BUSU9OUyA9IHtcblx0TkVWRVI6IDAsXG5cdEFMV0FZUzogMSxcblx0REVDSU1BTF9ST1VORDogMyxcblx0REVDSU1BTF9GSVQ6IDRcbn1cbmxldCBmMzJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoMSlcbmxldCB1OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZjMyQXJyYXkuYnVmZmVyLCAwLCA0KVxuZXhwb3J0IGZ1bmN0aW9uIHJvdW5kRmxvYXQzMihmbG9hdDMyTnVtYmVyKSB7XG5cdGYzMkFycmF5WzBdID0gZmxvYXQzMk51bWJlclxuXHRsZXQgbXVsdGlwbGllciA9IG11bHQxMFsoKHU4QXJyYXlbM10gJiAweDdmKSA8PCAxKSB8ICh1OEFycmF5WzJdID4+IDcpXVxuXHRyZXR1cm4gKChtdWx0aXBsaWVyICogZmxvYXQzMk51bWJlciArIChmbG9hdDMyTnVtYmVyID4gMCA/IDAuNSA6IC0wLjUpKSA+PiAwKSAvIG11bHRpcGxpZXJcbn1cbmV4cG9ydCBmdW5jdGlvbiBzZXRSZWFkU3RydWN0KHVwZGF0ZWRSZWFkU3RydWN0LCBsb2FkZWRTdHJ1Y3RzLCBzYXZlU3RhdGUpIHtcblx0cmVhZFN0cnVjdCA9IHVwZGF0ZWRSZWFkU3RydWN0O1xuXHRvbkxvYWRlZFN0cnVjdHVyZXMgPSBsb2FkZWRTdHJ1Y3RzO1xuXHRvblNhdmVTdGF0ZSA9IHNhdmVTdGF0ZTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/../../node_modules/msgpackr/unpack.js\n");

/***/ })

};
;